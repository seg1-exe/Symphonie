(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_symfony_stimulus-bridge_dist_index_js-node_modules_axios_index_js-node_m-d63cad"],{

/***/ "./node_modules/@hotwired/stimulus/dist/stimulus.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hotwired/stimulus/dist/stimulus.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* binding */ Application),
/* harmony export */   "AttributeObserver": () => (/* binding */ AttributeObserver),
/* harmony export */   "Context": () => (/* binding */ Context),
/* harmony export */   "Controller": () => (/* binding */ Controller),
/* harmony export */   "ElementObserver": () => (/* binding */ ElementObserver),
/* harmony export */   "IndexedMultimap": () => (/* binding */ IndexedMultimap),
/* harmony export */   "Multimap": () => (/* binding */ Multimap),
/* harmony export */   "StringMapObserver": () => (/* binding */ StringMapObserver),
/* harmony export */   "TokenListObserver": () => (/* binding */ TokenListObserver),
/* harmony export */   "ValueListObserver": () => (/* binding */ ValueListObserver),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "defaultSchema": () => (/* binding */ defaultSchema),
/* harmony export */   "del": () => (/* binding */ del),
/* harmony export */   "fetch": () => (/* binding */ fetch),
/* harmony export */   "prune": () => (/* binding */ prune)
/* harmony export */ });
/*
Stimulus 3.0.1
Copyright Â© 2021 Basecamp, LLC
 */
class EventListener {
    constructor(eventTarget, eventName, eventOptions) {
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this.eventOptions = eventOptions;
        this.unorderedBindings = new Set();
    }
    connect() {
        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
        this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
        this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
        const extendedEvent = extendEvent(event);
        for (const binding of this.bindings) {
            if (extendedEvent.immediatePropagationStopped) {
                break;
            }
            else {
                binding.handleEvent(extendedEvent);
            }
        }
    }
    get bindings() {
        return Array.from(this.unorderedBindings).sort((left, right) => {
            const leftIndex = left.index, rightIndex = right.index;
            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
        });
    }
}
function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
        return event;
    }
    else {
        const { stopImmediatePropagation } = event;
        return Object.assign(event, {
            immediatePropagationStopped: false,
            stopImmediatePropagation() {
                this.immediatePropagationStopped = true;
                stopImmediatePropagation.call(this);
            }
        });
    }
}

class Dispatcher {
    constructor(application) {
        this.application = application;
        this.eventListenerMaps = new Map;
        this.started = false;
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.eventListeners.forEach(eventListener => eventListener.connect());
        }
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.eventListeners.forEach(eventListener => eventListener.disconnect());
        }
    }
    get eventListeners() {
        return Array.from(this.eventListenerMaps.values())
            .reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
        this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding) {
        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    }
    handleError(error, message, detail = {}) {
        this.application.handleError(error, `Error ${message}`, detail);
    }
    fetchEventListenerForBinding(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        let eventListener = eventListenerMap.get(cacheKey);
        if (!eventListener) {
            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
            eventListenerMap.set(cacheKey, eventListener);
        }
        return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
        const eventListener = new EventListener(eventTarget, eventName, eventOptions);
        if (this.started) {
            eventListener.connect();
        }
        return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
        let eventListenerMap = this.eventListenerMaps.get(eventTarget);
        if (!eventListenerMap) {
            eventListenerMap = new Map;
            this.eventListenerMaps.set(eventTarget, eventListenerMap);
        }
        return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
        const parts = [eventName];
        Object.keys(eventOptions).sort().forEach(key => {
            parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
        });
        return parts.join(":");
    }
}

const descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    return {
        eventTarget: parseEventTarget(matches[4]),
        eventName: matches[2],
        eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
        identifier: matches[5],
        methodName: matches[7]
    };
}
function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
        return window;
    }
    else if (eventTargetName == "document") {
        return document;
    }
}
function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
        return "window";
    }
    else if (eventTarget == document) {
        return "document";
    }
}

function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
}

class Action {
    constructor(element, index, descriptor) {
        this.element = element;
        this.index = index;
        this.eventTarget = descriptor.eventTarget || element;
        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
        this.eventOptions = descriptor.eventOptions || {};
        this.identifier = descriptor.identifier || error("missing identifier");
        this.methodName = descriptor.methodName || error("missing method name");
    }
    static forToken(token) {
        return new this(token.element, token.index, parseActionDescriptorString(token.content));
    }
    toString() {
        const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
        return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
    }
    get params() {
        if (this.eventTarget instanceof Element) {
            return this.getParamsFromEventTargetAttributes(this.eventTarget);
        }
        else {
            return {};
        }
    }
    getParamsFromEventTargetAttributes(eventTarget) {
        const params = {};
        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
        const attributes = Array.from(eventTarget.attributes);
        attributes.forEach(({ name, value }) => {
            const match = name.match(pattern);
            const key = match && match[1];
            if (key) {
                Object.assign(params, { [camelize(key)]: typecast(value) });
            }
        });
        return params;
    }
    get eventTargetName() {
        return stringifyEventTarget(this.eventTarget);
    }
}
const defaultEventNames = {
    "a": e => "click",
    "button": e => "click",
    "form": e => "submit",
    "details": e => "toggle",
    "input": e => e.getAttribute("type") == "submit" ? "click" : "input",
    "select": e => "change",
    "textarea": e => "input"
};
function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
        return defaultEventNames[tagName](element);
    }
}
function error(message) {
    throw new Error(message);
}
function typecast(value) {
    try {
        return JSON.parse(value);
    }
    catch (o_O) {
        return value;
    }
}

class Binding {
    constructor(context, action) {
        this.context = context;
        this.action = action;
    }
    get index() {
        return this.action.index;
    }
    get eventTarget() {
        return this.action.eventTarget;
    }
    get eventOptions() {
        return this.action.eventOptions;
    }
    get identifier() {
        return this.context.identifier;
    }
    handleEvent(event) {
        if (this.willBeInvokedByEvent(event)) {
            this.invokeWithEvent(event);
        }
    }
    get eventName() {
        return this.action.eventName;
    }
    get method() {
        const method = this.controller[this.methodName];
        if (typeof method == "function") {
            return method;
        }
        throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    invokeWithEvent(event) {
        const { target, currentTarget } = event;
        try {
            const { params } = this.action;
            const actionEvent = Object.assign(event, { params });
            this.method.call(this.controller, actionEvent);
            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
        }
        catch (error) {
            const { identifier, controller, element, index } = this;
            const detail = { identifier, controller, element, index, event };
            this.context.handleError(error, `invoking action "${this.action}"`, detail);
        }
    }
    willBeInvokedByEvent(event) {
        const eventTarget = event.target;
        if (this.element === eventTarget) {
            return true;
        }
        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
            return this.scope.containsElement(eventTarget);
        }
        else {
            return this.scope.containsElement(this.action.element);
        }
    }
    get controller() {
        return this.context.controller;
    }
    get methodName() {
        return this.action.methodName;
    }
    get element() {
        return this.scope.element;
    }
    get scope() {
        return this.context.scope;
    }
}

class ElementObserver {
    constructor(element, delegate) {
        this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
        this.element = element;
        this.started = false;
        this.delegate = delegate;
        this.elements = new Set;
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.refresh();
        }
    }
    pause(callback) {
        if (this.started) {
            this.mutationObserver.disconnect();
            this.started = false;
        }
        callback();
        if (!this.started) {
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.started = true;
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            const matches = new Set(this.matchElementsInTree());
            for (const element of Array.from(this.elements)) {
                if (!matches.has(element)) {
                    this.removeElement(element);
                }
            }
            for (const element of Array.from(matches)) {
                this.addElement(element);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        if (mutation.type == "attributes") {
            this.processAttributeChange(mutation.target, mutation.attributeName);
        }
        else if (mutation.type == "childList") {
            this.processRemovedNodes(mutation.removedNodes);
            this.processAddedNodes(mutation.addedNodes);
        }
    }
    processAttributeChange(node, attributeName) {
        const element = node;
        if (this.elements.has(element)) {
            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
                this.delegate.elementAttributeChanged(element, attributeName);
            }
            else {
                this.removeElement(element);
            }
        }
        else if (this.matchElement(element)) {
            this.addElement(element);
        }
    }
    processRemovedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element) {
                this.processTree(element, this.removeElement);
            }
        }
    }
    processAddedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element && this.elementIsActive(element)) {
                this.processTree(element, this.addElement);
            }
        }
    }
    matchElement(element) {
        return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
        return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
        for (const element of this.matchElementsInTree(tree)) {
            processor.call(this, element);
        }
    }
    elementFromNode(node) {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return node;
        }
    }
    elementIsActive(element) {
        if (element.isConnected != this.element.isConnected) {
            return false;
        }
        else {
            return this.element.contains(element);
        }
    }
    addElement(element) {
        if (!this.elements.has(element)) {
            if (this.elementIsActive(element)) {
                this.elements.add(element);
                if (this.delegate.elementMatched) {
                    this.delegate.elementMatched(element);
                }
            }
        }
    }
    removeElement(element) {
        if (this.elements.has(element)) {
            this.elements.delete(element);
            if (this.delegate.elementUnmatched) {
                this.delegate.elementUnmatched(element);
            }
        }
    }
}

class AttributeObserver {
    constructor(element, attributeName, delegate) {
        this.attributeName = attributeName;
        this.delegate = delegate;
        this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
        return this.elementObserver.element;
    }
    get selector() {
        return `[${this.attributeName}]`;
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get started() {
        return this.elementObserver.started;
    }
    matchElement(element) {
        return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(this.selector));
        return match.concat(matches);
    }
    elementMatched(element) {
        if (this.delegate.elementMatchedAttribute) {
            this.delegate.elementMatchedAttribute(element, this.attributeName);
        }
    }
    elementUnmatched(element) {
        if (this.delegate.elementUnmatchedAttribute) {
            this.delegate.elementUnmatchedAttribute(element, this.attributeName);
        }
    }
    elementAttributeChanged(element, attributeName) {
        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
            this.delegate.elementAttributeValueChanged(element, attributeName);
        }
    }
}

class StringMapObserver {
    constructor(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        this.started = false;
        this.stringMap = new Map;
        this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
            this.refresh();
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            for (const attributeName of this.knownAttributeNames) {
                this.refreshAttribute(attributeName, null);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        const attributeName = mutation.attributeName;
        if (attributeName) {
            this.refreshAttribute(attributeName, mutation.oldValue);
        }
    }
    refreshAttribute(attributeName, oldValue) {
        const key = this.delegate.getStringMapKeyForAttribute(attributeName);
        if (key != null) {
            if (!this.stringMap.has(attributeName)) {
                this.stringMapKeyAdded(key, attributeName);
            }
            const value = this.element.getAttribute(attributeName);
            if (this.stringMap.get(attributeName) != value) {
                this.stringMapValueChanged(value, key, oldValue);
            }
            if (value == null) {
                const oldValue = this.stringMap.get(attributeName);
                this.stringMap.delete(attributeName);
                if (oldValue)
                    this.stringMapKeyRemoved(key, attributeName, oldValue);
            }
            else {
                this.stringMap.set(attributeName, value);
            }
        }
    }
    stringMapKeyAdded(key, attributeName) {
        if (this.delegate.stringMapKeyAdded) {
            this.delegate.stringMapKeyAdded(key, attributeName);
        }
    }
    stringMapValueChanged(value, key, oldValue) {
        if (this.delegate.stringMapValueChanged) {
            this.delegate.stringMapValueChanged(value, key, oldValue);
        }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        if (this.delegate.stringMapKeyRemoved) {
            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
        }
    }
    get knownAttributeNames() {
        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
        return Array.from(this.element.attributes).map(attribute => attribute.name);
    }
    get recordedAttributeNames() {
        return Array.from(this.stringMap.keys());
    }
}

function add(map, key, value) {
    fetch(map, key).add(value);
}
function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
}
function fetch(map, key) {
    let values = map.get(key);
    if (!values) {
        values = new Set();
        map.set(key, values);
    }
    return values;
}
function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
        map.delete(key);
    }
}

class Multimap {
    constructor() {
        this.valuesByKey = new Map();
    }
    get keys() {
        return Array.from(this.valuesByKey.keys());
    }
    get values() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
        add(this.valuesByKey, key, value);
    }
    delete(key, value) {
        del(this.valuesByKey, key, value);
    }
    has(key, value) {
        const values = this.valuesByKey.get(key);
        return values != null && values.has(value);
    }
    hasKey(key) {
        return this.valuesByKey.has(key);
    }
    hasValue(value) {
        const sets = Array.from(this.valuesByKey.values());
        return sets.some(set => set.has(value));
    }
    getValuesForKey(key) {
        const values = this.valuesByKey.get(key);
        return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
        return Array.from(this.valuesByKey)
            .filter(([key, values]) => values.has(value))
            .map(([key, values]) => key);
    }
}

class IndexedMultimap extends Multimap {
    constructor() {
        super();
        this.keysByValue = new Map;
    }
    get values() {
        return Array.from(this.keysByValue.keys());
    }
    add(key, value) {
        super.add(key, value);
        add(this.keysByValue, value, key);
    }
    delete(key, value) {
        super.delete(key, value);
        del(this.keysByValue, value, key);
    }
    hasValue(value) {
        return this.keysByValue.has(value);
    }
    getKeysForValue(value) {
        const set = this.keysByValue.get(value);
        return set ? Array.from(set) : [];
    }
}

class TokenListObserver {
    constructor(element, attributeName, delegate) {
        this.attributeObserver = new AttributeObserver(element, attributeName, this);
        this.delegate = delegate;
        this.tokensByElement = new Multimap;
    }
    get started() {
        return this.attributeObserver.started;
    }
    start() {
        this.attributeObserver.start();
    }
    pause(callback) {
        this.attributeObserver.pause(callback);
    }
    stop() {
        this.attributeObserver.stop();
    }
    refresh() {
        this.attributeObserver.refresh();
    }
    get element() {
        return this.attributeObserver.element;
    }
    get attributeName() {
        return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
        this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
        this.tokensUnmatched(unmatchedTokens);
        this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
        tokens.forEach(token => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
        tokens.forEach(token => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
        this.delegate.tokenMatched(token);
        this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
        this.delegate.tokenUnmatched(token);
        this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
        const previousTokens = this.tokensByElement.getValuesForKey(element);
        const currentTokens = this.readTokensForElement(element);
        const firstDifferingIndex = zip(previousTokens, currentTokens)
            .findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
        if (firstDifferingIndex == -1) {
            return [[], []];
        }
        else {
            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
        }
    }
    readTokensForElement(element) {
        const attributeName = this.attributeName;
        const tokenString = element.getAttribute(attributeName) || "";
        return parseTokenString(tokenString, element, attributeName);
    }
}
function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter(content => content.length)
        .map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
}

class ValueListObserver {
    constructor(element, attributeName, delegate) {
        this.tokenListObserver = new TokenListObserver(element, attributeName, this);
        this.delegate = delegate;
        this.parseResultsByToken = new WeakMap;
        this.valuesByTokenByElement = new WeakMap;
    }
    get started() {
        return this.tokenListObserver.started;
    }
    start() {
        this.tokenListObserver.start();
    }
    stop() {
        this.tokenListObserver.stop();
    }
    refresh() {
        this.tokenListObserver.refresh();
    }
    get element() {
        return this.tokenListObserver.element;
    }
    get attributeName() {
        return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).set(token, value);
            this.delegate.elementMatchedValue(element, value);
        }
    }
    tokenUnmatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).delete(token);
            this.delegate.elementUnmatchedValue(element, value);
        }
    }
    fetchParseResultForToken(token) {
        let parseResult = this.parseResultsByToken.get(token);
        if (!parseResult) {
            parseResult = this.parseToken(token);
            this.parseResultsByToken.set(token, parseResult);
        }
        return parseResult;
    }
    fetchValuesByTokenForElement(element) {
        let valuesByToken = this.valuesByTokenByElement.get(element);
        if (!valuesByToken) {
            valuesByToken = new Map;
            this.valuesByTokenByElement.set(element, valuesByToken);
        }
        return valuesByToken;
    }
    parseToken(token) {
        try {
            const value = this.delegate.parseValueForToken(token);
            return { value };
        }
        catch (error) {
            return { error };
        }
    }
}

class BindingObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.bindingsByAction = new Map;
    }
    start() {
        if (!this.valueListObserver) {
            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
            this.valueListObserver.start();
        }
    }
    stop() {
        if (this.valueListObserver) {
            this.valueListObserver.stop();
            delete this.valueListObserver;
            this.disconnectAllActions();
        }
    }
    get element() {
        return this.context.element;
    }
    get identifier() {
        return this.context.identifier;
    }
    get actionAttribute() {
        return this.schema.actionAttribute;
    }
    get schema() {
        return this.context.schema;
    }
    get bindings() {
        return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
        const binding = new Binding(this.context, action);
        this.bindingsByAction.set(action, binding);
        this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
        const binding = this.bindingsByAction.get(action);
        if (binding) {
            this.bindingsByAction.delete(action);
            this.delegate.bindingDisconnected(binding);
        }
    }
    disconnectAllActions() {
        this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding));
        this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
        const action = Action.forToken(token);
        if (action.identifier == this.identifier) {
            return action;
        }
    }
    elementMatchedValue(element, action) {
        this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
        this.disconnectAction(action);
    }
}

class ValueObserver {
    constructor(context, receiver) {
        this.context = context;
        this.receiver = receiver;
        this.stringMapObserver = new StringMapObserver(this.element, this);
        this.valueDescriptorMap = this.controller.valueDescriptorMap;
        this.invokeChangedCallbacksForDefaultValues();
    }
    start() {
        this.stringMapObserver.start();
    }
    stop() {
        this.stringMapObserver.stop();
    }
    get element() {
        return this.context.element;
    }
    get controller() {
        return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
        if (attributeName in this.valueDescriptorMap) {
            return this.valueDescriptorMap[attributeName].name;
        }
    }
    stringMapKeyAdded(key, attributeName) {
        const descriptor = this.valueDescriptorMap[attributeName];
        if (!this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
        }
    }
    stringMapValueChanged(value, name, oldValue) {
        const descriptor = this.valueDescriptorNameMap[name];
        if (value === null)
            return;
        if (oldValue === null) {
            oldValue = descriptor.writer(descriptor.defaultValue);
        }
        this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        const descriptor = this.valueDescriptorNameMap[key];
        if (this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
        }
        else {
            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
        }
    }
    invokeChangedCallbacksForDefaultValues() {
        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
            if (defaultValue != undefined && !this.controller.data.has(key)) {
                this.invokeChangedCallback(name, writer(defaultValue), undefined);
            }
        }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
        const changedMethodName = `${name}Changed`;
        const changedMethod = this.receiver[changedMethodName];
        if (typeof changedMethod == "function") {
            const descriptor = this.valueDescriptorNameMap[name];
            const value = descriptor.reader(rawValue);
            let oldValue = rawOldValue;
            if (rawOldValue) {
                oldValue = descriptor.reader(rawOldValue);
            }
            changedMethod.call(this.receiver, value, oldValue);
        }
    }
    get valueDescriptors() {
        const { valueDescriptorMap } = this;
        return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
        const descriptors = {};
        Object.keys(this.valueDescriptorMap).forEach(key => {
            const descriptor = this.valueDescriptorMap[key];
            descriptors[descriptor.name] = descriptor;
        });
        return descriptors;
    }
    hasValue(attributeName) {
        const descriptor = this.valueDescriptorNameMap[attributeName];
        const hasMethodName = `has${capitalize(descriptor.name)}`;
        return this.receiver[hasMethodName];
    }
}

class TargetObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.targetsByName = new Multimap;
    }
    start() {
        if (!this.tokenListObserver) {
            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
            this.tokenListObserver.start();
        }
    }
    stop() {
        if (this.tokenListObserver) {
            this.disconnectAllTargets();
            this.tokenListObserver.stop();
            delete this.tokenListObserver;
        }
    }
    tokenMatched({ element, content: name }) {
        if (this.scope.containsElement(element)) {
            this.connectTarget(element, name);
        }
    }
    tokenUnmatched({ element, content: name }) {
        this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
        var _a;
        if (!this.targetsByName.has(name, element)) {
            this.targetsByName.add(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
        }
    }
    disconnectTarget(element, name) {
        var _a;
        if (this.targetsByName.has(name, element)) {
            this.targetsByName.delete(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
        }
    }
    disconnectAllTargets() {
        for (const name of this.targetsByName.keys) {
            for (const element of this.targetsByName.getValuesForKey(name)) {
                this.disconnectTarget(element, name);
            }
        }
    }
    get attributeName() {
        return `data-${this.context.identifier}-target`;
    }
    get element() {
        return this.context.element;
    }
    get scope() {
        return this.context.scope;
    }
}

class Context {
    constructor(module, scope) {
        this.logDebugActivity = (functionName, detail = {}) => {
            const { identifier, controller, element } = this;
            detail = Object.assign({ identifier, controller, element }, detail);
            this.application.logDebugActivity(this.identifier, functionName, detail);
        };
        this.module = module;
        this.scope = scope;
        this.controller = new module.controllerConstructor(this);
        this.bindingObserver = new BindingObserver(this, this.dispatcher);
        this.valueObserver = new ValueObserver(this, this.controller);
        this.targetObserver = new TargetObserver(this, this);
        try {
            this.controller.initialize();
            this.logDebugActivity("initialize");
        }
        catch (error) {
            this.handleError(error, "initializing controller");
        }
    }
    connect() {
        this.bindingObserver.start();
        this.valueObserver.start();
        this.targetObserver.start();
        try {
            this.controller.connect();
            this.logDebugActivity("connect");
        }
        catch (error) {
            this.handleError(error, "connecting controller");
        }
    }
    disconnect() {
        try {
            this.controller.disconnect();
            this.logDebugActivity("disconnect");
        }
        catch (error) {
            this.handleError(error, "disconnecting controller");
        }
        this.targetObserver.stop();
        this.valueObserver.stop();
        this.bindingObserver.stop();
    }
    get application() {
        return this.module.application;
    }
    get identifier() {
        return this.module.identifier;
    }
    get schema() {
        return this.application.schema;
    }
    get dispatcher() {
        return this.application.dispatcher;
    }
    get element() {
        return this.scope.element;
    }
    get parentElement() {
        return this.element.parentElement;
    }
    handleError(error, message, detail = {}) {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.handleError(error, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
        this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
        this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    invokeControllerMethod(methodName, ...args) {
        const controller = this.controller;
        if (typeof controller[methodName] == "function") {
            controller[methodName](...args);
        }
    }
}

function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor) => {
        getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name));
        return values;
    }, new Set));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor) => {
        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
        return pairs;
    }, []);
}
function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
        ancestors.push(constructor);
        constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map(key => [key, definition[key]]) : [];
}

function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
}
function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
        const properties = blessing(constructor);
        for (const key in properties) {
            const descriptor = blessedProperties[key] || {};
            blessedProperties[key] = Object.assign(descriptor, properties[key]);
        }
        return blessedProperties;
    }, {});
}
function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
        const descriptor = getShadowedDescriptor(prototype, properties, key);
        if (descriptor) {
            Object.assign(shadowProperties, { [key]: descriptor });
        }
        return shadowProperties;
    }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
        if (shadowingDescriptor) {
            descriptor.get = shadowingDescriptor.get || descriptor.get;
            descriptor.set = shadowingDescriptor.set || descriptor.set;
        }
        return descriptor;
    }
}
const getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
        return (object) => [
            ...Object.getOwnPropertyNames(object),
            ...Object.getOwnPropertySymbols(object)
        ];
    }
    else {
        return Object.getOwnPropertyNames;
    }
})();
const extend = (() => {
    function extendWithReflect(constructor) {
        function extended() {
            return Reflect.construct(constructor, arguments, new.target);
        }
        extended.prototype = Object.create(constructor.prototype, {
            constructor: { value: extended }
        });
        Reflect.setPrototypeOf(extended, constructor);
        return extended;
    }
    function testReflectExtension() {
        const a = function () { this.a.call(this); };
        const b = extendWithReflect(a);
        b.prototype.a = function () { };
        return new b;
    }
    try {
        testReflectExtension();
        return extendWithReflect;
    }
    catch (error) {
        return (constructor) => class extended extends constructor {
        };
    }
})();

function blessDefinition(definition) {
    return {
        identifier: definition.identifier,
        controllerConstructor: bless(definition.controllerConstructor)
    };
}

class Module {
    constructor(application, definition) {
        this.application = application;
        this.definition = blessDefinition(definition);
        this.contextsByScope = new WeakMap;
        this.connectedContexts = new Set;
    }
    get identifier() {
        return this.definition.identifier;
    }
    get controllerConstructor() {
        return this.definition.controllerConstructor;
    }
    get contexts() {
        return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
        const context = this.fetchContextForScope(scope);
        this.connectedContexts.add(context);
        context.connect();
    }
    disconnectContextForScope(scope) {
        const context = this.contextsByScope.get(scope);
        if (context) {
            this.connectedContexts.delete(context);
            context.disconnect();
        }
    }
    fetchContextForScope(scope) {
        let context = this.contextsByScope.get(scope);
        if (!context) {
            context = new Context(this, scope);
            this.contextsByScope.set(scope, context);
        }
        return context;
    }
}

class ClassMap {
    constructor(scope) {
        this.scope = scope;
    }
    has(name) {
        return this.data.has(this.getDataKey(name));
    }
    get(name) {
        return this.getAll(name)[0];
    }
    getAll(name) {
        const tokenString = this.data.get(this.getDataKey(name)) || "";
        return tokenize(tokenString);
    }
    getAttributeName(name) {
        return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
        return `${name}-class`;
    }
    get data() {
        return this.scope.data;
    }
}

class DataMap {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.getAttribute(name);
    }
    set(key, value) {
        const name = this.getAttributeNameForKey(key);
        this.element.setAttribute(name, value);
        return this.get(key);
    }
    has(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.hasAttribute(name);
    }
    delete(key) {
        if (this.has(key)) {
            const name = this.getAttributeNameForKey(key);
            this.element.removeAttribute(name);
            return true;
        }
        else {
            return false;
        }
    }
    getAttributeNameForKey(key) {
        return `data-${this.identifier}-${dasherize(key)}`;
    }
}

class Guide {
    constructor(logger) {
        this.warnedKeysByObject = new WeakMap;
        this.logger = logger;
    }
    warn(object, key, message) {
        let warnedKeys = this.warnedKeysByObject.get(object);
        if (!warnedKeys) {
            warnedKeys = new Set;
            this.warnedKeysByObject.set(object, warnedKeys);
        }
        if (!warnedKeys.has(key)) {
            warnedKeys.add(key);
            this.logger.warn(message, object);
        }
    }
}

function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
}

class TargetSet {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(targetName) {
        return this.find(targetName) != null;
    }
    find(...targetNames) {
        return targetNames.reduce((target, targetName) => target
            || this.findTarget(targetName)
            || this.findLegacyTarget(targetName), undefined);
    }
    findAll(...targetNames) {
        return targetNames.reduce((targets, targetName) => [
            ...targets,
            ...this.findAllTargets(targetName),
            ...this.findAllLegacyTargets(targetName)
        ], []);
    }
    findTarget(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
        const attributeName = this.schema.targetAttributeForScope(this.identifier);
        return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
        const targetDescriptor = `${this.identifier}.${targetName}`;
        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
        if (element) {
            const { identifier } = this;
            const attributeName = this.schema.targetAttribute;
            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` +
                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
        }
        return element;
    }
    get guide() {
        return this.scope.guide;
    }
}

class Scope {
    constructor(schema, element, identifier, logger) {
        this.targets = new TargetSet(this);
        this.classes = new ClassMap(this);
        this.data = new DataMap(this);
        this.containsElement = (element) => {
            return element.closest(this.controllerSelector) === this.element;
        };
        this.schema = schema;
        this.element = element;
        this.identifier = identifier;
        this.guide = new Guide(logger);
    }
    findElement(selector) {
        return this.element.matches(selector)
            ? this.element
            : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
        return [
            ...this.element.matches(selector) ? [this.element] : [],
            ...this.queryElements(selector).filter(this.containsElement)
        ];
    }
    queryElements(selector) {
        return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
}

class ScopeObserver {
    constructor(element, schema, delegate) {
        this.element = element;
        this.schema = schema;
        this.delegate = delegate;
        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
        this.scopesByIdentifierByElement = new WeakMap;
        this.scopeReferenceCounts = new WeakMap;
    }
    start() {
        this.valueListObserver.start();
    }
    stop() {
        this.valueListObserver.stop();
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
        const { element, content: identifier } = token;
        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
        let scope = scopesByIdentifier.get(identifier);
        if (!scope) {
            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
            scopesByIdentifier.set(identifier, scope);
        }
        return scope;
    }
    elementMatchedValue(element, value) {
        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
        this.scopeReferenceCounts.set(value, referenceCount);
        if (referenceCount == 1) {
            this.delegate.scopeConnected(value);
        }
    }
    elementUnmatchedValue(element, value) {
        const referenceCount = this.scopeReferenceCounts.get(value);
        if (referenceCount) {
            this.scopeReferenceCounts.set(value, referenceCount - 1);
            if (referenceCount == 1) {
                this.delegate.scopeDisconnected(value);
            }
        }
    }
    fetchScopesByIdentifierForElement(element) {
        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
        if (!scopesByIdentifier) {
            scopesByIdentifier = new Map;
            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
        }
        return scopesByIdentifier;
    }
}

class Router {
    constructor(application) {
        this.application = application;
        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
        this.scopesByIdentifier = new Multimap;
        this.modulesByIdentifier = new Map;
    }
    get element() {
        return this.application.element;
    }
    get schema() {
        return this.application.schema;
    }
    get logger() {
        return this.application.logger;
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    get modules() {
        return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
        this.scopeObserver.start();
    }
    stop() {
        this.scopeObserver.stop();
    }
    loadDefinition(definition) {
        this.unloadIdentifier(definition.identifier);
        const module = new Module(this.application, definition);
        this.connectModule(module);
    }
    unloadIdentifier(identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            this.disconnectModule(module);
        }
    }
    getContextForElementAndIdentifier(element, identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            return module.contexts.find(context => context.element == element);
        }
    }
    handleError(error, message, detail) {
        this.application.handleError(error, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
        return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
        this.scopesByIdentifier.add(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.connectContextForScope(scope);
        }
    }
    scopeDisconnected(scope) {
        this.scopesByIdentifier.delete(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.disconnectContextForScope(scope);
        }
    }
    connectModule(module) {
        this.modulesByIdentifier.set(module.identifier, module);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach(scope => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
        this.modulesByIdentifier.delete(module.identifier);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach(scope => module.disconnectContextForScope(scope));
    }
}

const defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: identifier => `data-${identifier}-target`
};

class Application {
    constructor(element = document.documentElement, schema = defaultSchema) {
        this.logger = console;
        this.debug = false;
        this.logDebugActivity = (identifier, functionName, detail = {}) => {
            if (this.debug) {
                this.logFormattedMessage(identifier, functionName, detail);
            }
        };
        this.element = element;
        this.schema = schema;
        this.dispatcher = new Dispatcher(this);
        this.router = new Router(this);
    }
    static start(element, schema) {
        const application = new Application(element, schema);
        application.start();
        return application;
    }
    async start() {
        await domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
    }
    stop() {
        this.logDebugActivity("application", "stopping");
        this.dispatcher.stop();
        this.router.stop();
        this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
        if (controllerConstructor.shouldLoad) {
            this.load({ identifier, controllerConstructor });
        }
    }
    load(head, ...rest) {
        const definitions = Array.isArray(head) ? head : [head, ...rest];
        definitions.forEach(definition => this.router.loadDefinition(definition));
    }
    unload(head, ...rest) {
        const identifiers = Array.isArray(head) ? head : [head, ...rest];
        identifiers.forEach(identifier => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
        return this.router.contexts.map(context => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
        const context = this.router.getContextForElementAndIdentifier(element, identifier);
        return context ? context.controller : null;
    }
    handleError(error, message, detail) {
        var _a;
        this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
        detail = Object.assign({ application: this }, detail);
        this.logger.groupCollapsed(`${identifier} #${functionName}`);
        this.logger.log("details:", Object.assign({}, detail));
        this.logger.groupEnd();
    }
}
function domReady() {
    return new Promise(resolve => {
        if (document.readyState == "loading") {
            document.addEventListener("DOMContentLoaded", () => resolve());
        }
        else {
            resolve();
        }
    });
}

function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
        return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
}
function propertiesForClassDefinition(key) {
    return {
        [`${key}Class`]: {
            get() {
                const { classes } = this;
                if (classes.has(key)) {
                    return classes.get(key);
                }
                else {
                    const attribute = classes.getAttributeName(key);
                    throw new Error(`Missing attribute "${attribute}"`);
                }
            }
        },
        [`${key}Classes`]: {
            get() {
                return this.classes.getAll(key);
            }
        },
        [`has${capitalize(key)}Class`]: {
            get() {
                return this.classes.has(key);
            }
        }
    };
}

function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
}
function propertiesForTargetDefinition(name) {
    return {
        [`${name}Target`]: {
            get() {
                const target = this.targets.find(name);
                if (target) {
                    return target;
                }
                else {
                    throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
                }
            }
        },
        [`${name}Targets`]: {
            get() {
                return this.targets.findAll(name);
            }
        },
        [`has${capitalize(name)}Target`]: {
            get() {
                return this.targets.has(name);
            }
        }
    };
}

function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
        valueDescriptorMap: {
            get() {
                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
                    return Object.assign(result, { [attributeName]: valueDescriptor });
                }, {});
            }
        }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair) {
    const definition = parseValueDefinitionPair(valueDefinitionPair);
    const { key, name, reader: read, writer: write } = definition;
    return {
        [name]: {
            get() {
                const value = this.data.get(key);
                if (value !== null) {
                    return read(value);
                }
                else {
                    return definition.defaultValue;
                }
            },
            set(value) {
                if (value === undefined) {
                    this.data.delete(key);
                }
                else {
                    this.data.set(key, write(value));
                }
            }
        },
        [`has${capitalize(name)}`]: {
            get() {
                return this.data.has(key) || definition.hasCustomDefaultValue;
            }
        }
    };
}
function parseValueDefinitionPair([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
}
function parseValueTypeConstant(constant) {
    switch (constant) {
        case Array: return "array";
        case Boolean: return "boolean";
        case Number: return "number";
        case Object: return "object";
        case String: return "string";
    }
}
function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
        case "boolean": return "boolean";
        case "number": return "number";
        case "string": return "string";
    }
    if (Array.isArray(defaultValue))
        return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
        return "object";
}
function parseValueTypeObject(typeObject) {
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    if (typeFromObject) {
        const defaultValueType = parseValueTypeDefault(typeObject.default);
        if (typeFromObject !== defaultValueType) {
            throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
        }
        return typeFromObject;
    }
}
function parseValueTypeDefinition(typeDefinition) {
    const typeFromObject = parseValueTypeObject(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
        return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
}
function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
        return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== undefined)
        return defaultValue;
    return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(typeDefinition);
    return {
        type,
        key,
        name: camelize(key),
        get defaultValue() { return defaultValueForDefinition(typeDefinition); },
        get hasCustomDefaultValue() { return parseValueTypeDefault(typeDefinition) !== undefined; },
        reader: readers[type],
        writer: writers[type] || writers.default
    };
}
const defaultValuesByType = {
    get array() { return []; },
    boolean: false,
    number: 0,
    get object() { return {}; },
    string: ""
};
const readers = {
    array(value) {
        const array = JSON.parse(value);
        if (!Array.isArray(array)) {
            throw new TypeError("Expected array");
        }
        return array;
    },
    boolean(value) {
        return !(value == "0" || value == "false");
    },
    number(value) {
        return Number(value);
    },
    object(value) {
        const object = JSON.parse(value);
        if (object === null || typeof object != "object" || Array.isArray(object)) {
            throw new TypeError("Expected object");
        }
        return object;
    },
    string(value) {
        return value;
    }
};
const writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
};
function writeJSON(value) {
    return JSON.stringify(value);
}
function writeString(value) {
    return `${value}`;
}

class Controller {
    constructor(context) {
        this.context = context;
    }
    static get shouldLoad() {
        return true;
    }
    get application() {
        return this.context.application;
    }
    get scope() {
        return this.context.scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get targets() {
        return this.scope.targets;
    }
    get classes() {
        return this.scope.classes;
    }
    get data() {
        return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
        const type = prefix ? `${prefix}:${eventName}` : eventName;
        const event = new CustomEvent(type, { detail, bubbles, cancelable });
        target.dispatchEvent(event);
        return event;
    }
}
Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
Controller.targets = [];
Controller.values = {};




/***/ }),

/***/ "./node_modules/@symfony/stimulus-bridge/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@symfony/stimulus-bridge/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startStimulusApp": () => (/* binding */ startStimulusApp)
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpack/loader!@symfony/stimulus-bridge/controllers.json */ "./node_modules/@symfony/stimulus-bridge/dist/webpack/loader.js!./assets/controllers.json");



/*
Stimulus Webpack Helpers 1.0.0
Copyright Â© 2021 Basecamp, LLC
 */
function definitionsFromContext(context) {
    return context.keys()
        .map((key) => definitionForModuleWithContextAndKey(context, key))
        .filter((value) => value);
}
function definitionForModuleWithContextAndKey(context, key) {
    const identifier = identifierForContextKey(key);
    if (identifier) {
        return definitionForModuleAndIdentifier(context(key), identifier);
    }
}
function definitionForModuleAndIdentifier(module, identifier) {
    const controllerConstructor = module.default;
    if (typeof controllerConstructor == "function") {
        return { identifier, controllerConstructor };
    }
}
function identifierForContextKey(key) {
    const logicalName = (key.match(/^(?:\.\/)?(.+)(?:[_-]controller\..+?)$/) || [])[1];
    if (logicalName) {
        return logicalName.replace(/_/g, "-").replace(/\//g, "--");
    }
}

function startStimulusApp(context) {
    const application = _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Application.start();
    if (true) {
        application.debug = true;
    }
    if (context) {
        application.load(definitionsFromContext(context));
    }
    for (const controllerName in _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"]) {
        if (!_webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty(controllerName)) {
            continue;
        }
        _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"][controllerName].then((module) => {
            application.register(controllerName, module.default);
        });
    }
    return application;
}




/***/ }),

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* binding */ WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* binding */ buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* binding */ extractIdentifiers),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* binding */ getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* binding */ isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* binding */ isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* binding */ isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* binding */ isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* binding */ isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* binding */ isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* binding */ isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "makeBlock": () => (/* binding */ makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* binding */ walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* binding */ walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* binding */ walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");



function defaultOnError(error) {
    throw error;
}
function defaultOnWarn(msg) {
    ( true) && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  true
        ? (messages || errorMessages)[code] + (additionalMessage || ``)
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
    // transform errors
    [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [50 /* __EXTEND_POINT__ */]: ``
};

const FRAGMENT = Symbol(( true) ? `Fragment` : 0);
const TELEPORT = Symbol(( true) ? `Teleport` : 0);
const SUSPENSE = Symbol(( true) ? `Suspense` : 0);
const KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);
const OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);
const CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = Symbol(( true) ? `createElementBlock` : 0);
const CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = Symbol(( true) ? `createElementVNode` : 0);
const CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);
const CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);
const CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);
const RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);
const RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);
const RESOLVE_FILTER = Symbol(( true) ? `resolveFilter` : 0);
const WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);
const RENDER_LIST = Symbol(( true) ? `renderList` : 0);
const RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);
const MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);
const NORMALIZE_CLASS = Symbol(( true) ? `normalizeClass` : 0);
const NORMALIZE_STYLE = Symbol(( true) ? `normalizeStyle` : 0);
const NORMALIZE_PROPS = Symbol(( true) ? `normalizeProps` : 0);
const GUARD_REACTIVE_PROPS = Symbol(( true) ? `guardReactiveProps` : 0);
const TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);
const CAMELIZE = Symbol(( true) ? `camelize` : 0);
const CAPITALIZE = Symbol(( true) ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);
const SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);
const PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);
const WITH_CTX = Symbol(( true) ? `withCtx` : 0);
const UNREF = Symbol(( true) ? `unref` : 0);
const IS_REF = Symbol(( true) ? `isRef` : 0);
const WITH_MEMO = Symbol(( true) ? `withMemo` : 0);
const IS_MEMO_SAME = Symbol(( true) ? `isMemoSame` : 0);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
        }
        else {
            context.helper(getVNodeHelper(context.inSSR, isComponent));
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* JS_PROPERTY */,
        loc: locStub,
        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
    return {
        type: 4 /* SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* INTERPOLATION */,
        loc,
        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */
const isMemberExpressionBrowser = (path) => {
    // remove whitespaces around . or [ first
    path = path.trim().replace(whitespaceRE, s => s.trim());
    let state = 0 /* inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
            case 0 /* inMemberExp */:
                if (char === '[') {
                    stateStack.push(state);
                    state = 1 /* inBrackets */;
                    currentOpenBracketCount++;
                }
                else if (char === '(') {
                    stateStack.push(state);
                    state = 2 /* inParens */;
                    currentOpenParensCount++;
                }
                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                    return false;
                }
                break;
            case 1 /* inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `[`) {
                    currentOpenBracketCount++;
                }
                else if (char === `]`) {
                    if (!--currentOpenBracketCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 2 /* inParens */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `(`) {
                    currentOpenParensCount++;
                }
                else if (char === `)`) {
                    // if the exp ends as a call then it should not be considered valid
                    if (i === path.length - 1) {
                        return false;
                    }
                    if (!--currentOpenParensCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 3 /* inString */:
                if (char === currentStringType) {
                    state = stateStack.pop();
                    currentStringType = null;
                }
                break;
        }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP
    ;
const isMemberExpression = isMemberExpressionBrowser
    ;
function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isStaticArgOf(p.arg, name)) {
            return p;
        }
    }
}
function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
}
function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const callee = props.callee;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
    }
    return [props, callPath];
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    /**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */
    let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
    }
    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
            first.properties.unshift(prop);
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        let alreadyExists = false;
        // check existing key to avoid overriding user provided keys
        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === propKeyName);
        }
        if (!alreadyExists) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
        // the `guardReactiveProps` will no longer be needed
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
        }
    }
    if (node.type === 13 /* VNODE_CALL */) {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.props = propsWithInjection;
        }
    }
    else {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.arguments[2] = propsWithInjection;
        }
    }
}
function toValidAssetId(name, type) {
    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* COMPOUND_EXPRESSION */:
            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return false;
        default:
            if ((true)) ;
            return false;
    }
}
function getMemoedVNodeCall(node) {
    if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
    }
    else {
        return node;
    }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
}

const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
        message: `Platform-native elements with "is" prop will no longer be ` +
            `treated as components in Vue 3 unless the "is" value is explicitly ` +
            `prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
            `\`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
            `Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
            `object spread: it will now overwrite an existing non-mergeable attribute ` +
            `that appears before v-bind in the case of conflict. ` +
            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
            `You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
        message: `v-if / v-for precedence when used on the same element has changed ` +
            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
            `access to v-for scope variables. It is best to avoid the ambiguity ` +
            `with <template> tags or use a computed property that filters v-for ` +
            `data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
        message: `<template> with no special directives will render as a native template ` +
            `element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
};
function getCompatValue(key, context) {
    const config = context.options
        ? context.options.compatConfig
        : context.compatConfig;
    const value = config && config[key];
    if (key === 'MODE') {
        return value || 3; // compiler defaults to v3 behavior
    }
    else {
        return value;
    }
}
function isCompatEnabled(key, context) {
    const mode = getCompatValue('MODE', context);
    const value = getCompatValue(key, context);
    // in v3 mode, only enable if explicitly set to true
    // otherwise enable for any non-false value
    return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (( true) && enabled) {
        warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === 'suppress-warning') {
        return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
        err.loc = loc;
    context.onWarn(err);
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: ("development" !== 'production')
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
        // @ts-ignore
        options[key] =
            rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* X_INVALID_END_TAG */);
                        parseTag(context, 1 /* End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                    // 2.x <template> with no directive compat
                    if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context) &&
                        node &&
                        node.tag === 'template' &&
                        !node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
                            isSpecialTemplateDirective(p.name))) {
                        ( true) &&
                            warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                        node = node.children;
                    }
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace handling strategy like v2
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
        const shouldCondense = context.options.whitespace !== 'preserve';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!context.inPre && node.type === 2 /* TEXT */) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                    const prev = nodes[i - 1];
                    const next = nodes[i + 1];
                    // Remove if:
                    // - the whitespace is the first or last node, or:
                    // - (condense mode) the whitespace is adjacent to a comment, or:
                    // - (condense mode) the whitespace is between two elements AND contains newline
                    if (!prev ||
                        !next ||
                        (shouldCondense &&
                            (prev.type === 3 /* COMMENT */ ||
                                next.type === 3 /* COMMENT */ ||
                                (prev.type === 1 /* ELEMENT */ &&
                                    next.type === 1 /* ELEMENT */ &&
                                    /[\r\n]/.test(node.content))))) {
                        removedWhitespace = true;
                        nodes[i] = null;
                    }
                    else {
                        // Otherwise, the whitespace is condensed into a single space
                        node.content = ' ';
                    }
                }
                else if (shouldCondense) {
                    // in condense mode, consecutive whitespaces in text are condensed
                    // down to a single space.
                    node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                }
            }
            // Remove comment nodes if desired by configuration.
            else if (node.type === 3 /* COMMENT */ && !context.options.comments) {
                removedWhitespace = true;
                nodes[i] = null;
            }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        // #4030 self-closing <pre> tag
        if (isPreBoundary) {
            context.inPre = false;
        }
        if (isVPreBoundary) {
            context.inVPre = false;
        }
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    // 2.x inline-template compat
    {
        const inlineTemplateProp = element.props.find(p => p.type === 6 /* ATTRIBUTE */ && p.name === 'inline-template');
        if (inlineTemplateProp &&
            checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
                type: 2 /* TEXT */,
                content: loc.source,
                loc
            };
        }
    }
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* End */, parent);
    }
    else {
        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // Attributes.
    let props = parseAttributes(context, type);
    // check v-pre
    if (type === 0 /* Start */ &&
        !context.inVPre &&
        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* End */ && isSelfClosing) {
            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1 /* End */) {
        return;
    }
    // 2.x deprecation checks
    if (( true) &&
        isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7 /* DIRECTIVE */) {
                if (p.name === 'if') {
                    hasIf = true;
                }
                else if (p.name === 'for') {
                    hasFor = true;
                }
            }
            if (hasIf && hasFor) {
                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                break;
            }
        }
    }
    let tagType = 0 /* ELEMENT */;
    if (!context.inVPre) {
        if (tag === 'slot') {
            tagType = 2 /* SLOT */;
        }
        else if (tag === 'template') {
            if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                tagType = 3 /* TEMPLATE */;
            }
        }
        else if (isComponent(tag, props, context)) {
            tagType = 1 /* COMPONENT */;
        }
    }
    return {
        type: 1 /* ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
        return false;
    }
    if (tag === 'component' ||
        /^[A-Z]/.test(tag) ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        (options.isNativeTag && !options.isNativeTag(tag))) {
        return true;
    }
    // at this point the tag should be a native tag, but check for potential "is"
    // casting
    for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                    return true;
                }
                else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                    return true;
                }
            }
        }
        else {
            // directive
            // v-is (TODO Deprecate)
            if (p.name === 'is') {
                return true;
            }
            else if (
            // :is on plain element - only treat as component in compat mode
            p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                return true;
            }
        }
    }
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* End */) {
            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        // Trim whitespace between class
        // https://github.com/vuejs/core/issues/4251
        if (attr.type === 6 /* ATTRIBUTE */ &&
            attr.value &&
            attr.name === 'class') {
            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
        }
        if (type === 0 /* Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, '.');
        let dirName = match[1] ||
            (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                    ? 'on'
                    : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.lastIndexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    content = content.slice(1);
                }
                else {
                    content = content.slice(1, content.length - 1);
                }
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* CAN_STRINGIFY */
                    : 0 /* NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
        if (isPropShorthand)
            modifiers.push('prop');
        // 2.x compat v-bind:foo.sync -> v-model:foo
        if (dirName === 'bind' && arg) {
            if (modifiers.includes('sync') &&
                checkCompatEnabled("COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
            }
            if (( true) && modifiers.includes('prop')) {
                checkCompatEnabled("COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */, context, loc);
            }
        }
        return {
            type: 7 /* DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers,
            loc
        };
    }
    // missing directive name or illegal directive name
    if (!context.inVPre && startsWith(name, 'v-')) {
        emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
    }
    return {
        type: 6 /* ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* INTERPOLATION */,
        content: {
            type: 4 /* SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* RAWTEXT */ ||
        mode === 3 /* CDATA */ ||
        !rawText.includes('&')) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* RCDATA */:
        case 2 /* RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* ELEMENT */ &&
            child.tagType === 0 /* ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* NOT_CONSTANT */) {
                if (constantType >= 2 /* CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* HOISTED */ + (( true) ? ` /* HOISTED */` : 0);
                    child.codegenNode = context.hoist(child.codegenNode);
                    hoistedCount++;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* NEED_PATCH */ ||
                        flag === 1 /* TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                    if (codegenNode.dynamicProps) {
                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                    }
                }
            }
        }
        else if (child.type === 12 /* TEXT_CALL */ &&
            getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
        }
        // walk further
        if (child.type === 1 /* ELEMENT */) {
            const isComponent = child.tagType === 1 /* COMPONENT */;
            if (isComponent) {
                context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent) {
                context.scopes.vSlot--;
            }
        }
        else if (child.type === 11 /* FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
    // all children were hoisted - the entire children array is hoistable.
    if (hoistedCount &&
        hoistedCount === originalCount &&
        node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        node.codegenNode &&
        node.codegenNode.type === 13 /* VNODE_CALL */ &&
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* ELEMENT */:
            if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_CONSTANT */;
            }
            if (codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject') {
                return 0 /* NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* NOT_CONSTANT */);
                    return 0 /* NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* NOT_CONSTANT */);
                        return 0 /* NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* NOT_CONSTANT */);
                                return 0 /* NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    context.removeHelper(OPEN_BLOCK);
                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                    codegenNode.isBlock = false;
                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* NOT_CONSTANT */);
                return 0 /* NOT_CONSTANT */;
            }
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return 3 /* CAN_STRINGIFY */;
        case 9 /* IF */:
        case 11 /* FOR */:
        case 10 /* IF_BRANCH */:
            return 0 /* NOT_CONSTANT */;
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* COMPOUND_EXPRESSION */:
            let returnType = 3 /* CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* NOT_CONSTANT */) {
                    return 0 /* NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            if ((true)) ;
            return 0 /* NOT_CONSTANT */;
    }
}
const allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 /* JS_CALL_EXPRESSION */ &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) &&
        allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            return getConstantType(arg, context);
        }
        else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
            return getConstantTypeOfHelperCall(arg, context);
        }
    }
    return 0 /* NOT_CONSTANT */;
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            let valueType;
            if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
            }
            else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
            }
            else {
                valueType = 0 /* NOT_CONSTANT */;
            }
            if (valueType === 0 /* NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        // state
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        // methods
        helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
        },
        removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                    context.helpers.delete(name);
                }
                else {
                    context.helpers.set(name, currentCount);
                }
            }
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((true)) {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (( true) && !context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (( true) && removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))
                exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
        }
    };
    {
        context.filters = new Set();
    }
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
        root.filters = [...context.filters];
    }
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* VNODE_CALL */) {
                makeBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* STABLE_FRAGMENT */;
        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (( true) &&
            children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* IF_BRANCH */:
        case 11 /* FOR */:
        case 1 /* ELEMENT */:
        case 0 /* ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers
                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                .join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, 'filter', context);
        newline();
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
    const VueBinding = runtimeGlobalName;
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_ELEMENT_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === 'filter'
        ? RESOLVE_FILTER
        : type === 'component'
            ? RESOLVE_COMPONENT
            : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        // potential component implicit self-reference inferred from SFC filename
        const maybeSelfReference = id.endsWith('__self');
        if (maybeSelfReference) {
            id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
            push(`const _hoisted_${i + 1} = ${``}`);
            genNode(exp, context);
            newline();
        }
    }
    context.pure = false;
}
function isText$1(n) {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
        n.type === 4 /* SIMPLE_EXPRESSION */ ||
        n.type === 2 /* TEXT */ ||
        n.type === 5 /* INTERPOLATION */ ||
        n.type === 8 /* COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            push(node);
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
        context.push(node);
        return;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
        case 9 /* IF */:
        case 11 /* FOR */:
            ( true) &&
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* TEXT */:
            genText(node, context);
            break;
        case 4 /* SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* COMMENT */:
            genComment(node, context);
            break;
        case 13 /* VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        case 21 /* JS_BLOCK_STATEMENT */:
            genNodeList(node.body, context, true, false);
            break;
        // SSR only types
        case 22 /* JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* JS_IF_STATEMENT */:
            break;
        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* IF_BRANCH */:
            // noop
            break;
        default:
            if ((true)) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    const callHelper = isBlock
        ? getVNodeBlockHelper(context.inSSR, isComponent)
        : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        ((( true)) &&
            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        // wrap slot functions with owner context
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        if (node.isNonScopedSlot) {
            push(`, undefined, true`);
        }
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
    {
        return;
    }
}
function isReferencedIdentifier(id, parent, parentStack) {
    {
        return false;
    }
}
function isInDestructureAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}
function walkFunctionParams(node, onIdent) {
    for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
            onIdent(id);
        }
    }
}
function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
        if (stmt.type === 'VariableDeclaration') {
            if (stmt.declare)
                continue;
            for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                    onIdent(id);
                }
            }
        }
        else if (stmt.type === 'FunctionDeclaration' ||
            stmt.type === 'ClassDeclaration') {
            if (stmt.declare || !stmt.id)
                continue;
            onIdent(stmt.id);
        }
    }
}
function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
        case 'Identifier':
            nodes.push(param);
            break;
        case 'MemberExpression':
            let object = param;
            while (object.type === 'MemberExpression') {
                object = object.object;
            }
            nodes.push(object);
            break;
        case 'ObjectPattern':
            for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                    extractIdentifiers(prop.argument, nodes);
                }
                else {
                    extractIdentifiers(prop.value, nodes);
                }
            }
            break;
        case 'ArrayPattern':
            param.elements.forEach(element => {
                if (element)
                    extractIdentifiers(element, nodes);
            });
            break;
        case 'RestElement':
            extractIdentifiers(param.argument, nodes);
            break;
        case 'AssignmentPattern':
            extractIdentifiers(param.left, nodes);
            break;
    }
    return nodes;
}
const isFunctionType = (node) => {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node &&
    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
    !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments,typeof,void')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
        if ((true)) {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if ( true && dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (( true) && sibling && sibling.type === 3 /* COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* IF */) {
                // Check if v-else was followed by v-else-if
                if (dir.name === 'else-if' &&
                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
                    context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (( true) &&
                    comments.length &&
                    // #3619 ignore comments if the v-if is direct child of <transition>
                    !(context.parent &&
                        context.parent.type === 1 /* ELEMENT */ &&
                        isBuiltInType(context.parent.tag, 'transition'))) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    return {
        type: 10 /* IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')
            ? node.children
            : [node],
        userKey: findProp(node, `key`)
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( true) ? '"v-if"' : 0,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            let patchFlag = 64 /* STABLE_FRAGMENT */;
            let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (( true) &&
                children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);
        }
    }
    else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* VNODE_CALL */) {
            makeBlock(vnodeCall, context);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return ret;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
            exp.isStatic !== branchExp.isStatic ||
            exp.content !== branchExp.content) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, 'memo');
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp &&
            (keyProp.type === 6 /* ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* STABLE_FRAGMENT */
            : keyProp
                ? 128 /* KEYED_FRAGMENT */
                : 256 /* UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const { children } = forNode;
            // check <template v-for> key placement
            if (( true) && isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
                    (( true)
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0), undefined, undefined, true, undefined, false /* isComponent */);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                        // switch from block to vnode
                        removeHelper(OPEN_BLOCK);
                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                    }
                    else {
                        // switch from vnode to block
                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                    }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                }
                else {
                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
            }
            if (memo) {
                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                ]));
                loop.body = createBlockStatement([
                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                    createCompoundExpression([
                        `if (_cached`,
                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            }
            else {
                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    if (true) {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (true) {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                if (true) {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
    let i = args.length;
    while (i--) {
        if (args[i])
            break;
    }
    return args
        .slice(0, i + 1)
        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        (node.tagType === 1 /* COMPONENT */ ||
            node.tagType === 3 /* TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction);
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children) => {
            const fn = buildSlotFn(props, children, loc);
            if (context.compatConfig) {
                fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length &&
            // #3766
            // with whitespace: 'preserve', whitespaces between slots will end up in
            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* FORWARDED */
            : 1 /* STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn) {
    return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ]);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
            case 1 /* ELEMENT */:
                if (child.tagType === 2 /* SLOT */ ||
                    hasForwardedSlots(child.children)) {
                    return true;
                }
                break;
            case 9 /* IF */:
                if (hasForwardedSlots(child.branches))
                    return true;
                break;
            case 10 /* IF_BRANCH */:
            case 11 /* FOR */:
                if (hasForwardedSlots(child.children))
                    return true;
                break;
        }
    }
    return false;
}
function isNonWhitespaceContent(node) {
    if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
        return true;
    return node.type === 2 /* TEXT */
        ? !!node.content.trim()
        : isNonWhitespaceContent(node.content);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 /* ELEMENT */ &&
            (node.tagType === 0 /* ELEMENT */ ||
                node.tagType === 1 /* COMPONENT */))) {
            return;
        }
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        let vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
            if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
            }
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (( true) && node.children.length > 1) {
                    context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                    type === 8 /* COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                    patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((true)) {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            else {}
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    // 1. dynamic component
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, 'is');
    if (isProp) {
        if (isExplicitDynamic ||
            (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))) {
            const exp = isProp.type === 6 /* ATTRIBUTE */
                ? isProp.value && createSimpleExpression(isProp.value.content, true)
                : isProp.exp;
            if (exp) {
                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                    exp
                ]);
            }
        }
        else if (isProp.type === 6 /* ATTRIBUTE */ &&
            isProp.value.content.startsWith('vue:')) {
            // <button is="vue:xxx">
            // if not <component>, only is value that starts with "vue:" will be
            // treated as component by the parse phase and reach here, unless it's
            // compat mode where all is values are considered components
            tag = isProp.value.content.slice(4);
        }
    }
    // 1.5 v-is (TODO: Deprecate)
    const isDir = !isExplicitDynamic && findDir(node, 'is');
    if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
        ]);
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    const isComponent = node.tagType === 1 /* COMPONENT */;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
            if (!isComponent &&
                isEventHandler &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class') {
                hasClassBinding = true;
            }
            else if (name === 'style') {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
            // treat the dynamic class and style binding of the component as dynamic props
            if (isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                }
            }
            // skip is on <component>, or is="vue:xxx"
            if (name === 'is' &&
                (isComponentTag(tag) ||
                    (value && value.content.startsWith('vue:')) ||
                    (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context)))) {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isVBind = name === 'bind';
            const isVOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once/v-memo - they are handled by dedicated transforms.
            if (name === 'once' || name === 'memo') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isVBind &&
                    isStaticArgOf(arg, 'is') &&
                    (isComponentTag(tag) ||
                        (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isVOn && ssr) {
                continue;
            }
            if (
            // #938: elements with dynamic keys should be forced into blocks
            (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (isVBind) {
                        {
                            // 2.x v-bind object order compat
                            if ((true)) {
                                const hasOverridableKeys = mergeArgs.some(arg => {
                                    if (arg.type === 15 /* JS_OBJECT_EXPRESSION */) {
                                        return arg.properties.some(({ key }) => {
                                            if (key.type !== 4 /* SIMPLE_EXPRESSION */ ||
                                                !key.isStatic) {
                                                return true;
                                            }
                                            return (key.content !== 'class' &&
                                                key.content !== 'style' &&
                                                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content));
                                        });
                                    }
                                    else {
                                        // dynamic expression
                                        return true;
                                    }
                                });
                                if (hasOverridableKeys) {
                                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                }
                            }
                            if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                mergeArgs.unshift(exp);
                                continue;
                            }
                        }
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        mergeArgs.push({
                            type: 14 /* JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: [exp]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isVBind
                        ? 34 /* X_V_BIND_NO_EXPRESSION */
                        : 35 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                    shouldUseBlock = true;
                }
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* FULL_PROPS */;
    }
    else {
        if (hasClassBinding && !isComponent) {
            patchFlag |= 2 /* CLASS */;
        }
        if (hasStyleBinding && !isComponent) {
            patchFlag |= 4 /* STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* HYDRATE_EVENTS */;
        }
    }
    if (!shouldUseBlock &&
        (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* NEED_PATCH */;
    }
    // pre-normalize props, SSR is skipped for now
    if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
            case 15 /* JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                    const key = propsExpression.properties[i].key;
                    if (isStaticExp(key)) {
                        if (key.content === 'class') {
                            classKeyIndex = i;
                        }
                        else if (key.content === 'style') {
                            styleKeyIndex = i;
                        }
                    }
                    else if (!key.isHandlerKey) {
                        hasDynamicKey = true;
                    }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                    if (classProp && !isStaticExp(classProp.value)) {
                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                    }
                    if (styleProp &&
                        !isStaticExp(styleProp.value) &&
                        // the static style is compiled into an object,
                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                        (hasStyleBinding ||
                            // v-bind:style and style both exist,
                            // v-bind:style with static literal object
                            styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {
                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                    }
                }
                else {
                    // dynamic key binding, wrap with `normalizeProps`
                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                }
                break;
            case 14 /* JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
            default:
                // single v-bind
                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                        propsExpression
                    ])
                ]);
                break;
        }
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}
function isComponentTag(tag) {
    return tag === 'component' || tag === 'Component';
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            '{}',
            'undefined',
            'true'
        ];
        let expectedLen = 2;
        if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
        }
        if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
            expectedLen = 5;
        }
        slotArgs.splice(expectedLen); // remove unused arguments
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            let rawName = arg.content;
            // TODO deprecate @vnodeXXX usage
            if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
            }
            // for all event listeners, auto convert it to camelCase. See issue #2249
            eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    // mark the key as handler for props normalization check
    ret.props.forEach(p => (p.key.isHandlerKey = true));
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!context.inSSR) {
        if (modifiers.includes('prop')) {
            injectPrefix(arg, '.');
        }
        if (modifiers.includes('attr')) {
            injectPrefix(arg, '^');
        }
    }
    if (!exp ||
        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};
const injectPrefix = (arg, prefix) => {
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            arg.content = prefix + arg.content;
        }
        else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
        }
    }
    else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
    }
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* ROOT */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 11 /* FOR */ ||
        node.type === 10 /* IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = {
                                    type: 8 /* COMPOUND_EXPRESSION */,
                                    loc: child.loc,
                                    children: [child]
                                };
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* ROOT */ ||
                        (node.type === 1 /* ELEMENT */ &&
                            node.tagType === 0 /* ELEMENT */ &&
                            // #3756
                            // custom directives can potentially add DOM elements arbitrarily,
                            // we need to avoid setting textContent of the element at runtime
                            // to avoid accidentally overwriting the DOM elements added
                            // by the user through custom directives.
                            !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&
                                !context.directiveTransforms[p.name]) &&
                            // in compat mode, <template> tags with no special directives
                            // will be rendered as a fragment so its children must be
                            // converted into vnodes.
                            !(node.tag === 'template'))))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                        callArgs.push(1 /* TEXT */ +
                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));
                    }
                    children[i] = {
                        type: 12 /* TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
        if (seen.has(node) || context.inVOnce) {
            return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    context.bindingMetadata[rawExp];
    const maybeRef = !true    /* SETUP_CONST */;
    if (!expString.trim() ||
        (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER" /* COMPILER_FILTERS */, context)) {
        return;
    }
    if (node.type === 5 /* INTERPOLATION */) {
        // filter rewrite is applied before expression transform so only
        // simple expressions are possible at this stage
        rewriteFilter(node.content, context);
    }
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((prop) => {
            if (prop.type === 7 /* DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp) {
                rewriteFilter(prop.exp, context);
            }
        });
    }
};
function rewriteFilter(node, context) {
    if (node.type === 4 /* SIMPLE_EXPRESSION */) {
        parseFilter(node, context);
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== 'object')
                continue;
            if (child.type === 4 /* SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
            }
            else if (child.type === 8 /* COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
            }
            else if (child.type === 5 /* INTERPOLATION */) {
                rewriteFilter(child.content, context);
            }
        }
    }
}
function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters.length) {
        ( true) &&
            warnDeprecation("COMPILER_FILTER" /* COMPILER_FILTERS */, context, node.loc);
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
    }
}
function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf('(');
    if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, 'filter')}(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

const seen$1 = new WeakSet();
const transformMemo = (node, context) => {
    if (node.type === 1 /* ELEMENT */) {
        const dir = findDir(node, 'memo');
        if (!dir || seen$1.has(node)) {
            return;
        }
        seen$1.add(node);
        return () => {
            const codegenNode = node.codegenNode ||
                context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* COMPONENT */) {
                    makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++)
                ]);
            }
        };
    }
};

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...([transformFilter] ),
            ...(( true)
                    ? [transformExpression]
                    : 0),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "makeBlock": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);
const V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);
const V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);
const V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);
const V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);
const V_SHOW = Symbol(( true) ? `vShow` : 0);
const TRANSITION = Symbol(( true) ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {
            return TRANSITION;
        }
        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* HTML */;
        if (parent && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* DIRECTIVE */,
                    name: `bind`,
                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}
const DOMErrorMessages = {
    [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
            if (type) {
                if (type.type === 7 /* DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            ( true) && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                ( true) && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            ( true) && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
const isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)
        : key.type !== 4 /* SIMPLE_EXPRESSION */
            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const warnTransitionChildren = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 1 /* COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (node.children.length && hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&
        !(c.type === 2 /* TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* FOR */ ||
        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...(( true) ? [warnTransitionChildren] : 0)
];
const DOMDirectiveTransforms = {
    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/const.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/const.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HOOK_PLUGIN_SETTINGS_SET": () => (/* binding */ HOOK_PLUGIN_SETTINGS_SET),
/* harmony export */   "HOOK_SETUP": () => (/* binding */ HOOK_SETUP)
/* harmony export */ });
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/env.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevtoolsGlobalHook": () => (/* binding */ getDevtoolsGlobalHook),
/* harmony export */   "getTarget": () => (/* binding */ getTarget),
/* harmony export */   "isProxyAvailable": () => (/* binding */ isProxyAvailable)
/* harmony export */ });
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-ignore
    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')
        ? window
        : typeof __webpack_require__.g !== 'undefined'
            ? __webpack_require__.g
            : {};
}
const isProxyAvailable = typeof Proxy === 'function';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPerformanceSupported": () => (/* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_0__.isPerformanceSupported),
/* harmony export */   "now": () => (/* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_0__.now),
/* harmony export */   "setupDevtoolsPlugin": () => (/* binding */ setupDevtoolsPlugin)
/* harmony export */ });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "./node_modules/@vue/devtools-api/lib/esm/env.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy */ "./node_modules/@vue/devtools-api/lib/esm/proxy.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/@vue/devtools-api/lib/esm/time.js");






function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getTarget)();
    const hook = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getDevtoolsGlobalHook)();
    const enableProxy = _env__WEBPACK_IMPORTED_MODULE_1__.isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(_const__WEBPACK_IMPORTED_MODULE_2__.HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const proxy = enableProxy ? new _proxy__WEBPACK_IMPORTED_MODULE_3__.ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy,
        });
        if (proxy)
            setupFn(proxy.proxiedTarget);
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/proxy.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/proxy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiProxy": () => (/* binding */ ApiProxy)
/* harmony export */ });
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/@vue/devtools-api/lib/esm/time.js");


class ApiProxy {
    constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
            for (const id in plugin.settings) {
                const item = plugin.settings[id];
                defaultSettings[id] = item.defaultValue;
            }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
        }
        catch (e) {
            // noop
        }
        this.fallbacks = {
            getSettings() {
                return currentSettings;
            },
            setSettings(value) {
                try {
                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                }
                catch (e) {
                    // noop
                }
                currentSettings = value;
            },
            now() {
                return (0,_time__WEBPACK_IMPORTED_MODULE_0__.now)();
            },
        };
        if (hook) {
            hook.on(_const__WEBPACK_IMPORTED_MODULE_1__.HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
                if (pluginId === this.plugin.id) {
                    this.fallbacks.setSettings(value);
                }
            });
        }
        this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target.on[prop];
                }
                else {
                    return (...args) => {
                        this.onQueue.push({
                            method: prop,
                            args,
                        });
                    };
                }
            },
        });
        this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target[prop];
                }
                else if (prop === 'on') {
                    return this.proxiedOn;
                }
                else if (Object.keys(this.fallbacks).includes(prop)) {
                    return (...args) => {
                        this.targetQueue.push({
                            method: prop,
                            args,
                            resolve: () => { },
                        });
                        return this.fallbacks[prop](...args);
                    };
                }
                else {
                    return (...args) => {
                        return new Promise(resolve => {
                            this.targetQueue.push({
                                method: prop,
                                args,
                                resolve,
                            });
                        });
                    };
                }
            },
        });
    }
    async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
        }
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/time.js":
/*!********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/time.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPerformanceSupported": () => (/* binding */ isPerformanceSupported),
/* harmony export */   "now": () => (/* binding */ now)
/* harmony export */ });
let supported;
let perf;
function isPerformanceSupported() {
    var _a;
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else if (typeof __webpack_require__.g !== 'undefined' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = __webpack_require__.g.perf_hooks.performance;
    }
    else {
        supported = false;
    }
    return supported;
}
function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
}


/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "deferredComputed": () => (/* binding */ deferredComputed),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");


function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = this.parent;
            }
        }
        else if ((true)) {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    on() {
        activeEffectScope = this;
    }
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((true)) {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
        }
    }
    stop() {
        if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( true)
            ? { effect: activeEffect, target, type, key }
            : 0;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.onTrack) {
            activeEffect.onTrack(Object.assign({
                effect: activeEffect
            }, debuggerEventExtraInfo));
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( true)
        ? { target, type, key, newValue, oldValue, oldTarget }
        : 0;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((true)) {
                triggerEffects(deps[0], eventInfo);
            }
            else {}
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((true)) {
            triggerEffects(createDep(effects), eventInfo);
        }
        else {}
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    for (const effect of (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep]) {
        if (effect !== activeEffect || effect.allowRecurse) {
            if (( true) && effect.onTrigger) {
                effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));
            }
            if (effect.scheduler) {
                effect.scheduler();
            }
            else {
                effect.run();
            }
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
            return shouldUnwrap ? res.value : res;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
        }
        if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
            }
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "get" /* GET */, key);
    }
    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "has" /* HAS */, key);
    }
    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* SKIP */, true);
    return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = toRaw(ref);
        if ((true)) {
            trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: "get" /* GET */,
                key: 'value'
            });
        }
        else {}
    }
}
function triggerRefValue(ref, newVal) {
    ref = toRaw(ref);
    if (ref.dep) {
        if ((true)) {
            triggerEffects(ref.dep, {
                target: ref,
                type: "set" /* SET */,
                key: 'value',
                newValue: newVal
            });
        }
        else {}
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (( true) && debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}

var _a;
const tick = Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn) => {
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = () => {
    for (let i = 0; i < queue.length; i++) {
        queue[i]();
    }
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter) {
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                }
                else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(() => {
                        if (this.effect.active && this._get() !== valueToCompare) {
                            triggerRefValue(this);
                        }
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                    if (e.computed instanceof DeferredComputedRefImpl) {
                        e.scheduler(true /* computedTrigger */);
                    }
                }
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return (this._value = this.effect.run());
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return toRaw(this)._get();
    }
}
_a = "__v_isReadonly" /* IS_READONLY */;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* binding */ createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        if (job.id == null) {
            queue.push(job);
        }
        else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                continue;
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( true)
        ? (job) => checkRecursiveUpdates(seen, job)
        : 0;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && check(job)) {
                    continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance.parent.type.__asyncLoader &&
                instance.parent.ceReload) {
                instance.parent.ceReload(newComp.styles);
            }
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    // eslint-disable-next-line no-restricted-globals
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = 
/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = 
/*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !(false )) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        else if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (( true) &&
        result.patchFlag > 0 &&
        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
        [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (( true) && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                    const key = allAttrs[i];
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                            // remove `on`, lowercase first letter to reflect event casing
                            // accurately
                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                        }
                    }
                    else {
                        extraAttrs.push(key);
                    }
                }
                if (extraAttrs.length) {
                    warn(`Extraneous non-props attributes (` +
                        `${extraAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
                if (eventAttrs.length) {
                    warn(`Extraneous non-emits event listeners (` +
                        `${eventAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes. ` +
                        `If the listener is intended to be a component custom event listener only, ` +
                        `declare it using the "emits" option.`);
                }
            }
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (( true) && !isElementRoot(root)) {
            warn(`Runtime directive used on component with non-element root node. ` +
                `The directives will not function as intended.`);
        }
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (( true) && !isElementRoot(root)) {
            warn(`Component inside <Transition> renders non-element root node ` +
                `that cannot be animated.`);
        }
        root.transition = vnode.transition;
    }
    if (( true) && setRoot) {
        setRoot(root);
    }
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(options || {}, { flush: 'post' })
        : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(options || {}, { flush: 'sync' })
        : 0));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => {
            if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);
    if ((true)) {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    return () => {
        effect.stop();
        if (instance && instance.scope) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (( true) && children.length > 1) {
                warn('<transition> can only be used on a single element or component. Use ' +
                    '<transition-group> for lists.');
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) &&
                mode &&
                mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') {
                warn(`invalid <transition> mode: ${mode}`);
            }
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (( true) && !comp) {
                        warn(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children } }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return slots.default;
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
            warn(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
            warn(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
            ( true) && warn(`data() should return an object.`);
        }
        else {
            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* DATA */, key);
                    // expose data on ctx during dev
                    if (key[0] !== '$' && key[0] !== '_') {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((true)) {
                    warn(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                        `and no longer needs \`.value\` in the next minor release. ` +
                        `To opt-in to the new behavior now, ` +
                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                        `temporary and will not be needed in the future.)`);
                }
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                        (!false ))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    const normalized = withCtx((...args) => {
        if (( true) && currentInstance) {
            warn(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (true) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(false )) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
    }
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else if ((true)) {
                    warn('Mixins are only available in builds supporting Options API');
                }
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) {
                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
                    }
                    else {
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((true)) {
                    warn('Invalid template ref type:', ref, `(${typeof ref})`);
                }
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((true)) {
            warn('Invalid template ref type:', ref, `(${typeof ref})`);
        }
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (true /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_OPTIONS_API__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (( true) && needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +
            `which expects these compile-time feature flags to be globally injected ` +
            `via the bundler config in order to get better tree-shaking in the ` +
            `production bundle.\n\n` +
            `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    if (true) {
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                    hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = effect.run.bind(effect));
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((true)) {
            effect.onTrack = instance.rtc
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)
                : void 0;
            effect.onTrigger = instance.rtg
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)
                : void 0;
            // @ts-ignore (for scheduler)
            update.ownerInstance = instance;
        }
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            const extra = type === COMPONENTS
                ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)
            ? 8 /* TEXT_CHILDREN */
            : 16 /* ARRAY_CHILDREN */;
    }
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const createVNode = (( true) ? createVNodeWithArgsTransform : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
            return [];
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE) {
        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
    }
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: i => nextTick.bind(i.proxy),
    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP)
});
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (( true) &&
            setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
            setupState.__isScriptSetup &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            return setupState[key];
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* SETUP */:
                        return setupState[key];
                    case 2 /* DATA */:
                        return data[key];
                    case 4 /* CONTEXT */:
                        return ctx[key];
                    case 3 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
            }
            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
                accessCache[key] = 0 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (key[0] === '$' || key[0] === '_') &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) &&
                warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            this.set(target, key, descriptor.get(), null);
        }
        else if (descriptor.value != null) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (key[0] === '$' || key[0] === '_') {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        }
    });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createDevRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if (__VUE_OPTIONS_API__ && !(false )) {
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( true)
        ? {
            get(target, key) {
                markAttrsAccessed();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, '$attrs');
                return target[key];
            },
            set() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            },
            deleteProperty() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            }
        }
        : 0);
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

const computed = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (( true) && !ctx) {
        warn(`withAsyncContext called without active current instance. ` +
            `This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if (prev[i] !== memo[i]) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.31";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = (_ssrUtils );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "VueElement": () => (/* binding */ VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* binding */ defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* binding */ initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
            return;
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            try {
                el[key] = 0;
            }
            catch (_a) { }
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== 'undefined') {
    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    if (_getNow() > document.createEvent('Event').timeStamp) {
        // if the low-res timestamp which is bigger than the event timestamp
        // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listeners as well.
        _getNow = () => performance.now();
    }
    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
    // and does not fire microtasks in between event propagation, so safe to exclude.
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydate) {
    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (( true) && this.shadowRoot) {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: 'open' });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def) => {
            const { props, styles } = def;
            const hasOptions = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);
            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) {
                for (const key in this._props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
                        (numberProps || (numberProps = Object.create(null)))[key] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                    this._setProp(key, this[key], true, false);
                }
            }
            // defining getter/setters on prototype
            for (const key of rawKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
                Object.defineProperty(this, key, {
                    get() {
                        return this._getProp(key);
                    },
                    set(val) {
                        this._setProp(key, val);
                    }
                });
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(resolve);
        }
        else {
            resolve(this._def);
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
        }
        this._setProp((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((true)) {
                    instance.ceReload = newStyles => {
                        // always reset styles
                        if (this._styles) {
                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
                            this._styles.length = 0;
                        }
                        this._applyStyles(newStyles);
                        // if this is an async component, ceReload is called from the inner
                        // component so no need to reload the async wrapper
                        if (!this._def.__asyncLoader) {
                            // reload
                            this._instance = null;
                            this._update();
                        }
                    };
                }
                // intercept emit
                instance.emit = (event, ...args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((true)) {
                    (this._styles || (this._styles = [])).push(s);
                }
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook = (hook, args = []) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el) {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        window.ShadowRoot &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
var parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ "./node_modules/axios/lib/helpers/parseProtocol.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
axios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);
axios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

// Expose AxiosError class
axios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CanceledError = __webpack_require__(/*! ./CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var buildFullPath = __webpack_require__(/*! ./buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ./AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var transitionalDefaults = __webpack_require__(/*! ./transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var toFormData = __webpack_require__(/*! ../helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ../adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ../adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: __webpack_require__(/*! ./env/FormData */ "./node_modules/axios/lib/helpers/null.js")
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((module) => {

// eslint-disable-next-line strict
module.exports = null;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(/*! ../env/data */ "./node_modules/axios/lib/env/data.js").version);
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var TypeError = global.TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-constructor.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/a-constructor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var TypeError = global.TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var String = global.String;
var TypeError = global.TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw TypeError("Can't set " + String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var String = global.String;
var TypeError = global.TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice-simple.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice-simple.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

var Array = global.Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var Array = global.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Object = global.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-well-known-symbol.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-token-list-prototype.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/dom-token-list-prototype.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/function-apply.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var Function = global.Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = NATIVE_BIND ? Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var Object = global.Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es-x/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Object = global.Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es-x/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  redefine(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol-registry.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol-registry.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

/* eslint-disable es-x/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es-x/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es-x/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var TypeError = global.TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var Object = global.Object;
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var TypeError = global.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var TypeError = global.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.22.2',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-define-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-define-to-primitive.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    redefine(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- safe
  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var Object = global.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TypeError = global.TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/to-string.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var String = global.String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var String = global.String;

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "./node_modules/core-js/modules/es.json.stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.json.stringify.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = replacer;
  if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
  if (!isArray(replacer)) replacer = function (key, value) {
    if (isCallable($replacer)) value = call($replacer, this, key, value);
    if (!isSymbol(value)) return value;
  };
  args[1] = replacer;
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim);

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var arraySlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = arraySlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
    var dummy = this;
    // check on 1..constructor(foo) case
    return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.create.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-symbols.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt);
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  redefine(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
  var symbolToString = uncurryThis(SymbolPrototype.toString);
  var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineProperty(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = symbolValueOf(this);
      var string = symbolToString(symbol);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.for.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.for.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/native-symbol-registry */ "./node_modules/core-js/internals/native-symbol-registry.js");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.symbol.constructor */ "./node_modules/core-js/modules/es.symbol.constructor.js");
__webpack_require__(/*! ../modules/es.symbol.for */ "./node_modules/core-js/modules/es.symbol.for.js");
__webpack_require__(/*! ../modules/es.symbol.key-for */ "./node_modules/core-js/modules/es.symbol.key-for.js");
__webpack_require__(/*! ../modules/es.json.stringify */ "./node_modules/core-js/modules/es.json.stringify.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.key-for.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.key-for.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/native-symbol-registry */ "./node_modules/core-js/internals/native-symbol-registry.js");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var DOMTokenListPrototype = __webpack_require__(/*! ../internals/dom-token-list-prototype */ "./node_modules/core-js/internals/dom-token-list-prototype.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm-bundler.js":
/*!****************************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm-bundler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationFailureType": () => (/* binding */ NavigationFailureType),
/* harmony export */   "RouterLink": () => (/* binding */ RouterLink),
/* harmony export */   "RouterView": () => (/* binding */ RouterView),
/* harmony export */   "START_LOCATION": () => (/* binding */ START_LOCATION_NORMALIZED),
/* harmony export */   "createMemoryHistory": () => (/* binding */ createMemoryHistory),
/* harmony export */   "createRouter": () => (/* binding */ createRouter),
/* harmony export */   "createRouterMatcher": () => (/* binding */ createRouterMatcher),
/* harmony export */   "createWebHashHistory": () => (/* binding */ createWebHashHistory),
/* harmony export */   "createWebHistory": () => (/* binding */ createWebHistory),
/* harmony export */   "isNavigationFailure": () => (/* binding */ isNavigationFailure),
/* harmony export */   "matchedRouteKey": () => (/* binding */ matchedRouteKey),
/* harmony export */   "onBeforeRouteLeave": () => (/* binding */ onBeforeRouteLeave),
/* harmony export */   "onBeforeRouteUpdate": () => (/* binding */ onBeforeRouteUpdate),
/* harmony export */   "parseQuery": () => (/* binding */ parseQuery),
/* harmony export */   "routeLocationKey": () => (/* binding */ routeLocationKey),
/* harmony export */   "routerKey": () => (/* binding */ routerKey),
/* harmony export */   "routerViewLocationKey": () => (/* binding */ routerViewLocationKey),
/* harmony export */   "stringifyQuery": () => (/* binding */ stringifyQuery),
/* harmony export */   "useLink": () => (/* binding */ useLink),
/* harmony export */   "useRoute": () => (/* binding */ useRoute),
/* harmony export */   "useRouter": () => (/* binding */ useRouter),
/* harmony export */   "viewDepthKey": () => (/* binding */ viewDepthKey)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
  * vue-router v4.0.15
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */



const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
const PolySymbol = (name) => 
// vr = vue router
hasSymbol
    ? Symbol(( true) ? '[vue-router]: ' + name : 0)
    : (( true) ? '[vue-router]: ' : 0) + name;
// rvlm = Router View Location Matched
/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */
const matchedRouteKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view location matched' : 0);
/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */
const viewDepthKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view depth' : 0);
/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */
const routerKey = /*#__PURE__*/ PolySymbol(( true) ? 'router' : 0);
/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */
const routeLocationKey = /*#__PURE__*/ PolySymbol(( true) ? 'route location' : 0);
/**
 * Allows overriding the current route used by router-view. Internally this is
 * used when the `route` prop is passed.
 *
 * @internal
 */
const routerViewLocationKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view location' : 0);

const isBrowser = typeof window !== 'undefined';

function isESModule(obj) {
    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');
}
const assign = Object.assign;
function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
        const value = params[key];
        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
}
const noop = () => { };

function warn(msg) {
    // avoid using ...args as it breaks in older Edge builds
    const args = Array.from(arguments).slice(1);
    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
}

const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');
/**
 * Transforms an URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */
function parseURL(parseQuery, location, currentLocation = '/') {
    let path, query = {}, searchString = '', hash = '';
    // Could use URL and URLSearchParams but IE 11 doesn't support it
    const searchPos = location.indexOf('?');
    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
        path = location.slice(0, searchPos);
        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
        query = parseQuery(searchString);
    }
    if (hashPos > -1) {
        path = path || location.slice(0, hashPos);
        // keep the # character
        hash = location.slice(hashPos, location.length);
    }
    // no search and no query
    path = resolveRelativePath(path != null ? path : location, currentLocation);
    // empty path means a relative query or hash `?foo=f`, `#thing`
    return {
        fullPath: path + (searchString && '?') + searchString + hash,
        path,
        query,
        hash,
    };
}
/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */
function stringifyURL(stringifyQuery, location) {
    const query = location.query ? stringifyQuery(location.query) : '';
    return location.path + (query && '?') + query + (location.hash || '');
}
/**
 * Strips off the base from the beginning of a location.pathname in a non
 * case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */
function stripBase(pathname, base) {
    // no base or base is not found at the beginning
    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
    return pathname.slice(base.length) || '/';
}
/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */
function isSameRouteLocation(stringifyQuery, a, b) {
    const aLastIndex = a.matched.length - 1;
    const bLastIndex = b.matched.length - 1;
    return (aLastIndex > -1 &&
        aLastIndex === bLastIndex &&
        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
        isSameRouteLocationParams(a.params, b.params) &&
        stringifyQuery(a.query) === stringifyQuery(b.query) &&
        a.hash === b.hash);
}
/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */
function isSameRouteRecord(a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
            return false;
    }
    return true;
}
function isSameRouteLocationParamsValue(a, b) {
    return Array.isArray(a)
        ? isEquivalentArray(a, b)
        : Array.isArray(b)
            ? isEquivalentArray(b, a)
            : a === b;
}
/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */
function isEquivalentArray(a, b) {
    return Array.isArray(b)
        ? a.length === b.length && a.every((value, i) => value === b[i])
        : a.length === 1 && a[0] === b;
}
/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */
function resolveRelativePath(to, from) {
    if (to.startsWith('/'))
        return to;
    if (( true) && !from.startsWith('/')) {
        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
        return to;
    }
    if (!to)
        return from;
    const fromSegments = from.split('/');
    const toSegments = to.split('/');
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        // can't go below zero
        if (position === 1 || segment === '.')
            continue;
        if (segment === '..')
            position--;
        // found something that is not relative path
        else
            break;
    }
    return (fromSegments.slice(0, position).join('/') +
        '/' +
        toSegments
            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
            .join('/'));
}

var NavigationType;
(function (NavigationType) {
    NavigationType["pop"] = "pop";
    NavigationType["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (NavigationDirection) {
    NavigationDirection["back"] = "back";
    NavigationDirection["forward"] = "forward";
    NavigationDirection["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
/**
 * Starting location for Histories
 */
const START = '';
// Generic utils
/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */
function normalizeBase(base) {
    if (!base) {
        if (isBrowser) {
            // respect <base> tag
            const baseEl = document.querySelector('base');
            base = (baseEl && baseEl.getAttribute('href')) || '/';
            // strip full URL origin
            base = base.replace(/^\w+:\/\/[^\/]+/, '');
        }
        else {
            base = '/';
        }
    }
    // ensure leading slash when it was removed by the regex above avoid leading
    // slash with hash because the file could be read from the disk like file://
    // and the leading slash would cause problems
    if (base[0] !== '/' && base[0] !== '#')
        base = '/' + base;
    // remove the trailing slash so all other method can just do `base + fullPath`
    // to build an href
    return removeTrailingSlash(base);
}
// remove any character before the hash
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
    return base.replace(BEFORE_HASH_RE, '#') + location;
}

function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0),
    };
}
const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset,
});
function scrollToPosition(position) {
    let scrollToOptions;
    if ('el' in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');
        /**
         * `id`s can accept pretty much any characters, including CSS combinators
         * like `>` or `~`. It's still possible to retrieve elements using
         * `document.getElementById('~')` but it needs to be escaped when using
         * `document.querySelector('#\\~')` for it to be valid. The only
         * requirements for `id`s are them to be unique on the page and to not be
         * empty (`id=""`). Because of that, when passing an id selector, it should
         * be properly escaped for it to work with `querySelector`. We could check
         * for the id selector to be simple (no CSS combinators `+ >~`) but that
         * would make things inconsistent since they are valid characters for an
         * `id` but would need to be escaped when using `querySelector`, breaking
         * their usage and ending up in no selector returned. Selectors need to be
         * escaped:
         *
         * - `#1-thing` becomes `#\31 -thing`
         * - `#with~symbols` becomes `#with\\~symbols`
         *
         * - More information about  the topic can be found at
         *   https://mathiasbynens.be/notes/html5-id-class.
         * - Practical example: https://mathiasbynens.be/demo/html5-id
         */
        if (( true) && typeof position.el === 'string') {
            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
                try {
                    const foundEl = document.querySelector(position.el);
                    if (isIdSelector && foundEl) {
                        warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
                        // return to avoid other warnings
                        return;
                    }
                }
                catch (err) {
                    warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
                    // return to avoid other warnings
                    return;
                }
            }
        }
        const el = typeof positionEl === 'string'
            ? isIdSelector
                ? document.getElementById(positionEl.slice(1))
                : document.querySelector(positionEl)
            : positionEl;
        if (!el) {
            ( true) &&
                warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
            return;
        }
        scrollToOptions = getElementPosition(el, position);
    }
    else {
        scrollToOptions = position;
    }
    if ('scrollBehavior' in document.documentElement.style)
        window.scrollTo(scrollToOptions);
    else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
}
function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    // consume it so it's not used again
    scrollPositions.delete(key);
    return scroll;
}
// TODO: RFC about how to save scroll position
/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */
// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }

let createBaseLocation = () => location.protocol + '//' + location.host;
/**
 * Creates a normalized history location from a window.location object
 * @param location -
 */
function createCurrentLocation(base, location) {
    const { pathname, search, hash } = location;
    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
    const hashPos = base.indexOf('#');
    if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos))
            ? base.slice(hashPos).length
            : 1;
        let pathFromHash = hash.slice(slicePos);
        // prepend the starting slash to hash so the url starts with /#
        if (pathFromHash[0] !== '/')
            pathFromHash = '/' + pathFromHash;
        return stripBase(pathFromHash, '');
    }
    const path = stripBase(pathname, base);
    return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    // TODO: should it be a stack? a Dict. Check if the popstate listener
    // can trigger twice
    let pauseState = null;
    const popStateHandler = ({ state, }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
            currentLocation.value = to;
            historyState.value = state;
            // ignore the popstate and reset the pauseState
            if (pauseState && pauseState === from) {
                pauseState = null;
                return;
            }
            delta = fromState ? state.position - fromState.position : 0;
        }
        else {
            replace(to);
        }
        // console.log({ deltaFromCurrent })
        // Here we could also revert the navigation by calling history.go(-delta)
        // this listener will have to be adapted to not trigger again and to wait for the url
        // to be updated before triggering the listeners. Some kind of validation function would also
        // need to be passed to the listeners so the navigation can be accepted
        // call all listeners
        listeners.forEach(listener => {
            listener(currentLocation.value, from, {
                delta,
                type: NavigationType.pop,
                direction: delta
                    ? delta > 0
                        ? NavigationDirection.forward
                        : NavigationDirection.back
                    : NavigationDirection.unknown,
            });
        });
    };
    function pauseListeners() {
        pauseState = currentLocation.value;
    }
    function listen(callback) {
        // setup the listener and prepare teardown callbacks
        listeners.push(callback);
        const teardown = () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
                listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
    }
    function beforeUnloadListener() {
        const { history } = window;
        if (!history.state)
            return;
        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');
    }
    function destroy() {
        for (const teardown of teardowns)
            teardown();
        teardowns = [];
        window.removeEventListener('popstate', popStateHandler);
        window.removeEventListener('beforeunload', beforeUnloadListener);
    }
    // setup the listeners and prepare teardown callbacks
    window.addEventListener('popstate', popStateHandler);
    window.addEventListener('beforeunload', beforeUnloadListener);
    return {
        pauseListeners,
        listen,
        destroy,
    };
}
/**
 * Creates a state object
 */
function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null,
    };
}
function useHistoryStateNavigation(base) {
    const { history, location } = window;
    // private variables
    const currentLocation = {
        value: createCurrentLocation(base, location),
    };
    const historyState = { value: history.state };
    // build current history entry as this is a fresh navigation
    if (!historyState.value) {
        changeLocation(currentLocation.value, {
            back: null,
            current: currentLocation.value,
            forward: null,
            // the length is off by one, we need to decrease it
            position: history.length - 1,
            replaced: true,
            // don't add a scroll as the user may have an anchor and we want
            // scrollBehavior to be triggered without a saved position
            scroll: null,
        }, true);
    }
    function changeLocation(to, state, replace) {
        /**
         * if a base tag is provided and we are on a normal domain, we have to
         * respect the provided `base` attribute because pushState() will use it and
         * potentially erase anything before the `#` like at
         * https://github.com/vuejs/router/issues/685 where a base of
         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
         * there is no host, the `<base>` tag makes no sense and if there isn't a
         * base tag we can just use everything after the `#`.
         */
        const hashIndex = base.indexOf('#');
        const url = hashIndex > -1
            ? (location.host && document.querySelector('base')
                ? base
                : base.slice(hashIndex)) + to
            : createBaseLocation() + base + to;
        try {
            // BROWSER QUIRK
            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            historyState.value = state;
        }
        catch (err) {
            if ((true)) {
                warn('Error with push/replace State', err);
            }
            else {}
            // Force the navigation, this also resets the call count
            location[replace ? 'replace' : 'assign'](url);
        }
    }
    function replace(to, data) {
        const state = assign({}, history.state, buildState(historyState.value.back, 
        // keep back and forward entries but override current position
        to, historyState.value.forward, true), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
    }
    function push(to, data) {
        // Add to current entry the information of where we are going
        // as well as saving the current position
        const currentState = assign({}, 
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/router/issues/366
        historyState.value, history.state, {
            forward: to,
            scroll: computeScrollPosition(),
        });
        if (( true) && !history.state) {
            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` +
                `history.replaceState(history.state, '', url)\n\n` +
                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
        }
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
    }
    return {
        location: currentLocation,
        state: historyState,
        push,
        replace,
    };
}
/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */
function createWebHistory(base) {
    base = normalizeBase(base);
    const historyNavigation = useHistoryStateNavigation(base);
    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
        if (!triggerListeners)
            historyListeners.pauseListeners();
        history.go(delta);
    }
    const routerHistory = assign({
        // it's overridden right after
        location: '',
        base,
        go,
        createHref: createHref.bind(null, base),
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => historyNavigation.location.value,
    });
    Object.defineProperty(routerHistory, 'state', {
        enumerable: true,
        get: () => historyNavigation.state.value,
    });
    return routerHistory;
}

/**
 * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
 *
 * @param base - Base applied to all urls, defaults to '/'
 * @returns a history object that can be passed to the router constructor
 */
function createMemoryHistory(base = '') {
    let listeners = [];
    let queue = [START];
    let position = 0;
    base = normalizeBase(base);
    function setLocation(location) {
        position++;
        if (position === queue.length) {
            // we are at the end, we can simply append a new entry
            queue.push(location);
        }
        else {
            // we are in the middle, we remove everything from here in the queue
            queue.splice(position);
            queue.push(location);
        }
    }
    function triggerListeners(to, from, { direction, delta }) {
        const info = {
            direction,
            delta,
            type: NavigationType.pop,
        };
        for (const callback of listeners) {
            callback(to, from, info);
        }
    }
    const routerHistory = {
        // rewritten by Object.defineProperty
        location: START,
        // TODO: should be kept in queue
        state: {},
        base,
        createHref: createHref.bind(null, base),
        replace(to) {
            // remove current entry and decrement position
            queue.splice(position--, 1);
            setLocation(to);
        },
        push(to, data) {
            setLocation(to);
        },
        listen(callback) {
            listeners.push(callback);
            return () => {
                const index = listeners.indexOf(callback);
                if (index > -1)
                    listeners.splice(index, 1);
            };
        },
        destroy() {
            listeners = [];
            queue = [START];
            position = 0;
        },
        go(delta, shouldTrigger = true) {
            const from = this.location;
            const direction = 
            // we are considering delta === 0 going forward, but in abstract mode
            // using 0 for the delta doesn't make sense like it does in html5 where
            // it reloads the page
            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
            position = Math.max(0, Math.min(position + delta, queue.length - 1));
            if (shouldTrigger) {
                triggerListeners(this.location, from, {
                    direction,
                    delta,
                });
            }
        },
    };
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => queue[position],
    });
    return routerHistory;
}

/**
 * Creates a hash history. Useful for web applications with no host (e.g.
 * `file://`) or when configuring a server to handle any URL is not possible.
 *
 * @param base - optional base to provide. Defaults to `location.pathname +
 * location.search` If there is a `<base>` tag in the `head`, its value will be
 * ignored in favor of this parameter **but note it affects all the
 * history.pushState() calls**, meaning that if you use a `<base>` tag, it's
 * `href` value **has to match this parameter** (ignoring anything after the
 * `#`).
 *
 * @example
 * ```js
 * // at https://example.com/folder
 * createWebHashHistory() // gives a url of `https://example.com/folder#`
 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
 * // you should avoid doing this because it changes the original url and breaks copying urls
 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
 *
 * // at file:///usr/etc/folder/index.html
 * // for locations with no `host`, the base is ignored
 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
 * ```
 */
function createWebHashHistory(base) {
    // Make sure this implementation is fine in terms of encoding, specially for IE11
    // for `file://`, directly use the pathname and ignore the base
    // location.pathname contains an initial `/` even at the root: `https://example.com`
    base = location.host ? base || location.pathname + location.search : '';
    // allow the user to provide a `#` in the middle: `/base/#/app`
    if (!base.includes('#'))
        base += '#';
    if (( true) && !base.endsWith('#/') && !base.endsWith('#')) {
        warn(`A hash base must end with a "#":\n"${base}" should be "${base.replace(/#.*$/, '#')}".`);
    }
    return createWebHistory(base);
}

function isRouteLocation(route) {
    return typeof route === 'string' || (route && typeof route === 'object');
}
function isRouteName(name) {
    return typeof name === 'string' || typeof name === 'symbol';
}

/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */
const START_LOCATION_NORMALIZED = {
    path: '/',
    name: undefined,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: undefined,
};

const NavigationFailureSymbol = /*#__PURE__*/ PolySymbol(( true) ? 'navigation failure' : 0);
/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */
var NavigationFailureType;
(function (NavigationFailureType) {
    /**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */
    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
    /**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */
    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
    /**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */
    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
// DEV only debug messages
const ErrorTypeMessages = {
    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {
        return `No match for\n ${JSON.stringify(location)}${currentLocation
            ? '\nwhile being at\n' + JSON.stringify(currentLocation)
            : ''}`;
    },
    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {
        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
    },
    [4 /* NAVIGATION_ABORTED */]({ from, to }) {
        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
    },
    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {
        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
    },
    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {
        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
    },
};
function createRouterError(type, params) {
    // keep full error messages in cjs versions
    if (true) {
        return assign(new Error(ErrorTypeMessages[type](params)), {
            type,
            [NavigationFailureSymbol]: true,
        }, params);
    }
    else {}
}
function isNavigationFailure(error, type) {
    return (error instanceof Error &&
        NavigationFailureSymbol in error &&
        (type == null || !!(error.type & type)));
}
const propertiesToLog = ['params', 'query', 'hash'];
function stringifyRoute(to) {
    if (typeof to === 'string')
        return to;
    if ('path' in to)
        return to.path;
    const location = {};
    for (const key of propertiesToLog) {
        if (key in to)
            location[key] = to[key];
    }
    return JSON.stringify(location, null, 2);
}

// default pattern for a param: non greedy everything but /
const BASE_PARAM_PATTERN = '[^/]+?';
const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true,
};
// Special Regex characters that must be escaped in static tokens
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */
function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    // the amount of scores is the same as the length of segments except for the root segment "/"
    const score = [];
    // the regexp as a string
    let pattern = options.start ? '^' : '';
    // extracted keys
    const keys = [];
    for (const segment of segments) {
        // the root segment needs special treatment
        const segmentScores = segment.length ? [] : [90 /* Root */];
        // allow trailing slash
        if (options.strict && !segment.length)
            pattern += '/';
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
            const token = segment[tokenIndex];
            // resets the score if we are inside a sub segment /:a-other-:b
            let subSegmentScore = 40 /* Segment */ +
                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);
            if (token.type === 0 /* Static */) {
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    pattern += '/';
                pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
                subSegmentScore += 40 /* Static */;
            }
            else if (token.type === 1 /* Param */) {
                const { value, repeatable, optional, regexp } = token;
                keys.push({
                    name: value,
                    repeatable,
                    optional,
                });
                const re = regexp ? regexp : BASE_PARAM_PATTERN;
                // the user provided a custom regexp /:id(\\d+)
                if (re !== BASE_PARAM_PATTERN) {
                    subSegmentScore += 10 /* BonusCustomRegExp */;
                    // make sure the regexp is valid before using it
                    try {
                        new RegExp(`(${re})`);
                    }
                    catch (err) {
                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +
                            err.message);
                    }
                }
                // when we repeat we must take care of the repeating leading slash
                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    subPattern =
                        // avoid an optional / if there are more segments e.g. /:p?-static
                        // or /:p?-:p2
                        optional && segment.length < 2
                            ? `(?:/${subPattern})`
                            : '/' + subPattern;
                if (optional)
                    subPattern += '?';
                pattern += subPattern;
                subSegmentScore += 20 /* Dynamic */;
                if (optional)
                    subSegmentScore += -8 /* BonusOptional */;
                if (repeatable)
                    subSegmentScore += -20 /* BonusRepeatable */;
                if (re === '.*')
                    subSegmentScore += -50 /* BonusWildcard */;
            }
            segmentScores.push(subSegmentScore);
        }
        // an empty array like /home/ -> [[{home}], []]
        // if (!segment.length) pattern += '/'
        score.push(segmentScores);
    }
    // only apply the strict bonus to the last score
    if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;
    }
    // TODO: dev only warn double trailing slash
    if (!options.strict)
        pattern += '/?';
    if (options.end)
        pattern += '$';
    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
    else if (options.strict)
        pattern += '(?:/|$)';
    const re = new RegExp(pattern, options.sensitive ? '' : 'i');
    function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
            return null;
        for (let i = 1; i < match.length; i++) {
            const value = match[i] || '';
            const key = keys[i - 1];
            params[key.name] = value && key.repeatable ? value.split('/') : value;
        }
        return params;
    }
    function stringify(params) {
        let path = '';
        // for optional parameters to allow to be empty
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
            if (!avoidDuplicatedSlash || !path.endsWith('/'))
                path += '/';
            avoidDuplicatedSlash = false;
            for (const token of segment) {
                if (token.type === 0 /* Static */) {
                    path += token.value;
                }
                else if (token.type === 1 /* Param */) {
                    const { value, repeatable, optional } = token;
                    const param = value in params ? params[value] : '';
                    if (Array.isArray(param) && !repeatable)
                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
                    const text = Array.isArray(param) ? param.join('/') : param;
                    if (!text) {
                        if (optional) {
                            // if we have more than one optional param like /:a?-static and there are more segments, we don't need to
                            // care about the optional param
                            if (segment.length < 2 && segments.length > 1) {
                                // remove the last slash as we could be at the end
                                if (path.endsWith('/'))
                                    path = path.slice(0, -1);
                                // do not append a slash on the next iteration
                                else
                                    avoidDuplicatedSlash = true;
                            }
                        }
                        else
                            throw new Error(`Missing required param "${value}"`);
                    }
                    path += text;
                }
            }
        }
        return path;
    }
    return {
        re,
        score,
        keys,
        parse,
        stringify,
    };
}
/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 *
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */
function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        // only keep going if diff === 0
        if (diff)
            return diff;
        i++;
    }
    // if the last subsegment was Static, the shorter segments should be sorted first
    // otherwise sort the longest segment first
    if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */
            ? -1
            : 1;
    }
    else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */
            ? 1
            : -1;
    }
    return 0;
}
/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 *
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */
function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        // do not return if both are equal
        if (comp)
            return comp;
        i++;
    }
    // if a and b share the same score entries but b has more, sort b first
    return bScore.length - aScore.length;
    // this is the ternary version
    // return aScore.length < bScore.length
    //   ? 1
    //   : aScore.length > bScore.length
    //   ? -1
    //   : 0
}

const ROOT_TOKEN = {
    type: 0 /* Static */,
    value: '',
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
// After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()
function tokenizePath(path) {
    if (!path)
        return [[]];
    if (path === '/')
        return [[ROOT_TOKEN]];
    if (!path.startsWith('/')) {
        throw new Error(( true)
            ? `Route paths should start with a "/": "${path}" should be "/${path}".`
            : 0);
    }
    // if (tokenCache.has(path)) return tokenCache.get(path)!
    function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0 /* Static */;
    let previousState = state;
    const tokens = [];
    // the segment will always be valid because we get into the initial state
    // with the leading /
    let segment;
    function finalizeSegment() {
        if (segment)
            tokens.push(segment);
        segment = [];
    }
    // index on the path
    let i = 0;
    // char at index
    let char;
    // buffer of the value read
    let buffer = '';
    // custom regexp for a param
    let customRe = '';
    function consumeBuffer() {
        if (!buffer)
            return;
        if (state === 0 /* Static */) {
            segment.push({
                type: 0 /* Static */,
                value: buffer,
            });
        }
        else if (state === 1 /* Param */ ||
            state === 2 /* ParamRegExp */ ||
            state === 3 /* ParamRegExpEnd */) {
            if (segment.length > 1 && (char === '*' || char === '+'))
                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
            segment.push({
                type: 1 /* Param */,
                value: buffer,
                regexp: customRe,
                repeatable: char === '*' || char === '+',
                optional: char === '*' || char === '?',
            });
        }
        else {
            crash('Invalid state to consume buffer');
        }
        buffer = '';
    }
    function addCharToBuffer() {
        buffer += char;
    }
    while (i < path.length) {
        char = path[i++];
        if (char === '\\' && state !== 2 /* ParamRegExp */) {
            previousState = state;
            state = 4 /* EscapeNext */;
            continue;
        }
        switch (state) {
            case 0 /* Static */:
                if (char === '/') {
                    if (buffer) {
                        consumeBuffer();
                    }
                    finalizeSegment();
                }
                else if (char === ':') {
                    consumeBuffer();
                    state = 1 /* Param */;
                }
                else {
                    addCharToBuffer();
                }
                break;
            case 4 /* EscapeNext */:
                addCharToBuffer();
                state = previousState;
                break;
            case 1 /* Param */:
                if (char === '(') {
                    state = 2 /* ParamRegExp */;
                }
                else if (VALID_PARAM_RE.test(char)) {
                    addCharToBuffer();
                }
                else {
                    consumeBuffer();
                    state = 0 /* Static */;
                    // go back one character if we were not modifying
                    if (char !== '*' && char !== '?' && char !== '+')
                        i--;
                }
                break;
            case 2 /* ParamRegExp */:
                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
                // it already works by escaping the closing )
                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
                // is this really something people need since you can also write
                // /prefix_:p()_suffix
                if (char === ')') {
                    // handle the escaped )
                    if (customRe[customRe.length - 1] == '\\')
                        customRe = customRe.slice(0, -1) + char;
                    else
                        state = 3 /* ParamRegExpEnd */;
                }
                else {
                    customRe += char;
                }
                break;
            case 3 /* ParamRegExpEnd */:
                // same as finalizing a param
                consumeBuffer();
                state = 0 /* Static */;
                // go back one character if we were not modifying
                if (char !== '*' && char !== '?' && char !== '+')
                    i--;
                customRe = '';
                break;
            default:
                crash('Unknown state');
                break;
        }
    }
    if (state === 2 /* ParamRegExp */)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    // tokenCache.set(path, tokens)
    return tokens;
}

function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    // warn against params with the same name
    if ((true)) {
        const existingKeys = new Set();
        for (const key of parser.keys) {
            if (existingKeys.has(key.name))
                warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
            existingKeys.add(key.name);
        }
    }
    const matcher = assign(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: [],
    });
    if (parent) {
        // both are aliases or both are not aliases
        // we don't want to mix them because the order is used when
        // passing originalRecord in Matcher.addRoute
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
            parent.children.push(matcher);
    }
    return matcher;
}

/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */
function createRouterMatcher(routes, globalOptions) {
    // normalized ordered array of matchers
    const matchers = [];
    const matcherMap = new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
        return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
        // used later on to remove by name
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        // we might be the child of an alias
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        // generate an array of records to correctly handle aliases
        const normalizedRecords = [
            mainNormalizedRecord,
        ];
        if ('alias' in record) {
            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;
            for (const alias of aliases) {
                normalizedRecords.push(assign({}, mainNormalizedRecord, {
                    // this allows us to hold a copy of the `components` option
                    // so that async components cache is hold on the original record
                    components: originalRecord
                        ? originalRecord.record.components
                        : mainNormalizedRecord.components,
                    path: alias,
                    // we might be the child of an alias
                    aliasOf: originalRecord
                        ? originalRecord.record
                        : mainNormalizedRecord,
                    // the aliases are always of the same kind as the original since they
                    // are defined on the same record
                }));
            }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
            const { path } = normalizedRecord;
            // Build up the path for nested routes if the child isn't an absolute
            // route. Only add the / delimiter if the child path isn't empty and if the
            // parent path doesn't have a trailing slash
            if (parent && path[0] !== '/') {
                const parentPath = parent.record.path;
                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
                normalizedRecord.path =
                    parent.record.path + (path && connectingSlash + path);
            }
            if (( true) && normalizedRecord.path === '*') {
                throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
            }
            // create the object before hand so it can be passed to children
            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
            if (( true) && parent && path[0] === '/')
                checkMissingParamsInAbsolutePath(matcher, parent);
            // if we are an alias we must tell the original record that we exist
            // so we can be removed
            if (originalRecord) {
                originalRecord.alias.push(matcher);
                if ((true)) {
                    checkSameParams(originalRecord, matcher);
                }
            }
            else {
                // otherwise, the first record is the original and others are aliases
                originalMatcher = originalMatcher || matcher;
                if (originalMatcher !== matcher)
                    originalMatcher.alias.push(matcher);
                // remove the route if named and only for the top record (avoid in nested calls)
                // this works because the original record is the first one
                if (isRootAdd && record.name && !isAliasRecord(matcher))
                    removeRoute(record.name);
            }
            if ('children' in mainNormalizedRecord) {
                const children = mainNormalizedRecord.children;
                for (let i = 0; i < children.length; i++) {
                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                }
            }
            // if there was no original record, then the first one was not an alias and all
            // other alias (if any) need to reference this record when adding children
            originalRecord = originalRecord || matcher;
            // TODO: add normalized records for more flexibility
            // if (parent && isAliasRecord(originalRecord)) {
            //   parent.children.push(originalRecord)
            // }
            insertMatcher(matcher);
        }
        return originalMatcher
            ? () => {
                // since other matchers are aliases, they should be removed by the original matcher
                removeRoute(originalMatcher);
            }
            : noop;
    }
    function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
            const matcher = matcherMap.get(matcherRef);
            if (matcher) {
                matcherMap.delete(matcherRef);
                matchers.splice(matchers.indexOf(matcher), 1);
                matcher.children.forEach(removeRoute);
                matcher.alias.forEach(removeRoute);
            }
        }
        else {
            const index = matchers.indexOf(matcherRef);
            if (index > -1) {
                matchers.splice(index, 1);
                if (matcherRef.record.name)
                    matcherMap.delete(matcherRef.record.name);
                matcherRef.children.forEach(removeRoute);
                matcherRef.alias.forEach(removeRoute);
            }
        }
    }
    function getRoutes() {
        return matchers;
    }
    function insertMatcher(matcher) {
        let i = 0;
        while (i < matchers.length &&
            comparePathParserScore(matcher, matchers[i]) >= 0 &&
            // Adding children with empty path should still appear before the parent
            // https://github.com/vuejs/router/issues/1124
            (matcher.record.path !== matchers[i].record.path ||
                !isRecordChildOf(matcher, matchers[i])))
            i++;
        matchers.splice(i, 0, matcher);
        // only add the original record to the name map
        if (matcher.record.name && !isAliasRecord(matcher))
            matcherMap.set(matcher.record.name, matcher);
    }
    function resolve(location, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ('name' in location && location.name) {
            matcher = matcherMap.get(location.name);
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                });
            name = matcher.record.name;
            params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(currentLocation.params, 
            // only keep params that exist in the resolved location
            // TODO: only keep optional params coming from a parent record
            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);
            // throws if cannot be stringified
            path = matcher.stringify(params);
        }
        else if ('path' in location) {
            // no need to resolve the path with the matcher as it was provided
            // this also allows the user to control the encoding
            path = location.path;
            if (( true) && !path.startsWith('/')) {
                warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);
            }
            matcher = matchers.find(m => m.re.test(path));
            // matcher should have a value after the loop
            if (matcher) {
                // TODO: dev warning of unused params if provided
                // we know the matcher works because we tested the regexp
                params = matcher.parse(path);
                name = matcher.record.name;
            }
            // location is a relative path
        }
        else {
            // match by name or path of current route
            matcher = currentLocation.name
                ? matcherMap.get(currentLocation.name)
                : matchers.find(m => m.re.test(currentLocation.path));
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                    currentLocation,
                });
            name = matcher.record.name;
            // since we are navigating to the same location, we don't need to pick the
            // params like when `name` is provided
            params = assign({}, currentLocation.params, location.params);
            path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
            // reversed order so parents are at the beginning
            matched.unshift(parentMatcher.record);
            parentMatcher = parentMatcher.parent;
        }
        return {
            name,
            path,
            params,
            matched,
            meta: mergeMetaFields(matched),
        };
    }
    // add initial routes
    routes.forEach(route => addRoute(route));
    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
        if (key in params)
            newParams[key] = params[key];
    }
    return newParams;
}
/**
 * Normalizes a RouteRecordRaw. Creates a copy
 *
 * @param record
 * @returns the normalized version
 */
function normalizeRouteRecord(record) {
    return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: undefined,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: 'components' in record
            ? record.components || {}
            : { default: record.component },
    };
}
/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */
function normalizeRecordProps(record) {
    const propsObject = {};
    // props does not exist on redirect records but we can set false directly
    const props = record.props || false;
    if ('component' in record) {
        propsObject.default = props;
    }
    else {
        // NOTE: we could also allow a function to be applied to every component.
        // Would need user feedback for use cases
        for (const name in record.components)
            propsObject[name] = typeof props === 'boolean' ? props : props[name];
    }
    return propsObject;
}
/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */
function isAliasRecord(record) {
    while (record) {
        if (record.record.aliasOf)
            return true;
        record = record.parent;
    }
    return false;
}
/**
 * Merge meta fields of an array of records
 *
 * @param matched - array of matched records
 */
function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
    const options = {};
    for (const key in defaults) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
    }
    return options;
}
function isSameParam(a, b) {
    return (a.name === b.name &&
        a.optional === b.optional &&
        a.repeatable === b.repeatable);
}
/**
 * Check if a path and its alias have the same required params
 *
 * @param a - original record
 * @param b - alias record
 */
function checkSameParams(a, b) {
    for (const key of a.keys) {
        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
    for (const key of b.keys) {
        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
}
function checkMissingParamsInAbsolutePath(record, parent) {
    for (const key of parent.keys) {
        if (!record.keys.find(isSameParam.bind(null, key)))
            return warn(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
    }
}
function isRecordChildOf(record, parent) {
    return parent.children.some(child => child === record || isRecordChildOf(record, child));
}

/**
 * Encoding Rules â£ = Space Path: â£ " < > # ? { } Query: â£ " < > # & = Hash: â£ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */
// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
const HASH_RE = /#/g; // %23
const AMPERSAND_RE = /&/g; // %26
const SLASH_RE = /\//g; // %2F
const EQUAL_RE = /=/g; // %3D
const IM_RE = /\?/g; // %3F
const PLUS_RE = /\+/g; // %2B
/**
 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
 * seems to be less flexible than not doing so and I can't find out the legacy
 * systems requiring this for regular requests like text/html. In the standard,
 * the encoding of the plus character is only mentioned for
 * application/x-www-form-urlencoded
 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
 * leave the plus character as is in queries. To be more flexible, we allow the
 * plus character on the query but it can also be manually encoded by the user.
 *
 * Resources:
 * - https://url.spec.whatwg.org/#urlencoded-parsing
 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
 */
const ENC_BRACKET_OPEN_RE = /%5B/g; // [
const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]
const ENC_CARET_RE = /%5E/g; // ^
const ENC_BACKTICK_RE = /%60/g; // `
const ENC_CURLY_OPEN_RE = /%7B/g; // {
const ENC_PIPE_RE = /%7C/g; // |
const ENC_CURLY_CLOSE_RE = /%7D/g; // }
const ENC_SPACE_RE = /%20/g; // }
/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */
function commonEncode(text) {
    return encodeURI('' + text)
        .replace(ENC_PIPE_RE, '|')
        .replace(ENC_BRACKET_OPEN_RE, '[')
        .replace(ENC_BRACKET_CLOSE_RE, ']');
}
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeHash(text) {
    return commonEncode(text)
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^');
}
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeQueryValue(text) {
    return (commonEncode(text)
        // Encode the space as +, encode the + to differentiate it from the space
        .replace(PLUS_RE, '%2B')
        .replace(ENC_SPACE_RE, '+')
        .replace(HASH_RE, '%23')
        .replace(AMPERSAND_RE, '%26')
        .replace(ENC_BACKTICK_RE, '`')
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^'));
}
/**
 * Like `encodeQueryValue` but also encodes the `=` character.
 *
 * @param text - string to encode
 */
function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
}
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
 * string instead.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeParam(text) {
    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');
}
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */
function decode(text) {
    try {
        return decodeURIComponent('' + text);
    }
    catch (err) {
        ( true) && warn(`Error decoding "${text}". Using original value`);
    }
    return '' + text;
}

/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */
function parseQuery(search) {
    const query = {};
    // avoid creating an object with an empty key and empty value
    // because of split('&')
    if (search === '' || search === '?')
        return query;
    const hasLeadingIM = search[0] === '?';
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
    for (let i = 0; i < searchParams.length; ++i) {
        // pre decode the + into space
        const searchParam = searchParams[i].replace(PLUS_RE, ' ');
        // allow the = character
        const eqPos = searchParam.indexOf('=');
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
            // an extra variable for ts types
            let currentValue = query[key];
            if (!Array.isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
            }
            currentValue.push(value);
        }
        else {
            query[key] = value;
        }
    }
    return query;
}
/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */
function stringifyQuery(query) {
    let search = '';
    for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
            // only null adds the value
            if (value !== undefined) {
                search += (search.length ? '&' : '') + key;
            }
            continue;
        }
        // keep null values
        const values = Array.isArray(value)
            ? value.map(v => v && encodeQueryValue(v))
            : [value && encodeQueryValue(value)];
        values.forEach(value => {
            // skip undefined values in arrays as if they were not present
            // smaller code than using filter
            if (value !== undefined) {
                // only append & with non-empty search
                search += (search.length ? '&' : '') + key;
                if (value != null)
                    search += '=' + value;
            }
        });
    }
    return search;
}
/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */
function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
        const value = query[key];
        if (value !== undefined) {
            normalizedQuery[key] = Array.isArray(value)
                ? value.map(v => (v == null ? null : '' + v))
                : value == null
                    ? value
                    : '' + value;
        }
    }
    return normalizedQuery;
}

/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */
function useCallbacks() {
    let handlers = [];
    function add(handler) {
        handlers.push(handler);
        return () => {
            const i = handlers.indexOf(handler);
            if (i > -1)
                handlers.splice(i, 1);
        };
    }
    function reset() {
        handlers = [];
    }
    return {
        add,
        list: () => handlers,
        reset,
    };
}

function registerGuard(record, name, guard) {
    const removeFromList = () => {
        record[name].delete(guard);
    };
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onActivated)(() => {
        record[name].add(guard);
    });
    record[name].add(guard);
}
/**
 * Add a navigation guard that triggers whenever the component for the current
 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
 * used in any component. The guard is removed when the component is unmounted.
 *
 * @param leaveGuard - {@link NavigationGuard}
 */
function onBeforeRouteLeave(leaveGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');
        return;
    }
    registerGuard(activeRecord, 'leaveGuards', leaveGuard);
}
/**
 * Add a navigation guard that triggers whenever the current location is about
 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
 * component. The guard is removed when the component is unmounted.
 *
 * @param updateGuard - {@link NavigationGuard}
 */
function onBeforeRouteUpdate(updateGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');
        return;
    }
    registerGuard(activeRecord, 'updateGuards', updateGuard);
}
function guardToPromiseFn(guard, to, from, record, name) {
    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
    const enterCallbackArray = record &&
        // name is defined if record is because of the function overload
        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve, reject) => {
        const next = (valid) => {
            if (valid === false)
                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {
                    from,
                    to,
                }));
            else if (valid instanceof Error) {
                reject(valid);
            }
            else if (isRouteLocation(valid)) {
                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {
                    from: to,
                    to: valid,
                }));
            }
            else {
                if (enterCallbackArray &&
                    // since enterCallbackArray is truthy, both record and name also are
                    record.enterCallbacks[name] === enterCallbackArray &&
                    typeof valid === 'function')
                    enterCallbackArray.push(valid);
                resolve();
            }
        };
        // wrapping with Promise.resolve allows it to work with both async and sync guards
        const guardReturn = guard.call(record && record.instances[name], to, from, ( true) ? canOnlyBeCalledOnce(next, to, from) : 0);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
            guardCall = guardCall.then(next);
        if (( true) && guard.length > 2) {
            const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ''}:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof guardReturn === 'object' && 'then' in guardReturn) {
                guardCall = guardCall.then(resolvedValue => {
                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                    if (!next._called) {
                        warn(message);
                        return Promise.reject(new Error('Invalid navigation guard'));
                    }
                    return resolvedValue;
                });
                // TODO: test me!
            }
            else if (guardReturn !== undefined) {
                // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                if (!next._called) {
                    warn(message);
                    reject(new Error('Invalid navigation guard'));
                    return;
                }
            }
        }
        guardCall.catch(err => reject(err));
    });
}
function canOnlyBeCalledOnce(next, to, from) {
    let called = 0;
    return function () {
        if (called++ === 1)
            warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
        // @ts-expect-error: we put it in the original one because it's easier to check
        next._called = true;
        if (called === 1)
            next.apply(null, arguments);
    };
}
function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
        for (const name in record.components) {
            let rawComponent = record.components[name];
            if ((true)) {
                if (!rawComponent ||
                    (typeof rawComponent !== 'object' &&
                        typeof rawComponent !== 'function')) {
                    warn(`Component "${name}" in record with path "${record.path}" is not` +
                        ` a valid component. Received "${String(rawComponent)}".`);
                    // throw to ensure we stop here but warn to ensure the message isn't
                    // missed by the user
                    throw new Error('Invalid route component');
                }
                else if ('then' in rawComponent) {
                    // warn if user wrote import('/component.vue') instead of () =>
                    // import('./component.vue')
                    warn(`Component "${name}" in record with path "${record.path}" is a ` +
                        `Promise instead of a function that returns a Promise. Did you ` +
                        `write "import('./MyPage.vue')" instead of ` +
                        `"() => import('./MyPage.vue')" ? This will break in ` +
                        `production if not fixed.`);
                    const promise = rawComponent;
                    rawComponent = () => promise;
                }
                else if (rawComponent.__asyncLoader &&
                    // warn only once per component
                    !rawComponent.__warnedDefineAsync) {
                    rawComponent.__warnedDefineAsync = true;
                    warn(`Component "${name}" in record with path "${record.path}" is defined ` +
                        `using "defineAsyncComponent()". ` +
                        `Write "() => import('./MyPage.vue')" instead of ` +
                        `"defineAsyncComponent(() => import('./MyPage.vue'))".`);
                }
            }
            // skip update and leave guards if the route component is not mounted
            if (guardType !== 'beforeRouteEnter' && !record.instances[name])
                continue;
            if (isRouteComponent(rawComponent)) {
                // __vccOpts is added by vue-class-component and contain the regular options
                const options = rawComponent.__vccOpts || rawComponent;
                const guard = options[guardType];
                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
            }
            else {
                // start requesting the chunk already
                let componentPromise = rawComponent();
                if (( true) && !('catch' in componentPromise)) {
                    warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
                    componentPromise = Promise.resolve(componentPromise);
                }
                guards.push(() => componentPromise.then(resolved => {
                    if (!resolved)
                        return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
                    const resolvedComponent = isESModule(resolved)
                        ? resolved.default
                        : resolved;
                    // replace the function with the resolved component
                    record.components[name] = resolvedComponent;
                    // __vccOpts is added by vue-class-component and contain the regular options
                    const options = resolvedComponent.__vccOpts || resolvedComponent;
                    const guard = options[guardType];
                    return guard && guardToPromiseFn(guard, to, from, record, name)();
                }));
            }
        }
    }
    return guards;
}
/**
 * Allows differentiating lazy components from functional components and vue-class-component
 *
 * @param component
 */
function isRouteComponent(component) {
    return (typeof component === 'object' ||
        'displayName' in component ||
        'props' in component ||
        '__vccOpts' in component);
}

// TODO: we could allow currentRoute as a prop to expose `isActive` and
// `isExactActive` behavior should go through an RFC
function useLink(props) {
    const router = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
    const route = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => router.resolve((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)));
    const activeRecordIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
            return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
            return index;
        // possible parent record
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
        // we are dealing with nested routes
        length > 1 &&
            // if the parent and matched route have the same path, this link is
            // referring to the empty child. Or we currently are on a different
            // child of the same parent
            getOriginalPath(routeMatched) === parentRecordPath &&
            // avoid comparing the child with its parent
            currentMatched[currentMatched.length - 1].path !== parentRecordPath
            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))
            : index);
    });
    const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        includesParams(currentRoute.params, route.value.params));
    const isExactActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        activeRecordIndex.value === currentRoute.matched.length - 1 &&
        isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
        if (guardEvent(e)) {
            return router[(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.replace) ? 'replace' : 'push']((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)
            // avoid uncaught errors are they are logged anyway
            ).catch(noop);
        }
        return Promise.resolve();
    }
    // devtools only
    if (( true) && isBrowser) {
        const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (instance) {
            const linkContextDevtools = {
                route: route.value,
                isActive: isActive.value,
                isExactActive: isExactActive.value,
            };
            // @ts-expect-error: this is internal
            instance.__vrl_devtools = instance.__vrl_devtools || [];
            // @ts-expect-error: this is internal
            instance.__vrl_devtools.push(linkContextDevtools);
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {
                linkContextDevtools.route = route.value;
                linkContextDevtools.isActive = isActive.value;
                linkContextDevtools.isExactActive = isExactActive.value;
            }, { flush: 'post' });
        }
    }
    return {
        route,
        href: (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => route.value.href),
        isActive,
        isExactActive,
        navigate,
    };
}
const RouterLinkImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterLink',
    props: {
        to: {
            type: [String, Object],
            required: true,
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: 'page',
        },
    },
    useLink,
    setup(props, { slots }) {
        const link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(useLink(props));
        const { options } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
        const elClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
            // [getLinkClass(
            //   props.inactiveClass,
            //   options.linkInactiveClass,
            //   'router-link-inactive'
            // )]: !link.isExactActive,
            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,
        }));
        return () => {
            const children = slots.default && slots.default(link);
            return props.custom
                ? children
                : (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('a', {
                    'aria-current': link.isExactActive
                        ? props.ariaCurrentValue
                        : null,
                    href: link.href,
                    // this would override user added attrs but Vue will still add
                    // the listener so we end up triggering both
                    onClick: link.navigate,
                    class: elClass.value,
                }, children);
        };
    },
});
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to render a link that triggers a navigation on click.
 */
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
    // don't redirect with control keys
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
    // don't redirect when preventDefault called
    if (e.defaultPrevented)
        return;
    // don't redirect on right click
    if (e.button !== undefined && e.button !== 0)
        return;
    // don't redirect if `target="_blank"`
    // @ts-expect-error getAttribute does exist
    if (e.currentTarget && e.currentTarget.getAttribute) {
        // @ts-expect-error getAttribute exists
        const target = e.currentTarget.getAttribute('target');
        if (/\b_blank\b/i.test(target))
            return;
    }
    // this may be a Weex event which doesn't have this method
    if (e.preventDefault)
        e.preventDefault();
    return true;
}
function includesParams(outer, inner) {
    for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === 'string') {
            if (innerValue !== outerValue)
                return false;
        }
        else {
            if (!Array.isArray(outerValue) ||
                outerValue.length !== innerValue.length ||
                innerValue.some((value, i) => value !== outerValue[i]))
                return false;
        }
    }
    return true;
}
/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */
function getOriginalPath(record) {
    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';
}
/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null
    ? propClass
    : globalClass != null
        ? globalClass
        : defaultClass;

const RouterViewImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterView',
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
        name: {
            type: String,
            default: 'default',
        },
        route: Object,
    },
    // Better compat for @vue/compat users
    // https://github.com/vuejs/router/issues/1315
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
        ( true) && warnDeprecatedUsage();
        const injectedRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerViewLocationKey);
        const routeToDisplay = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.route || injectedRoute.value);
        const depth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(viewDepthKey, 0);
        const matchedRouteRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => routeToDisplay.value.matched[depth]);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(viewDepthKey, depth + 1);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(matchedRouteKey, matchedRouteRef);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(routerViewLocationKey, routeToDisplay);
        const viewRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
        // watch at the same time the component instance, the route record we are
        // rendering, and the name
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
            // copy reused instances
            if (to) {
                // this will update the instance for new instances as well as reused
                // instances when navigating to a new route
                to.instances[name] = instance;
                // the component instance is reused for a different route or name so
                // we copy any saved update or leave guards. With async setup, the
                // mounting component will mount before the matchedRoute changes,
                // making instance === oldInstance, so we check if guards have been
                // added before. This works because we remove guards when
                // unmounting/deactivating components
                if (from && from !== to && instance && instance === oldInstance) {
                    if (!to.leaveGuards.size) {
                        to.leaveGuards = from.leaveGuards;
                    }
                    if (!to.updateGuards.size) {
                        to.updateGuards = from.updateGuards;
                    }
                }
            }
            // trigger beforeRouteEnter next callbacks
            if (instance &&
                to &&
                // if there is no instance but to and from are the same this might be
                // the first visit
                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
            }
        }, { flush: 'post' });
        return () => {
            const route = routeToDisplay.value;
            const matchedRoute = matchedRouteRef.value;
            const ViewComponent = matchedRoute && matchedRoute.components[props.name];
            // we need the value at the time we render because when we unmount, we
            // navigated to a different location so the value is different
            const currentName = props.name;
            if (!ViewComponent) {
                return normalizeSlot(slots.default, { Component: ViewComponent, route });
            }
            // props from route configuration
            const routePropsOption = matchedRoute.props[props.name];
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? route.params
                    : typeof routePropsOption === 'function'
                        ? routePropsOption(route)
                        : routePropsOption
                : null;
            const onVnodeUnmounted = vnode => {
                // remove the instance reference to prevent leak
                if (vnode.component.isUnmounted) {
                    matchedRoute.instances[currentName] = null;
                }
            };
            const component = (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(ViewComponent, assign({}, routeProps, attrs, {
                onVnodeUnmounted,
                ref: viewRef,
            }));
            if (( true) &&
                isBrowser &&
                component.ref) {
                // TODO: can display if it's an alias, its props
                const info = {
                    depth,
                    name: matchedRoute.name,
                    path: matchedRoute.path,
                    meta: matchedRoute.meta,
                };
                const internalInstances = Array.isArray(component.ref)
                    ? component.ref.map(r => r.i)
                    : [component.ref.i];
                internalInstances.forEach(instance => {
                    // @ts-expect-error
                    instance.__vrv_devtools = info;
                });
            }
            return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) ||
                component);
        };
    },
});
function normalizeSlot(slot, data) {
    if (!slot)
        return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to display the current route the user is at.
 */
const RouterView = RouterViewImpl;
// warn against deprecated usage with <transition> & <keep-alive>
// due to functional component being no longer eager in Vue 3
function warnDeprecatedUsage() {
    const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const parentName = instance.parent && instance.parent.type.name;
    if (parentName &&
        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {
        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` +
            `Use slot props instead:\n\n` +
            `<router-view v-slot="{ Component }">\n` +
            `  <${comp}>\n` +
            `    <component :is="Component" />\n` +
            `  </${comp}>\n` +
            `</router-view>`);
    }
}

function formatRouteLocation(routeLocation, tooltip) {
    const copy = assign({}, routeLocation, {
        // remove variables that can contain vue instances
        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),
    });
    return {
        _custom: {
            type: null,
            readOnly: true,
            display: routeLocation.fullPath,
            tooltip,
            value: copy,
        },
    };
}
function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
// to support multiple router instances
let routerId = 0;
function addDevtools(app, router, matcher) {
    // Take over router.beforeEach and afterEach
    // make sure we are not registering the devtool twice
    if (router.__hasDevtools)
        return;
    router.__hasDevtools = true;
    // increment to support multiple router instances
    const id = routerId++;
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)({
        id: 'org.vuejs.router' + (id ? '.' + id : ''),
        label: 'Vue Router',
        packageName: 'vue-router',
        homepage: 'https://router.vuejs.org',
        logo: 'https://router.vuejs.org/logo.png',
        componentStateTypes: ['Routing'],
        app,
    }, api => {
        // display state added by the router
        api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
                payload.instanceData.state.push({
                    type: 'Routing',
                    key: '$route',
                    editable: false,
                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),
                });
            }
        });
        // mark router-link as active and display tags on router views
        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
            if (componentInstance.__vrv_devtools) {
                const info = componentInstance.__vrv_devtools;
                node.tags.push({
                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,
                    textColor: 0,
                    tooltip: 'This component is rendered by &lt;router-view&gt;',
                    backgroundColor: PINK_500,
                });
            }
            // if multiple useLink are used
            if (Array.isArray(componentInstance.__vrl_devtools)) {
                componentInstance.__devtoolsApi = api;
                componentInstance.__vrl_devtools.forEach(devtoolsData => {
                    let backgroundColor = ORANGE_400;
                    let tooltip = '';
                    if (devtoolsData.isExactActive) {
                        backgroundColor = LIME_500;
                        tooltip = 'This is exactly active';
                    }
                    else if (devtoolsData.isActive) {
                        backgroundColor = BLUE_600;
                        tooltip = 'This link is active';
                    }
                    node.tags.push({
                        label: devtoolsData.route.path,
                        textColor: 0,
                        tooltip,
                        backgroundColor,
                    });
                });
            }
        });
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(router.currentRoute, () => {
            // refresh active state
            refreshRoutesView();
            api.notifyComponentUpdate();
            api.sendInspectorTree(routerInspectorId);
            api.sendInspectorState(routerInspectorId);
        });
        const navigationsLayerId = 'router:navigations:' + id;
        api.addTimelineLayer({
            id: navigationsLayerId,
            label: `Router${id ? ' ' + id : ''} Navigations`,
            color: 0x40a8c4,
        });
        // const errorsLayerId = 'router:errors'
        // api.addTimelineLayer({
        //   id: errorsLayerId,
        //   label: 'Router Errors',
        //   color: 0xea5455,
        // })
        router.onError((error, to) => {
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'Error during Navigation',
                    subtitle: to.fullPath,
                    logType: 'error',
                    time: api.now(),
                    data: { error },
                    groupId: to.meta.__navigationId,
                },
            });
        });
        // attached to `meta` and used to group events
        let navigationId = 0;
        router.beforeEach((to, from) => {
            const data = {
                guard: formatDisplay('beforeEach'),
                from: formatRouteLocation(from, 'Current Location during this navigation'),
                to: formatRouteLocation(to, 'Target location'),
            };
            // Used to group navigations together, hide from devtools
            Object.defineProperty(to.meta, '__navigationId', {
                value: navigationId++,
            });
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    time: api.now(),
                    title: 'Start of navigation',
                    subtitle: to.fullPath,
                    data,
                    groupId: to.meta.__navigationId,
                },
            });
        });
        router.afterEach((to, from, failure) => {
            const data = {
                guard: formatDisplay('afterEach'),
            };
            if (failure) {
                data.failure = {
                    _custom: {
                        type: Error,
                        readOnly: true,
                        display: failure ? failure.message : '',
                        tooltip: 'Navigation Failure',
                        value: failure,
                    },
                };
                data.status = formatDisplay('â');
            }
            else {
                data.status = formatDisplay('â');
            }
            // we set here to have the right order
            data.from = formatRouteLocation(from, 'Current Location during this navigation');
            data.to = formatRouteLocation(to, 'Target location');
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'End of navigation',
                    subtitle: to.fullPath,
                    time: api.now(),
                    data,
                    logType: failure ? 'warning' : 'default',
                    groupId: to.meta.__navigationId,
                },
            });
        });
        /**
         * Inspector of Existing routes
         */
        const routerInspectorId = 'router-inspector:' + id;
        api.addInspector({
            id: routerInspectorId,
            label: 'Routes' + (id ? ' ' + id : ''),
            icon: 'book',
            treeFilterPlaceholder: 'Search routes',
        });
        function refreshRoutesView() {
            // the routes view isn't active
            if (!activeRoutesPayload)
                return;
            const payload = activeRoutesPayload;
            // children routes will appear as nested
            let routes = matcher.getRoutes().filter(route => !route.parent);
            // reset match state to false
            routes.forEach(resetMatchStateOnRouteRecord);
            // apply a match state if there is a payload
            if (payload.filter) {
                routes = routes.filter(route => 
                // save matches state based on the payload
                isRouteMatching(route, payload.filter.toLowerCase()));
            }
            // mark active routes
            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));
            payload.rootNodes = routes.map(formatRouteRecordForInspector);
        }
        let activeRoutesPayload;
        api.on.getInspectorTree(payload => {
            activeRoutesPayload = payload;
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                refreshRoutesView();
            }
        });
        /**
         * Display information about the currently selected route record
         */
        api.on.getInspectorState(payload => {
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                const routes = matcher.getRoutes();
                const route = routes.find(route => route.record.__vd_id === payload.nodeId);
                if (route) {
                    payload.state = {
                        options: formatRouteRecordMatcherForStateInspector(route),
                    };
                }
            }
        });
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
    });
}
function modifierForKey(key) {
    if (key.optional) {
        return key.repeatable ? '*' : '?';
    }
    else {
        return key.repeatable ? '+' : '';
    }
}
function formatRouteRecordMatcherForStateInspector(route) {
    const { record } = route;
    const fields = [
        { editable: false, key: 'path', value: record.path },
    ];
    if (record.name != null) {
        fields.push({
            editable: false,
            key: 'name',
            value: record.name,
        });
    }
    fields.push({ editable: false, key: 'regexp', value: route.re });
    if (route.keys.length) {
        fields.push({
            editable: false,
            key: 'keys',
            value: {
                _custom: {
                    type: null,
                    readOnly: true,
                    display: route.keys
                        .map(key => `${key.name}${modifierForKey(key)}`)
                        .join(' '),
                    tooltip: 'Param keys',
                    value: route.keys,
                },
            },
        });
    }
    if (record.redirect != null) {
        fields.push({
            editable: false,
            key: 'redirect',
            value: record.redirect,
        });
    }
    if (route.alias.length) {
        fields.push({
            editable: false,
            key: 'aliases',
            value: route.alias.map(alias => alias.record.path),
        });
    }
    fields.push({
        key: 'score',
        editable: false,
        value: {
            _custom: {
                type: null,
                readOnly: true,
                display: route.score.map(score => score.join(', ')).join(' | '),
                tooltip: 'Score used to sort routes',
                value: route.score,
            },
        },
    });
    return fields;
}
/**
 * Extracted from tailwind palette
 */
const PINK_500 = 0xec4899;
const BLUE_600 = 0x2563eb;
const LIME_500 = 0x84cc16;
const CYAN_400 = 0x22d3ee;
const ORANGE_400 = 0xfb923c;
// const GRAY_100 = 0xf4f4f5
const DARK = 0x666666;
function formatRouteRecordForInspector(route) {
    const tags = [];
    const { record } = route;
    if (record.name != null) {
        tags.push({
            label: String(record.name),
            textColor: 0,
            backgroundColor: CYAN_400,
        });
    }
    if (record.aliasOf) {
        tags.push({
            label: 'alias',
            textColor: 0,
            backgroundColor: ORANGE_400,
        });
    }
    if (route.__vd_match) {
        tags.push({
            label: 'matches',
            textColor: 0,
            backgroundColor: PINK_500,
        });
    }
    if (route.__vd_exactActive) {
        tags.push({
            label: 'exact',
            textColor: 0,
            backgroundColor: LIME_500,
        });
    }
    if (route.__vd_active) {
        tags.push({
            label: 'active',
            textColor: 0,
            backgroundColor: BLUE_600,
        });
    }
    if (record.redirect) {
        tags.push({
            label: 'redirect: ' +
                (typeof record.redirect === 'string' ? record.redirect : 'Object'),
            textColor: 0xffffff,
            backgroundColor: DARK,
        });
    }
    // add an id to be able to select it. Using the `path` is not possible because
    // empty path children would collide with their parents
    let id = record.__vd_id;
    if (id == null) {
        id = String(routeRecordId++);
        record.__vd_id = id;
    }
    return {
        id,
        label: record.path,
        tags,
        children: route.children.map(formatRouteRecordForInspector),
    };
}
//  incremental id for route records and inspector state
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
    // no route will be active if matched is empty
    // reset the matching state
    const isExactActive = currentRoute.matched.length &&
        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
    route.__vd_exactActive = route.__vd_active = isExactActive;
    if (!isExactActive) {
        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));
    }
    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
    route.__vd_match = false;
    route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter) {
    const found = String(route.re).match(EXTRACT_REGEXP_RE);
    route.__vd_match = false;
    if (!found || found.length < 3) {
        return false;
    }
    // use a regexp without $ at the end to match nested routes better
    const nonEndingRE = new RegExp(found[1].replace(/\$$/, ''), found[2]);
    if (nonEndingRE.test(filter)) {
        // mark children as matches
        route.children.forEach(child => isRouteMatching(child, filter));
        // exception case: `/`
        if (route.record.path !== '/' || filter === '/') {
            route.__vd_match = route.re.test(filter);
            return true;
        }
        // hide the / route
        return false;
    }
    const path = route.record.path.toLowerCase();
    const decodedPath = decode(path);
    // also allow partial matching on the path
    if (!filter.startsWith('/') &&
        (decodedPath.includes(filter) || path.includes(filter)))
        return true;
    if (decodedPath.startsWith(filter) || path.startsWith(filter))
        return true;
    if (route.record.name && String(route.record.name).includes(filter))
        return true;
    return route.children.some(child => isRouteMatching(child, filter));
}
function omit(obj, keys) {
    const ret = {};
    for (const key in obj) {
        if (!keys.includes(key)) {
            // @ts-expect-error
            ret[key] = obj[key];
        }
    }
    return ret;
}

/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */
function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    if (( true) && !routerHistory)
        throw new Error('Provide the "history" option when calling "createRouter()":' +
            ' https://next.router.vuejs.org/api/#history.');
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    // leave the scrollRestoration if no scrollBehavior is provided
    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = 
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
            parent = matcher.getRecordMatcher(parentOrRoute);
            record = route;
        }
        else {
            record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
            matcher.removeRoute(recordMatcher);
        }
        else if ((true)) {
            warn(`Cannot remove non-existent route "${String(name)}"`);
        }
    }
    function getRoutes() {
        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
    }
    function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
    }
    function resolve(rawLocation, currentLocation) {
        // const objectLocation = routerLocationAsObject(rawLocation)
        // we create a copy to modify it later
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === 'string') {
            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);
            const href = routerHistory.createHref(locationNormalized.fullPath);
            if ((true)) {
                if (href.startsWith('//'))
                    warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
                else if (!matchedRoute.matched.length) {
                    warn(`No match found for location with path "${rawLocation}"`);
                }
            }
            // locationNormalized is always a new object
            return assign(locationNormalized, matchedRoute, {
                params: decodeParams(matchedRoute.params),
                hash: decode(locationNormalized.hash),
                redirectedFrom: undefined,
                href,
            });
        }
        let matcherLocation;
        // path could be relative in object as well
        if ('path' in rawLocation) {
            if (( true) &&
                'params' in rawLocation &&
                !('name' in rawLocation) &&
                // @ts-expect-error: the type is never
                Object.keys(rawLocation.params).length) {
                warn(`Path "${
                // @ts-expect-error: the type is never
                rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
            }
            matcherLocation = assign({}, rawLocation, {
                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,
            });
        }
        else {
            // remove any nullish param
            const targetParams = assign({}, rawLocation.params);
            for (const key in targetParams) {
                if (targetParams[key] == null) {
                    delete targetParams[key];
                }
            }
            // pass encoded values to the matcher so it can produce encoded path and fullPath
            matcherLocation = assign({}, rawLocation, {
                params: encodeParams(rawLocation.params),
            });
            // current location params are decoded, we need to encode them in case the
            // matcher merges the params
            currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || '';
        if (( true) && hash && !hash.startsWith('#')) {
            warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
        }
        // decoding them) the matcher might have merged current location params so
        // we need to run the decoding again
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
            hash: encodeHash(hash),
            path: matchedRoute.path,
        }));
        const href = routerHistory.createHref(fullPath);
        if ((true)) {
            if (href.startsWith('//')) {
                warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
            }
            else if (!matchedRoute.matched.length) {
                warn(`No match found for location with path "${'path' in rawLocation ? rawLocation.path : rawLocation}"`);
            }
        }
        return assign({
            fullPath,
            // keep the hash encoded so fullPath is effectively path + encodedQuery +
            // hash
            hash,
            query: 
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery
                ? normalizeQuery(rawLocation.query)
                : (rawLocation.query || {}),
        }, matchedRoute, {
            redirectedFrom: undefined,
            href,
        });
    }
    function locationAsObject(to) {
        return typeof to === 'string'
            ? parseURL(parseQuery$1, to, currentRoute.value.path)
            : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
            return createRouterError(8 /* NAVIGATION_CANCELLED */, {
                from,
                to,
            });
        }
    }
    function push(to) {
        return pushWithRedirect(to);
    }
    function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
            const { redirect } = lastMatched;
            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;
            if (typeof newTargetLocation === 'string') {
                newTargetLocation =
                    newTargetLocation.includes('?') || newTargetLocation.includes('#')
                        ? (newTargetLocation = locationAsObject(newTargetLocation))
                        : // force empty params
                            { path: newTargetLocation };
                // @ts-expect-error: force empty params when a string is passed to let
                // the router parse them again
                newTargetLocation.params = {};
            }
            if (( true) &&
                !('path' in newTargetLocation) &&
                !('name' in newTargetLocation)) {
                warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
                throw new Error('Invalid redirect');
            }
            return assign({
                query: to.query,
                hash: to.hash,
                params: to.params,
            }, newTargetLocation);
        }
    }
    function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = (pendingLocation = resolve(to));
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        // to could be a string where `replace` is a function
        const replace = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
                state: data,
                force,
                replace,
            }), 
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation);
        // if it was a redirect we already called `pushWithRedirect` above
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });
            // trigger scroll to allow scrolling to the same anchor
            handleScroll(from, from, 
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true, 
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false);
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
            .catch((error) => isNavigationFailure(error)
            ? // navigation redirects still mark the router as ready
                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)
                    ? error
                    : markAsReady(error) // also returns the error
            : // reject any unknown error
                triggerError(error, toLocation, from))
            .then((failure) => {
            if (failure) {
                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    if (( true) &&
                        // we are redirecting to the same location we were already at
                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&
                        // and we have done it a couple of times
                        redirectedFrom &&
                        // @ts-expect-error: added only in dev
                        (redirectedFrom._count = redirectedFrom._count
                            ? // @ts-expect-error
                                redirectedFrom._count + 1
                            : 1) > 10) {
                        warn(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
                        return Promise.reject(new Error('Infinite redirect in navigation guard'));
                    }
                    return pushWithRedirect(
                    // keep options
                    assign(locationAsObject(failure.to), {
                        state: data,
                        force,
                        replace,
                    }), 
                    // preserve the original redirectedFrom if any
                    redirectedFrom || toLocation);
                }
            }
            else {
                // if we fail we don't finalize the navigation
                failure = finalizeNavigation(toLocation, from, true, replace, data);
            }
            triggerAfterEach(toLocation, from, failure);
            return failure;
        });
    }
    /**
     * Helper to reject and skip all navigation guards if a new navigation happened
     * @param to
     * @param from
     */
    function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
    }
    // TODO: refactor the whole before guards by internally using router.beforeEach
    function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        // all components here have been resolved once because we are leaving
        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);
        // leavingRecords is already reversed
        for (const record of leavingRecords) {
            record.leaveGuards.forEach(guard => {
                guards.push(guardToPromiseFn(guard, to, from));
            });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        // run the queue of per route beforeRouteLeave guards
        return (runGuardQueue(guards)
            .then(() => {
            // check global guards beforeEach
            guards = [];
            for (const guard of beforeGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            .then(() => {
            // check in components beforeRouteUpdate
            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);
            for (const record of updatingRecords) {
                record.updateGuards.forEach(guard => {
                    guards.push(guardToPromiseFn(guard, to, from));
                });
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check the route beforeEnter
            guards = [];
            for (const record of to.matched) {
                // do not trigger beforeEnter on reused views
                if (record.beforeEnter && !from.matched.includes(record)) {
                    if (Array.isArray(record.beforeEnter)) {
                        for (const beforeEnter of record.beforeEnter)
                            guards.push(guardToPromiseFn(beforeEnter, to, from));
                    }
                    else {
                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                    }
                }
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
            // clear existing enterCallbacks, these are added by extractComponentsGuards
            to.matched.forEach(record => (record.enterCallbacks = {}));
            // check in-component beforeRouteEnter
            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check global guards beforeResolve
            guards = [];
            for (const guard of beforeResolveGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            // catch any navigation canceled
            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)
            ? err
            : Promise.reject(err)));
    }
    function triggerAfterEach(to, from, failure) {
        // navigation is confirmed, call afterGuards
        // TODO: wrap with error handlers
        for (const guard of afterGuards.list())
            guard(to, from, failure);
    }
    /**
     * - Cleans up any navigation guards
     * - Changes the url if necessary
     * - Calls the scrollBehavior
     */
    function finalizeNavigation(toLocation, from, isPush, replace, data) {
        // a more recent navigation took place
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
            return error;
        // only consider as push if it's not the first navigation
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        // change URL only if the user did a push/replace and if it's not the initial navigation because
        // it's just reflecting the url
        if (isPush) {
            // on the initial navigation, we want to reuse the scroll position from
            // history state if it exists
            if (replace || isFirstNavigation)
                routerHistory.replace(toLocation.fullPath, assign({
                    scroll: isFirstNavigation && state && state.scroll,
                }, data));
            else
                routerHistory.push(toLocation.fullPath, data);
        }
        // accept current navigation
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
    }
    let removeHistoryListener;
    // attach listener to history to trigger navigations
    function setupListeners() {
        // avoid setting up listeners twice due to an invalid first navigation
        if (removeHistoryListener)
            return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
            // cannot be a redirect route because it was in history
            const toLocation = resolve(to);
            // due to dynamic routing, and to hash history with manual navigation
            // (manually changing the url or calling history.hash = '#/somewhere'),
            // there could be a redirect record in history
            const shouldRedirect = handleRedirectRecord(toLocation);
            if (shouldRedirect) {
                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
                return;
            }
            pendingLocation = toLocation;
            const from = currentRoute.value;
            // TODO: should be moved to web history?
            if (isBrowser) {
                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
            }
            navigate(toLocation, from)
                .catch((error) => {
                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {
                    return error;
                }
                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    // Here we could call if (info.delta) routerHistory.go(-info.delta,
                    // false) but this is bug prone as we have no way to wait the
                    // navigation to be finished before calling pushWithRedirect. Using
                    // a setTimeout of 16ms seems to work but there is not guarantee for
                    // it to work on every browser. So Instead we do not restore the
                    // history entry and trigger a new navigation as requested by the
                    // navigation guard.
                    // the error is already handled by router.push we just want to avoid
                    // logging the error
                    pushWithRedirect(error.to, toLocation
                    // avoid an uncaught rejection, let push call triggerError
                    )
                        .then(failure => {
                        // manual change in hash history #916 ending up in the URL not
                        // changing but it was changed by the manual url change, so we
                        // need to manually change it ourselves
                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |
                            16 /* NAVIGATION_DUPLICATED */) &&
                            !info.delta &&
                            info.type === NavigationType.pop) {
                            routerHistory.go(-1, false);
                        }
                    })
                        .catch(noop);
                    // avoid the then branch
                    return Promise.reject();
                }
                // do not restore history on unknown direction
                if (info.delta)
                    routerHistory.go(-info.delta, false);
                // unrecognized error, transfer to the global handler
                return triggerError(error, toLocation, from);
            })
                .then((failure) => {
                failure =
                    failure ||
                        finalizeNavigation(
                        // after navigation, all matched components are resolved
                        toLocation, from, false);
                // revert the navigation
                if (failure) {
                    if (info.delta) {
                        routerHistory.go(-info.delta, false);
                    }
                    else if (info.type === NavigationType.pop &&
                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {
                        // manual change in hash history #916
                        // it's like a push but lacks the information of the direction
                        routerHistory.go(-1, false);
                    }
                }
                triggerAfterEach(toLocation, from, failure);
            })
                .catch(noop);
        });
    }
    // Initialization and Errors
    let readyHandlers = useCallbacks();
    let errorHandlers = useCallbacks();
    let ready;
    /**
     * Trigger errorHandlers added via onError and throws the error as well
     *
     * @param error - error to throw
     * @param to - location we were navigating to when the error happened
     * @param from - location we were navigating from when the error happened
     * @returns the error as a rejected promise
     */
    function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorHandlers.list();
        if (list.length) {
            list.forEach(handler => handler(error, to, from));
        }
        else {
            if ((true)) {
                warn('uncaught error during route navigation:');
            }
            console.error(error);
        }
        return Promise.reject(error);
    }
    function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            readyHandlers.add([resolve, reject]);
        });
    }
    function markAsReady(err) {
        if (!ready) {
            // still not ready if an error happened
            ready = !err;
            setupListeners();
            readyHandlers
                .list()
                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));
            readyHandlers.reset();
        }
        return err;
    }
    // Scroll behavior
    function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
            return Promise.resolve();
        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
            ((isFirstNavigation || !isPush) &&
                history.state &&
                history.state.scroll) ||
            null;
        return (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)()
            .then(() => scrollBehavior(to, from, scrollPosition))
            .then(position => position && scrollToPosition(position))
            .catch(err => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = new Set();
    const router = {
        currentRoute,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorHandlers.add,
        isReady,
        install(app) {
            const router = this;
            app.component('RouterLink', RouterLink);
            app.component('RouterView', RouterView);
            app.config.globalProperties.$router = router;
            Object.defineProperty(app.config.globalProperties, '$route', {
                enumerable: true,
                get: () => (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(currentRoute),
            });
            // this initial navigation is only necessary on client, on server it doesn't
            // make sense because it will create an extra unnecessary navigation and could
            // lead to problems
            if (isBrowser &&
                // used for the initial navigation client side to avoid pushing
                // multiple times when the router is used in multiple apps
                !started &&
                currentRoute.value === START_LOCATION_NORMALIZED) {
                // see above
                started = true;
                push(routerHistory.location).catch(err => {
                    if ((true))
                        warn('Unexpected error when starting the router:', err);
                });
            }
            const reactiveRoute = {};
            for (const key in START_LOCATION_NORMALIZED) {
                // @ts-expect-error: the key matches
                reactiveRoute[key] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => currentRoute.value[key]);
            }
            app.provide(routerKey, router);
            app.provide(routeLocationKey, (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(reactiveRoute));
            app.provide(routerViewLocationKey, currentRoute);
            const unmountApp = app.unmount;
            installedApps.add(app);
            app.unmount = function () {
                installedApps.delete(app);
                // the router is not attached to an app anymore
                if (installedApps.size < 1) {
                    // invalidate the current navigation
                    pendingLocation = START_LOCATION_NORMALIZED;
                    removeHistoryListener && removeHistoryListener();
                    removeHistoryListener = null;
                    currentRoute.value = START_LOCATION_NORMALIZED;
                    started = false;
                    ready = false;
                }
                unmountApp();
            };
            if (( true) && isBrowser) {
                addDevtools(app, router, matcher);
            }
        },
    };
    return router;
}
function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
                updatingRecords.push(recordFrom);
            else
                leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
            // the type doesn't matter because we are comparing per reference
            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
                enteringRecords.push(recordTo);
            }
        }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
}

/**
 * Returns the router instance. Equivalent to using `$router` inside
 * templates.
 */
function useRouter() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
}
/**
 * Returns the current route location. Equivalent to using `$route` inside
 * templates.
 */
function useRoute() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
}




/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "compile": () => (/* binding */ compileToFunction),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
    {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
    }
}

// This entry is the "full-build" that includes both the runtime
if ((true)) {
    initDev();
}
const compileCache = Object.create(null);
function compileToFunction(template, options) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)) {
        if (template.nodeType) {
            template = template.innerHTML;
        }
        else {
            ( true) && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(`invalid template option: `, template);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        }
    }
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === '#') {
        const el = document.querySelector(template);
        if (( true) && !el) {
            (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(`Template element not found or is empty: ${template}`);
        }
        // __UNSAFE__
        // Reason: potential execution of JS expressions in in-DOM template.
        // The user must make sure the in-DOM template is trusted. If it's rendered
        // by the server, the template should not contain any user data.
        template = el ? el.innerHTML : ``;
    }
    const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
        hoistStatic: true,
        onError: ( true) ? onError : 0,
        onWarn: ( true) ? e => onError(e, true) : 0
    }, options));
    function onError(err, asWarning = false) {
        const message = asWarning
            ? err.message
            : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(codeFrame ? `${message}\n${codeFrame}` : message);
    }
    // The wildcard import results in a huge object with every export
    // with keys that cannot be mangled, and can be quite heavy size-wise.
    // In the global build we know `Vue` is available globally so we can avoid
    // the wildcard object.
    const render = (new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__));
    render._rc = true;
    return (compileCache[key] = render);
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(compileToFunction);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3ltZm9ueV9zdGltdWx1cy1icmlkZ2VfZGlzdF9pbmRleF9qcy1ub2RlX21vZHVsZXNfYXhpb3NfaW5kZXhfanMtbm9kZV9tLWQ2M2NhZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCLEVBQUUsSUFBSTtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsMkNBQTJDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFD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V0FBVyxTQUFTLHFCQUFxQixJQUFJLFdBQVc7QUFDdkssdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUssR0FBRztBQUN2QjtBQUNBLEtBQUssRUFBRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxREFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixnQ0FBZ0MsSUFBSSxJQUFJLDJEQUEyRCxFQUFFLHVCQUF1QixLQUFLLE9BQU87QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBLGVBQWUsMkNBQUU7QUFDakIsY0FBYywyQ0FBRTtBQUNoQixxQkFBcUIsMkNBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFvQjtBQUNuQztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFNLEdBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQU87QUFDbkIsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0RBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaURBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxLQUFxQztBQUN0QyxzQkFBc0I7QUFDdEIsTUFBTSxDQUFFO0FBQ1IsQ0FBQyxLQUFxQyx3QkFBd0IsQ0FBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Es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QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBUztBQUM5QixpQ0FBaUMsTUFBTTtBQUN2QywwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUM7QUFDeEQ7QUFDQSxVQUFVLENBQUk7QUFDZDtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBa0MsY0FBYyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBcUM7QUFDMUMsSUFBSSwwREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RTtBQUMvRSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFLO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQXFDO0FBQzlEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZDQUFRO0FBQzdDO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFnRTtBQUNqRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQU07QUFDakI7O0FBRWlaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3Y0R2xXO0FBQ3VDO0FBQ3JEO0FBQ1c7QUFDNEI7O0FBRXhFO0FBQ0E7QUFDQSxRQUFRLHFFQUFtQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFxQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDLEtBQUssc0RBQUk7QUFDM0QsbUJBQW1CLDZDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsWUFBWSxzREFBSSw0Q0FBNEMsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxFQUFFLDBEQUFPLFdBQVcsbURBQU07QUFDN0M7QUFDQSxrQkFBa0IsS0FBcUMsY0FBYyxDQUFTO0FBQzlFLGlCQUFpQixLQUFxQyw0QkFBNEIsQ0FBSTtBQUN0RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQSxZQUFZLDhEQUFpQjtBQUM3QixRQUFRLHNEQUFJLGdCQUFnQixRQUFRLElBQUksVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZDQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlFQUF1Qjs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhvdHdpcmVkL3N0aW11bHVzL2Rpc3Qvc3RpbXVsdXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzeW1mb255L3N0aW11bHVzLWJyaWRnZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWNvcmUvZGlzdC9jb21waWxlci1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWRvbS9kaXN0L2NvbXBpbGVyLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vcHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vdGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wtcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5rZXktZm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuU3RpbXVsdXMgMy4wLjFcbkNvcHlyaWdodCDCqSAyMDIxIEJhc2VjYW1wLCBMTENcbiAqL1xuY2xhc3MgRXZlbnRMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuZXZlbnRPcHRpb25zID0gZXZlbnRPcHRpb25zO1xuICAgICAgICB0aGlzLnVub3JkZXJlZEJpbmRpbmdzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMsIHRoaXMuZXZlbnRPcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLCB0aGlzLmV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGJpbmRpbmdDb25uZWN0ZWQoYmluZGluZykge1xuICAgICAgICB0aGlzLnVub3JkZXJlZEJpbmRpbmdzLmFkZChiaW5kaW5nKTtcbiAgICB9XG4gICAgYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkQmluZGluZ3MuZGVsZXRlKGJpbmRpbmcpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBleHRlbmRlZEV2ZW50ID0gZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgdGhpcy5iaW5kaW5ncykge1xuICAgICAgICAgICAgaWYgKGV4dGVuZGVkRXZlbnQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmhhbmRsZUV2ZW50KGV4dGVuZGVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy51bm9yZGVyZWRCaW5kaW5ncykuc29ydCgobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRJbmRleCA9IGxlZnQuaW5kZXgsIHJpZ2h0SW5kZXggPSByaWdodC5pbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0SW5kZXggPCByaWdodEluZGV4ID8gLTEgOiBsZWZ0SW5kZXggPiByaWdodEluZGV4ID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dGVuZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihldmVudCwge1xuICAgICAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChldmVudExpc3RlbmVyID0+IGV2ZW50TGlzdGVuZXIuY29ubmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChldmVudExpc3RlbmVyID0+IGV2ZW50TGlzdGVuZXIuZGlzY29ubmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXZlbnRMaXN0ZW5lck1hcHMudmFsdWVzKCkpXG4gICAgICAgICAgICAucmVkdWNlKChsaXN0ZW5lcnMsIG1hcCkgPT4gbGlzdGVuZXJzLmNvbmNhdChBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSkpLCBbXSk7XG4gICAgfVxuICAgIGJpbmRpbmdDb25uZWN0ZWQoYmluZGluZykge1xuICAgICAgICB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykuYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICB9XG4gICAgYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyRm9yQmluZGluZyhiaW5kaW5nKS5iaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsID0ge30pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5oYW5kbGVFcnJvcihlcnJvciwgYEVycm9yICR7bWVzc2FnZX1gLCBkZXRhaWwpO1xuICAgIH1cbiAgICBmZXRjaEV2ZW50TGlzdGVuZXJGb3JCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMgfSA9IGJpbmRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBmZXRjaEV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmNhY2hlS2V5KGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgbGV0IGV2ZW50TGlzdGVuZXIgPSBldmVudExpc3RlbmVyTWFwLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMuY3JlYXRlRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lck1hcC5zZXQoY2FjaGVLZXksIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyO1xuICAgIH1cbiAgICBjcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucykge1xuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyID0gbmV3IEV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxldCBldmVudExpc3RlbmVyTWFwID0gdGhpcy5ldmVudExpc3RlbmVyTWFwcy5nZXQoZXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoIWV2ZW50TGlzdGVuZXJNYXApIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJNYXAgPSBuZXcgTWFwO1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyTWFwcy5zZXQoZXZlbnRUYXJnZXQsIGV2ZW50TGlzdGVuZXJNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyTWFwO1xuICAgIH1cbiAgICBjYWNoZUtleShldmVudE5hbWUsIGV2ZW50T3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtldmVudE5hbWVdO1xuICAgICAgICBPYmplY3Qua2V5cyhldmVudE9wdGlvbnMpLnNvcnQoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGAke2V2ZW50T3B0aW9uc1trZXldID8gXCJcIiA6IFwiIVwifSR7a2V5fWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCI6XCIpO1xuICAgIH1cbn1cblxuY29uc3QgZGVzY3JpcHRvclBhdHRlcm4gPSAvXigoLis/KShAKHdpbmRvd3xkb2N1bWVudCkpPy0+KT8oLis/KSgjKFteOl0rPykpKDooLispKT8kLztcbmZ1bmN0aW9uIHBhcnNlQWN0aW9uRGVzY3JpcHRvclN0cmluZyhkZXNjcmlwdG9yU3RyaW5nKSB7XG4gICAgY29uc3Qgc291cmNlID0gZGVzY3JpcHRvclN0cmluZy50cmltKCk7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNvdXJjZS5tYXRjaChkZXNjcmlwdG9yUGF0dGVybikgfHwgW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRUYXJnZXQ6IHBhcnNlRXZlbnRUYXJnZXQobWF0Y2hlc1s0XSksXG4gICAgICAgIGV2ZW50TmFtZTogbWF0Y2hlc1syXSxcbiAgICAgICAgZXZlbnRPcHRpb25zOiBtYXRjaGVzWzldID8gcGFyc2VFdmVudE9wdGlvbnMobWF0Y2hlc1s5XSkgOiB7fSxcbiAgICAgICAgaWRlbnRpZmllcjogbWF0Y2hlc1s1XSxcbiAgICAgICAgbWV0aG9kTmFtZTogbWF0Y2hlc1s3XVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0TmFtZSkge1xuICAgIGlmIChldmVudFRhcmdldE5hbWUgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFRhcmdldE5hbWUgPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50T3B0aW9ucyhldmVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXZlbnRPcHRpb25zLnNwbGl0KFwiOlwiKS5yZWR1Y2UoKG9wdGlvbnMsIHRva2VuKSA9PiBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgW3Rva2VuLnJlcGxhY2UoL14hLywgXCJcIildOiAhL14hLy50ZXN0KHRva2VuKSB9KSwge30pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXQgPT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiBcIndpbmRvd1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFRhcmdldCA9PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gXCJkb2N1bWVudFwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FtZWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKD86W18tXSkoW2EtejAtOV0pL2csIChfLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gZGFzaGVyaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhbQS1aXSkvZywgKF8sIGNoYXIpID0+IGAtJHtjaGFyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5mdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXRjaCgvW15cXHNdKy9nKSB8fCBbXTtcbn1cblxuY2xhc3MgQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBpbmRleCwgZGVzY3JpcHRvcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBkZXNjcmlwdG9yLmV2ZW50VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZGVzY3JpcHRvci5ldmVudE5hbWUgfHwgZ2V0RGVmYXVsdEV2ZW50TmFtZUZvckVsZW1lbnQoZWxlbWVudCkgfHwgZXJyb3IoXCJtaXNzaW5nIGV2ZW50IG5hbWVcIik7XG4gICAgICAgIHRoaXMuZXZlbnRPcHRpb25zID0gZGVzY3JpcHRvci5ldmVudE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGRlc2NyaXB0b3IuaWRlbnRpZmllciB8fCBlcnJvcihcIm1pc3NpbmcgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gZGVzY3JpcHRvci5tZXRob2ROYW1lIHx8IGVycm9yKFwibWlzc2luZyBtZXRob2QgbmFtZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh0b2tlbi5lbGVtZW50LCB0b2tlbi5pbmRleCwgcGFyc2VBY3Rpb25EZXNjcmlwdG9yU3RyaW5nKHRva2VuLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZVN1ZmZpeCA9IHRoaXMuZXZlbnRUYXJnZXROYW1lID8gYEAke3RoaXMuZXZlbnRUYXJnZXROYW1lfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5ldmVudE5hbWV9JHtldmVudE5hbWVTdWZmaXh9LT4ke3RoaXMuaWRlbnRpZmllcn0jJHt0aGlzLm1ldGhvZE5hbWV9YDtcbiAgICB9XG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbXNGcm9tRXZlbnRUYXJnZXRBdHRyaWJ1dGVzKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBhcmFtc0Zyb21FdmVudFRhcmdldEF0dHJpYnV0ZXMoZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tKC4rKS1wYXJhbSRgKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IEFycmF5LmZyb20oZXZlbnRUYXJnZXQuYXR0cmlidXRlcyk7XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgeyBbY2FtZWxpemUoa2V5KV06IHR5cGVjYXN0KHZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGdldCBldmVudFRhcmdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFdmVudFRhcmdldCh0aGlzLmV2ZW50VGFyZ2V0KTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0RXZlbnROYW1lcyA9IHtcbiAgICBcImFcIjogZSA9PiBcImNsaWNrXCIsXG4gICAgXCJidXR0b25cIjogZSA9PiBcImNsaWNrXCIsXG4gICAgXCJmb3JtXCI6IGUgPT4gXCJzdWJtaXRcIixcbiAgICBcImRldGFpbHNcIjogZSA9PiBcInRvZ2dsZVwiLFxuICAgIFwiaW5wdXRcIjogZSA9PiBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT0gXCJzdWJtaXRcIiA/IFwiY2xpY2tcIiA6IFwiaW5wdXRcIixcbiAgICBcInNlbGVjdFwiOiBlID0+IFwiY2hhbmdlXCIsXG4gICAgXCJ0ZXh0YXJlYVwiOiBlID0+IFwiaW5wdXRcIlxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudE5hbWVGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgaW4gZGVmYXVsdEV2ZW50TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRFdmVudE5hbWVzW3RhZ05hbWVdKGVsZW1lbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiB0eXBlY2FzdCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKG9fTykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5jbGFzcyBCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmluZGV4O1xuICAgIH1cbiAgICBnZXQgZXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5ldmVudFRhcmdldDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmV2ZW50T3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lsbEJlSW52b2tlZEJ5RXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZVdpdGhFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmV2ZW50TmFtZTtcbiAgICB9XG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5jb250cm9sbGVyW3RoaXMubWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBcIiR7dGhpcy5hY3Rpb259XCIgcmVmZXJlbmNlcyB1bmRlZmluZWQgbWV0aG9kIFwiJHt0aGlzLm1ldGhvZE5hbWV9XCJgKTtcbiAgICB9XG4gICAgaW52b2tlV2l0aEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyYW1zIH0gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbkV2ZW50ID0gT2JqZWN0LmFzc2lnbihldmVudCwgeyBwYXJhbXMgfSk7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZC5jYWxsKHRoaXMuY29udHJvbGxlciwgYWN0aW9uRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ0RlYnVnQWN0aXZpdHkodGhpcy5tZXRob2ROYW1lLCB7IGV2ZW50LCB0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIGFjdGlvbjogdGhpcy5tZXRob2ROYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50LCBpbmRleCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCwgaW5kZXgsIGV2ZW50IH07XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaGFuZGxlRXJyb3IoZXJyb3IsIGBpbnZva2luZyBhY3Rpb24gXCIke3RoaXMuYWN0aW9ufVwiYCwgZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aWxsQmVJbnZva2VkQnlFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5jb250YWluc0VsZW1lbnQoZXZlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuY29udGFpbnNFbGVtZW50KHRoaXMuYWN0aW9uLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGdldCBtZXRob2ROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb24ubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY29wZTtcbiAgICB9XG59XG5cbmNsYXNzIEVsZW1lbnRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCA9IHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgU2V0O1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB0aGlzLnByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBuZXcgU2V0KHRoaXMubWF0Y2hFbGVtZW50c0luVHJlZSgpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIEFycmF5LmZyb20obWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NBdHRyaWJ1dGVDaGFuZ2UobXV0YXRpb24udGFyZ2V0LCBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1JlbW92ZWROb2RlcyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWRkZWROb2RlcyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQXR0cmlidXRlQ2hhbmdlKG5vZGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudEF0dHJpYnV0ZUNoYW5nZWQgJiYgdGhpcy5tYXRjaEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVDaGFuZ2VkKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1JlbW92ZWROb2Rlcyhub2Rlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShub2RlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRGcm9tTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVHJlZShlbGVtZW50LCB0aGlzLnJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NBZGRlZE5vZGVzKG5vZGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBBcnJheS5mcm9tKG5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudEZyb21Ob2RlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGhpcy5lbGVtZW50SXNBY3RpdmUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUcmVlKGVsZW1lbnQsIHRoaXMuYWRkRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubWF0Y2hFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUgPSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlKTtcbiAgICB9XG4gICAgcHJvY2Vzc1RyZWUodHJlZSwgcHJvY2Vzc29yKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLm1hdGNoRWxlbWVudHNJblRyZWUodHJlZSkpIHtcbiAgICAgICAgICAgIHByb2Nlc3Nvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRGcm9tTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50SXNBY3RpdmUoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCAhPSB0aGlzLmVsZW1lbnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRJc0FjdGl2ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudE1hdGNoZWQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudFVubWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudFVubWF0Y2hlZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQXR0cmlidXRlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIgPSBuZXcgRWxlbWVudE9ic2VydmVyKGVsZW1lbnQsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudE9ic2VydmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmF0dHJpYnV0ZU5hbWV9XWA7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBwYXVzZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5wYXVzZShjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudE9ic2VydmVyLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm1hdGNoRWxlbWVudCh0cmVlKSA/IFt0cmVlXSA6IFtdO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0cmVlLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcikpO1xuICAgICAgICByZXR1cm4gbWF0Y2guY29uY2F0KG1hdGNoZXMpO1xuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRNYXRjaGVkQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRNYXRjaGVkQXR0cmlidXRlKGVsZW1lbnQsIHRoaXMuYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudFVubWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50LCB0aGlzLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRBdHRyaWJ1dGVDaGFuZ2VkKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZCAmJiB0aGlzLmF0dHJpYnV0ZU5hbWUgPT0gYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXR0cmlidXRlVmFsdWVDaGFuZ2VkKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTdHJpbmdNYXBPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpbmdNYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4gdGhpcy5wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgb2YgdGhpcy5rbm93bkF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24obXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gbXV0YXRpb24uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBtdXRhdGlvbi5vbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlbGVnYXRlLmdldFN0cmluZ01hcEtleUZvckF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyaW5nTWFwLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmluZ01hcC5nZXQoYXR0cmlidXRlTmFtZSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCh2YWx1ZSwga2V5LCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zdHJpbmdNYXAuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwLnNldChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleUFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleUFkZGVkKGtleSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKHZhbHVlLCBrZXksIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIGtleSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmluZ01hcEtleVJlbW92ZWQoa2V5LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zdHJpbmdNYXBLZXlSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleVJlbW92ZWQoa2V5LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGtub3duQXR0cmlidXRlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5jdXJyZW50QXR0cmlidXRlTmFtZXMuY29uY2F0KHRoaXMucmVjb3JkZWRBdHRyaWJ1dGVOYW1lcykpKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRBdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMpLm1hcChhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgcmVjb3JkZWRBdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdHJpbmdNYXAua2V5cygpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBmZXRjaChtYXAsIGtleSkuYWRkKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGRlbChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBmZXRjaChtYXAsIGtleSkuZGVsZXRlKHZhbHVlKTtcbiAgICBwcnVuZShtYXAsIGtleSk7XG59XG5mdW5jdGlvbiBmZXRjaChtYXAsIGtleSkge1xuICAgIGxldCB2YWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldCgpO1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIHBydW5lKG1hcCwga2V5KSB7XG4gICAgY29uc3QgdmFsdWVzID0gbWFwLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB2YWx1ZXMuc2l6ZSA9PSAwKSB7XG4gICAgICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgICB9XG59XG5cbmNsYXNzIE11bHRpbWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNCeUtleSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IGtleXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzQnlLZXkua2V5cygpKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlcygpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBzZXRzLnJlZHVjZSgodmFsdWVzLCBzZXQpID0+IHZhbHVlcy5jb25jYXQoQXJyYXkuZnJvbShzZXQpKSwgW10pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBzZXRzLnJlZHVjZSgoc2l6ZSwgc2V0KSA9PiBzaXplICsgc2V0LnNpemUsIDApO1xuICAgIH1cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhZGQodGhpcy52YWx1ZXNCeUtleSwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlbCh0aGlzLnZhbHVlc0J5S2V5LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaGFzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcy5oYXModmFsdWUpO1xuICAgIH1cbiAgICBoYXNLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc0J5S2V5LmhhcyhrZXkpO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMuc29tZShzZXQgPT4gc2V0Lmhhcyh2YWx1ZSkpO1xuICAgIH1cbiAgICBnZXRWYWx1ZXNGb3JLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXMgPyBBcnJheS5mcm9tKHZhbHVlcykgOiBbXTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzQnlLZXkpXG4gICAgICAgICAgICAuZmlsdGVyKChba2V5LCB2YWx1ZXNdKSA9PiB2YWx1ZXMuaGFzKHZhbHVlKSlcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlc10pID0+IGtleSk7XG4gICAgfVxufVxuXG5jbGFzcyBJbmRleGVkTXVsdGltYXAgZXh0ZW5kcyBNdWx0aW1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5c0J5VmFsdWUgPSBuZXcgTWFwO1xuICAgIH1cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXNCeVZhbHVlLmtleXMoKSk7XG4gICAgfVxuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgYWRkKHRoaXMua2V5c0J5VmFsdWUsIHZhbHVlLCBrZXkpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5kZWxldGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGRlbCh0aGlzLmtleXNCeVZhbHVlLCB2YWx1ZSwga2V5KTtcbiAgICB9XG4gICAgaGFzVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c0J5VmFsdWUuaGFzKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMua2V5c0J5VmFsdWUuZ2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNldCA/IEFycmF5LmZyb20oc2V0KSA6IFtdO1xuICAgIH1cbn1cblxuY2xhc3MgVG9rZW5MaXN0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIgPSBuZXcgQXR0cmlidXRlT2JzZXJ2ZXIoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQgPSBuZXcgTXVsdGltYXA7XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5zdGFydGVkO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBwYXVzZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnBhdXNlKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLmF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkQXR0cmlidXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy50b2tlbnNNYXRjaGVkKHRoaXMucmVhZFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH1cbiAgICBlbGVtZW50QXR0cmlidXRlVmFsdWVDaGFuZ2VkKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgW3VubWF0Y2hlZFRva2VucywgbWF0Y2hlZFRva2Vuc10gPSB0aGlzLnJlZnJlc2hUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnRva2Vuc1VubWF0Y2hlZCh1bm1hdGNoZWRUb2tlbnMpO1xuICAgICAgICB0aGlzLnRva2Vuc01hdGNoZWQobWF0Y2hlZFRva2Vucyk7XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWRBdHRyaWJ1dGUoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnRva2Vuc1VubWF0Y2hlZCh0aGlzLnRva2Vuc0J5RWxlbWVudC5nZXRWYWx1ZXNGb3JLZXkoZWxlbWVudCkpO1xuICAgIH1cbiAgICB0b2tlbnNNYXRjaGVkKHRva2Vucykge1xuICAgICAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB0aGlzLnRva2VuTWF0Y2hlZCh0b2tlbikpO1xuICAgIH1cbiAgICB0b2tlbnNVbm1hdGNoZWQodG9rZW5zKSB7XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHRoaXMudG9rZW5Vbm1hdGNoZWQodG9rZW4pKTtcbiAgICB9XG4gICAgdG9rZW5NYXRjaGVkKHRva2VuKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUudG9rZW5NYXRjaGVkKHRva2VuKTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQuYWRkKHRva2VuLmVsZW1lbnQsIHRva2VuKTtcbiAgICB9XG4gICAgdG9rZW5Vbm1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS50b2tlblVubWF0Y2hlZCh0b2tlbik7XG4gICAgICAgIHRoaXMudG9rZW5zQnlFbGVtZW50LmRlbGV0ZSh0b2tlbi5lbGVtZW50LCB0b2tlbik7XG4gICAgfVxuICAgIHJlZnJlc2hUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbnMgPSB0aGlzLnRva2Vuc0J5RWxlbWVudC5nZXRWYWx1ZXNGb3JLZXkoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbnMgPSB0aGlzLnJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBmaXJzdERpZmZlcmluZ0luZGV4ID0gemlwKHByZXZpb3VzVG9rZW5zLCBjdXJyZW50VG9rZW5zKVxuICAgICAgICAgICAgLmZpbmRJbmRleCgoW3ByZXZpb3VzVG9rZW4sIGN1cnJlbnRUb2tlbl0pID0+ICF0b2tlbnNBcmVFcXVhbChwcmV2aW91c1Rva2VuLCBjdXJyZW50VG9rZW4pKTtcbiAgICAgICAgaWYgKGZpcnN0RGlmZmVyaW5nSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJldmlvdXNUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCksIGN1cnJlbnRUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0b2tlblN0cmluZy50cmltKCkuc3BsaXQoL1xccysvKS5maWx0ZXIoY29udGVudCA9PiBjb250ZW50Lmxlbmd0aClcbiAgICAgICAgLm1hcCgoY29udGVudCwgaW5kZXgpID0+ICh7IGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGNvbnRlbnQsIGluZGV4IH0pKTtcbn1cbmZ1bmN0aW9uIHppcChsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpbmRleCkgPT4gW2xlZnRbaW5kZXhdLCByaWdodFtpbmRleF1dKTtcbn1cbmZ1bmN0aW9uIHRva2Vuc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQgJiYgbGVmdC5pbmRleCA9PSByaWdodC5pbmRleCAmJiBsZWZ0LmNvbnRlbnQgPT0gcmlnaHQuY29udGVudDtcbn1cblxuY2xhc3MgVmFsdWVMaXN0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIgPSBuZXcgVG9rZW5MaXN0T2JzZXJ2ZXIoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5wYXJzZVJlc3VsdHNCeVRva2VuID0gbmV3IFdlYWtNYXA7XG4gICAgICAgIHRoaXMudmFsdWVzQnlUb2tlbkJ5RWxlbWVudCA9IG5ldyBXZWFrTWFwO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdE9ic2VydmVyLmF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIHRva2VuTWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLnNldCh0b2tlbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hQYXJzZVJlc3VsdEZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIGxldCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VSZXN1bHRzQnlUb2tlbi5nZXQodG9rZW4pO1xuICAgICAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgICBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4uc2V0KHRva2VuLCBwYXJzZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0O1xuICAgIH1cbiAgICBmZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlc0J5VG9rZW4gPSB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXZhbHVlc0J5VG9rZW4pIHtcbiAgICAgICAgICAgIHZhbHVlc0J5VG9rZW4gPSBuZXcgTWFwO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNCeVRva2VuQnlFbGVtZW50LnNldChlbGVtZW50LCB2YWx1ZXNCeVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzQnlUb2tlbjtcbiAgICB9XG4gICAgcGFyc2VUb2tlbih0b2tlbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRlbGVnYXRlLnBhcnNlVmFsdWVGb3JUb2tlbih0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQmluZGluZ09ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbiA9IG5ldyBNYXA7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIgPSBuZXcgVmFsdWVMaXN0T2JzZXJ2ZXIodGhpcy5lbGVtZW50LCB0aGlzLmFjdGlvbkF0dHJpYnV0ZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXI7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxBY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IGFjdGlvbkF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmFjdGlvbkF0dHJpYnV0ZTtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY2hlbWE7XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5iaW5kaW5nc0J5QWN0aW9uLnZhbHVlcygpKTtcbiAgICB9XG4gICAgY29ubmVjdEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IG5ldyBCaW5kaW5nKHRoaXMuY29udGV4dCwgYWN0aW9uKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc0J5QWN0aW9uLnNldChhY3Rpb24sIGJpbmRpbmcpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmJpbmRpbmdDb25uZWN0ZWQoYmluZGluZyk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzQnlBY3Rpb24uZ2V0KGFjdGlvbik7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzQnlBY3Rpb24uZGVsZXRlKGFjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJpbmRpbmdEaXNjb25uZWN0ZWQoYmluZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbEFjdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaChiaW5kaW5nID0+IHRoaXMuZGVsZWdhdGUuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKSk7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5jbGVhcigpO1xuICAgIH1cbiAgICBwYXJzZVZhbHVlRm9yVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gQWN0aW9uLmZvclRva2VuKHRva2VuKTtcbiAgICAgICAgaWYgKGFjdGlvbi5pZGVudGlmaWVyID09IHRoaXMuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIGFjdGlvbikge1xuICAgICAgICB0aGlzLmNvbm5lY3RBY3Rpb24oYWN0aW9uKTtcbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZFZhbHVlKGVsZW1lbnQsIGFjdGlvbikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBY3Rpb24oYWN0aW9uKTtcbiAgICB9XG59XG5cbmNsYXNzIFZhbHVlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5zdHJpbmdNYXBPYnNlcnZlciA9IG5ldyBTdHJpbmdNYXBPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcCA9IHRoaXMuY29udHJvbGxlci52YWx1ZURlc2NyaXB0b3JNYXA7XG4gICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrc0ZvckRlZmF1bHRWYWx1ZXMoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdNYXBPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGdldFN0cmluZ01hcEtleUZvckF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZURlc2NyaXB0b3JNYXBbYXR0cmlidXRlTmFtZV0ubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBLZXlBZGRlZChrZXksIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2soa2V5LCBkZXNjcmlwdG9yLndyaXRlcih0aGlzLnJlY2VpdmVyW2tleV0pLCBkZXNjcmlwdG9yLndyaXRlcihkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmluZ01hcFZhbHVlQ2hhbmdlZCh2YWx1ZSwgbmFtZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTmFtZU1hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gZGVzY3JpcHRvci53cml0ZXIoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHN0cmluZ01hcEtleVJlbW92ZWQoa2V5LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JOYW1lTWFwW2tleV07XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKGtleSwgZGVzY3JpcHRvci53cml0ZXIodGhpcy5yZWNlaXZlcltrZXldKSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2soa2V5LCBkZXNjcmlwdG9yLndyaXRlcihkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSksIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VDaGFuZ2VkQ2FsbGJhY2tzRm9yRGVmYXVsdFZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgbmFtZSwgZGVmYXVsdFZhbHVlLCB3cml0ZXIgfSBvZiB0aGlzLnZhbHVlRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT0gdW5kZWZpbmVkICYmICF0aGlzLmNvbnRyb2xsZXIuZGF0YS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIHdyaXRlcihkZWZhdWx0VmFsdWUpLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZUNoYW5nZWRDYWxsYmFjayhuYW1lLCByYXdWYWx1ZSwgcmF3T2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZE1ldGhvZE5hbWUgPSBgJHtuYW1lfUNoYW5nZWRgO1xuICAgICAgICBjb25zdCBjaGFuZ2VkTWV0aG9kID0gdGhpcy5yZWNlaXZlcltjaGFuZ2VkTWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbmdlZE1ldGhvZCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBbbmFtZV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2NyaXB0b3IucmVhZGVyKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIGxldCBvbGRWYWx1ZSA9IHJhd09sZFZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhd09sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBkZXNjcmlwdG9yLnJlYWRlcihyYXdPbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VkTWV0aG9kLmNhbGwodGhpcy5yZWNlaXZlciwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWVEZXNjcmlwdG9ycygpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZURlc2NyaXB0b3JNYXAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZURlc2NyaXB0b3JNYXApLm1hcChrZXkgPT4gdmFsdWVEZXNjcmlwdG9yTWFwW2tleV0pO1xuICAgIH1cbiAgICBnZXQgdmFsdWVEZXNjcmlwdG9yTmFtZU1hcCgpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy52YWx1ZURlc2NyaXB0b3JNYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcFtrZXldO1xuICAgICAgICAgICAgZGVzY3JpcHRvcnNbZGVzY3JpcHRvci5uYW1lXSA9IGRlc2NyaXB0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gICAgfVxuICAgIGhhc1ZhbHVlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTmFtZU1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgY29uc3QgaGFzTWV0aG9kTmFtZSA9IGBoYXMke2NhcGl0YWxpemUoZGVzY3JpcHRvci5uYW1lKX1gO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlcltoYXNNZXRob2ROYW1lXTtcbiAgICB9XG59XG5cbmNsYXNzIFRhcmdldE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMudGFyZ2V0c0J5TmFtZSA9IG5ldyBNdWx0aW1hcDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbkxpc3RPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlciA9IG5ldyBUb2tlbkxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRhcmdldHMoKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW5NYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlLmNvbnRhaW5zRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2VuVW5tYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKTtcbiAgICB9XG4gICAgY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldHNCeU5hbWUuaGFzKG5hbWUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldHNCeU5hbWUuYWRkKG5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50b2tlbkxpc3RPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCgpID0+IHRoaXMuZGVsZWdhdGUudGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRzQnlOYW1lLmhhcyhuYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzQnlOYW1lLmRlbGV0ZShuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLnRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbFRhcmdldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLnRhcmdldHNCeU5hbWUua2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudGFyZ2V0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUYXJnZXQoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgZGF0YS0ke3RoaXMuY29udGV4dC5pZGVudGlmaWVyfS10YXJnZXRgO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NvcGU7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGUsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eSA9IChmdW5jdGlvbk5hbWUsIGRldGFpbCA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBkZXRhaWwgPSBPYmplY3QuYXNzaWduKHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCB9LCBkZXRhaWwpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5sb2dEZWJ1Z0FjdGl2aXR5KHRoaXMuaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgbW9kdWxlLmNvbnRyb2xsZXJDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nT2JzZXJ2ZXIgPSBuZXcgQmluZGluZ09ic2VydmVyKHRoaXMsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlciA9IG5ldyBWYWx1ZU9ic2VydmVyKHRoaXMsIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSBuZXcgVGFyZ2V0T2JzZXJ2ZXIodGhpcywgdGhpcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiaW5pdGlhbGl6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIFwiaW5pdGlhbGl6aW5nIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgXCJjb25uZWN0aW5nIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJkaXNjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgXCJkaXNjb25uZWN0aW5nIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgZ2V0IGFwcGxpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgZGlzcGF0Y2hlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlLCBkZXRhaWwgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0sIGRldGFpbCk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIGBFcnJvciAke21lc3NhZ2V9YCwgZGV0YWlsKTtcbiAgICB9XG4gICAgdGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWV9VGFyZ2V0Q29ubmVjdGVkYCwgZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lfVRhcmdldERpc2Nvbm5lY3RlZGAsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBpbnZva2VDb250cm9sbGVyTWV0aG9kKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250cm9sbGVyW21ldGhvZE5hbWVdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29udHJvbGxlclttZXRob2ROYW1lXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldEFuY2VzdG9yc0ZvckNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhbmNlc3RvcnMucmVkdWNlKCh2YWx1ZXMsIGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgICAgIGdldE93blN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpLmZvckVhY2gobmFtZSA9PiB2YWx1ZXMuYWRkKG5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LCBuZXcgU2V0KSk7XG59XG5mdW5jdGlvbiByZWFkSW5oZXJpdGFibGVTdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBhbmNlc3RvcnMucmVkdWNlKChwYWlycywgY29uc3RydWN0b3IpID0+IHtcbiAgICAgICAgcGFpcnMucHVzaCguLi5nZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSk7XG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvcnNGb3JDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgIHdoaWxlIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChjb25zdHJ1Y3Rvcik7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9ycy5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uIDogW107XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIGRlZmluaXRpb24gPyBPYmplY3Qua2V5cyhkZWZpbml0aW9uKS5tYXAoa2V5ID0+IFtrZXksIGRlZmluaXRpb25ba2V5XV0pIDogW107XG59XG5cbmZ1bmN0aW9uIGJsZXNzKGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHNoYWRvdyhjb25zdHJ1Y3RvciwgZ2V0Qmxlc3NlZFByb3BlcnRpZXMoY29uc3RydWN0b3IpKTtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhjb25zdHJ1Y3RvciwgcHJvcGVydGllcykge1xuICAgIGNvbnN0IHNoYWRvd0NvbnN0cnVjdG9yID0gZXh0ZW5kKGNvbnN0cnVjdG9yKTtcbiAgICBjb25zdCBzaGFkb3dQcm9wZXJ0aWVzID0gZ2V0U2hhZG93UHJvcGVydGllcyhjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNoYWRvd0NvbnN0cnVjdG9yLnByb3RvdHlwZSwgc2hhZG93UHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHNoYWRvd0NvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gZ2V0Qmxlc3NlZFByb3BlcnRpZXMoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBibGVzc2luZ3MgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgXCJibGVzc2luZ3NcIik7XG4gICAgcmV0dXJuIGJsZXNzaW5ncy5yZWR1Y2UoKGJsZXNzZWRQcm9wZXJ0aWVzLCBibGVzc2luZykgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYmxlc3NpbmcoY29uc3RydWN0b3IpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gYmxlc3NlZFByb3BlcnRpZXNba2V5XSB8fCB7fTtcbiAgICAgICAgICAgIGJsZXNzZWRQcm9wZXJ0aWVzW2tleV0gPSBPYmplY3QuYXNzaWduKGRlc2NyaXB0b3IsIHByb3BlcnRpZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsZXNzZWRQcm9wZXJ0aWVzO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldFNoYWRvd1Byb3BlcnRpZXMocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIGdldE93bktleXMocHJvcGVydGllcykucmVkdWNlKChzaGFkb3dQcm9wZXJ0aWVzLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldFNoYWRvd2VkRGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BlcnRpZXMsIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNoYWRvd1Byb3BlcnRpZXMsIHsgW2tleV06IGRlc2NyaXB0b3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYWRvd1Byb3BlcnRpZXM7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0U2hhZG93ZWREZXNjcmlwdG9yKHByb3RvdHlwZSwgcHJvcGVydGllcywga2V5KSB7XG4gICAgY29uc3Qgc2hhZG93aW5nRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBrZXkpO1xuICAgIGNvbnN0IHNoYWRvd2VkQnlWYWx1ZSA9IHNoYWRvd2luZ0Rlc2NyaXB0b3IgJiYgXCJ2YWx1ZVwiIGluIHNoYWRvd2luZ0Rlc2NyaXB0b3I7XG4gICAgaWYgKCFzaGFkb3dlZEJ5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvcGVydGllcywga2V5KS52YWx1ZTtcbiAgICAgICAgaWYgKHNoYWRvd2luZ0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gc2hhZG93aW5nRGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNoYWRvd2luZ0Rlc2NyaXB0b3Iuc2V0IHx8IGRlc2NyaXB0b3Iuc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cbn1cbmNvbnN0IGdldE93bktleXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChvYmplY3QpID0+IFtcbiAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCksXG4gICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdClcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICB9XG59KSgpO1xuY29uc3QgZXh0ZW5kID0gKCgpID0+IHtcbiAgICBmdW5jdGlvbiBleHRlbmRXaXRoUmVmbGVjdChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBleHRlbmRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChjb25zdHJ1Y3RvciwgYXJndW1lbnRzLCBuZXcudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IGV4dGVuZGVkIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFJlZmxlY3Quc2V0UHJvdG90eXBlT2YoZXh0ZW5kZWQsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0UmVmbGVjdEV4dGVuc2lvbigpIHtcbiAgICAgICAgY29uc3QgYSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5hLmNhbGwodGhpcyk7IH07XG4gICAgICAgIGNvbnN0IGIgPSBleHRlbmRXaXRoUmVmbGVjdChhKTtcbiAgICAgICAgYi5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBiO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB0ZXN0UmVmbGVjdEV4dGVuc2lvbigpO1xuICAgICAgICByZXR1cm4gZXh0ZW5kV2l0aFJlZmxlY3Q7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gKGNvbnN0cnVjdG9yKSA9PiBjbGFzcyBleHRlbmRlZCBleHRlbmRzIGNvbnN0cnVjdG9yIHtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBibGVzc0RlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aWZpZXI6IGRlZmluaXRpb24uaWRlbnRpZmllcixcbiAgICAgICAgY29udHJvbGxlckNvbnN0cnVjdG9yOiBibGVzcyhkZWZpbml0aW9uLmNvbnRyb2xsZXJDb25zdHJ1Y3RvcilcbiAgICB9O1xufVxuXG5jbGFzcyBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gYmxlc3NEZWZpbml0aW9uKGRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmNvbnRleHRzQnlTY29wZSA9IG5ldyBXZWFrTWFwO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENvbnRleHRzID0gbmV3IFNldDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24uaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldCBjb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb25uZWN0ZWRDb250ZXh0cyk7XG4gICAgfVxuICAgIGNvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZmV0Y2hDb250ZXh0Rm9yU2NvcGUoc2NvcGUpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENvbnRleHRzLmFkZChjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5jb25uZWN0KCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dHNCeVNjb3BlLmdldChzY29wZSk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZENvbnRleHRzLmRlbGV0ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0c0J5U2NvcGUuZ2V0KHNjb3BlKTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQodGhpcywgc2NvcGUpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c0J5U2NvcGUuc2V0KHNjb3BlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG59XG5cbmNsYXNzIENsYXNzTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFzKHRoaXMuZ2V0RGF0YUtleShuYW1lKSk7XG4gICAgfVxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbChuYW1lKVswXTtcbiAgICB9XG4gICAgZ2V0QWxsKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJpbmcgPSB0aGlzLmRhdGEuZ2V0KHRoaXMuZ2V0RGF0YUtleShuYW1lKSkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHRva2VuaXplKHRva2VuU3RyaW5nKTtcbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0QXR0cmlidXRlTmFtZUZvcktleSh0aGlzLmdldERhdGFLZXkobmFtZSkpO1xuICAgIH1cbiAgICBnZXREYXRhS2V5KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9LWNsYXNzYDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmRhdGE7XG4gICAgfVxufVxuXG5jbGFzcyBEYXRhTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGBkYXRhLSR7dGhpcy5pZGVudGlmaWVyfS0ke2Rhc2hlcml6ZShrZXkpfWA7XG4gICAgfVxufVxuXG5jbGFzcyBHdWlkZSB7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgICAgIHRoaXMud2FybmVkS2V5c0J5T2JqZWN0ID0gbmV3IFdlYWtNYXA7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICB3YXJuKG9iamVjdCwga2V5LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCB3YXJuZWRLZXlzID0gdGhpcy53YXJuZWRLZXlzQnlPYmplY3QuZ2V0KG9iamVjdCk7XG4gICAgICAgIGlmICghd2FybmVkS2V5cykge1xuICAgICAgICAgICAgd2FybmVkS2V5cyA9IG5ldyBTZXQ7XG4gICAgICAgICAgICB0aGlzLndhcm5lZEtleXNCeU9iamVjdC5zZXQob2JqZWN0LCB3YXJuZWRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdhcm5lZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHdhcm5lZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKG1lc3NhZ2UsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZVZhbHVlQ29udGFpbnNUb2tlbihhdHRyaWJ1dGVOYW1lLCB0b2tlbikge1xuICAgIHJldHVybiBgWyR7YXR0cmlidXRlTmFtZX1+PVwiJHt0b2tlbn1cIl1gO1xufVxuXG5jbGFzcyBUYXJnZXRTZXQge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5zY2hlbWE7XG4gICAgfVxuICAgIGhhcyh0YXJnZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQodGFyZ2V0TmFtZSkgIT0gbnVsbDtcbiAgICB9XG4gICAgZmluZCguLi50YXJnZXROYW1lcykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0TmFtZXMucmVkdWNlKCh0YXJnZXQsIHRhcmdldE5hbWUpID0+IHRhcmdldFxuICAgICAgICAgICAgfHwgdGhpcy5maW5kVGFyZ2V0KHRhcmdldE5hbWUpXG4gICAgICAgICAgICB8fCB0aGlzLmZpbmRMZWdhY3lUYXJnZXQodGFyZ2V0TmFtZSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZpbmRBbGwoLi4udGFyZ2V0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE5hbWVzLnJlZHVjZSgodGFyZ2V0cywgdGFyZ2V0TmFtZSkgPT4gW1xuICAgICAgICAgICAgLi4udGFyZ2V0cyxcbiAgICAgICAgICAgIC4uLnRoaXMuZmluZEFsbFRhcmdldHModGFyZ2V0TmFtZSksXG4gICAgICAgICAgICAuLi50aGlzLmZpbmRBbGxMZWdhY3lUYXJnZXRzKHRhcmdldE5hbWUpXG4gICAgICAgIF0sIFtdKTtcbiAgICB9XG4gICAgZmluZFRhcmdldCh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmZpbmRFbGVtZW50KHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZmluZEFsbFRhcmdldHModGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5maW5kQWxsRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBnZXRTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlRm9yU2NvcGUodGhpcy5pZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlQ29udGFpbnNUb2tlbihhdHRyaWJ1dGVOYW1lLCB0YXJnZXROYW1lKTtcbiAgICB9XG4gICAgZmluZExlZ2FjeVRhcmdldCh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRMZWdhY3lTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZSh0aGlzLnNjb3BlLmZpbmRFbGVtZW50KHNlbGVjdG9yKSwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRBbGxMZWdhY3lUYXJnZXRzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldExlZ2FjeVNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZmluZEFsbEVsZW1lbnRzKHNlbGVjdG9yKS5tYXAoZWxlbWVudCA9PiB0aGlzLmRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSk7XG4gICAgfVxuICAgIGdldExlZ2FjeVNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2NyaXB0b3IgPSBgJHt0aGlzLmlkZW50aWZpZXJ9LiR7dGFyZ2V0TmFtZX1gO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZSwgdGFyZ2V0RGVzY3JpcHRvcik7XG4gICAgfVxuICAgIGRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlO1xuICAgICAgICAgICAgY29uc3QgcmV2aXNlZEF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS50YXJnZXRBdHRyaWJ1dGVGb3JTY29wZShpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpZGUud2FybihlbGVtZW50LCBgdGFyZ2V0OiR7dGFyZ2V0TmFtZX1gLCBgUGxlYXNlIHJlcGxhY2UgJHthdHRyaWJ1dGVOYW1lfT1cIiR7aWRlbnRpZmllcn0uJHt0YXJnZXROYW1lfVwiIHdpdGggJHtyZXZpc2VkQXR0cmlidXRlTmFtZX09XCIke3RhcmdldE5hbWV9XCIuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGUgJHthdHRyaWJ1dGVOYW1lfSBhdHRyaWJ1dGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgU3RpbXVsdXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBndWlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZ3VpZGU7XG4gICAgfVxufVxuXG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBlbGVtZW50LCBpZGVudGlmaWVyLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gbmV3IFRhcmdldFNldCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gbmV3IENsYXNzTWFwKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YU1hcCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb250YWluc0VsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvc2VzdCh0aGlzLmNvbnRyb2xsZXJTZWxlY3RvcikgPT09IHRoaXMuZWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuZ3VpZGUgPSBuZXcgR3VpZGUobG9nZ2VyKTtcbiAgICB9XG4gICAgZmluZEVsZW1lbnQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKVxuICAgICAgICAgICAgPyB0aGlzLmVsZW1lbnRcbiAgICAgICAgICAgIDogdGhpcy5xdWVyeUVsZW1lbnRzKHNlbGVjdG9yKS5maW5kKHRoaXMuY29udGFpbnNFbGVtZW50KTtcbiAgICB9XG4gICAgZmluZEFsbEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyBbdGhpcy5lbGVtZW50XSA6IFtdLFxuICAgICAgICAgICAgLi4udGhpcy5xdWVyeUVsZW1lbnRzKHNlbGVjdG9yKS5maWx0ZXIodGhpcy5jb250YWluc0VsZW1lbnQpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlQ29udGFpbnNUb2tlbih0aGlzLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlLCB0aGlzLmlkZW50aWZpZXIpO1xuICAgIH1cbn1cblxuY2xhc3MgU2NvcGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgc2NoZW1hLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyID0gbmV3IFZhbHVlTGlzdE9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcy5jb250cm9sbGVyQXR0cmlidXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXJCeUVsZW1lbnQgPSBuZXcgV2Vha01hcDtcbiAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cyA9IG5ldyBXZWFrTWFwO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlO1xuICAgIH1cbiAgICBwYXJzZVZhbHVlRm9yVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBjb250ZW50OiBpZGVudGlmaWVyIH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3Qgc2NvcGVzQnlJZGVudGlmaWVyID0gdGhpcy5mZXRjaFNjb3Blc0J5SWRlbnRpZmllckZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGxldCBzY29wZSA9IHNjb3Blc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVTY29wZUZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc2NvcGVzQnlJZGVudGlmaWVyLnNldChpZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvdW50ID0gKHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuZ2V0KHZhbHVlKSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuc2V0KHZhbHVlLCByZWZlcmVuY2VDb3VudCk7XG4gICAgICAgIGlmIChyZWZlcmVuY2VDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNjb3BlQ29ubmVjdGVkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkVmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlQ291bnQgPSB0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWZlcmVuY2VDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cy5zZXQodmFsdWUsIHJlZmVyZW5jZUNvdW50IC0gMSk7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2NvcGVEaXNjb25uZWN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZldGNoU2NvcGVzQnlJZGVudGlmaWVyRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBzY29wZXNCeUlkZW50aWZpZXIgPSB0aGlzLnNjb3Blc0J5SWRlbnRpZmllckJ5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghc2NvcGVzQnlJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBzY29wZXNCeUlkZW50aWZpZXIgPSBuZXcgTWFwO1xuICAgICAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXJCeUVsZW1lbnQuc2V0KGVsZW1lbnQsIHNjb3Blc0J5SWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3Blc0J5SWRlbnRpZmllcjtcbiAgICB9XG59XG5cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLnNjb3BlT2JzZXJ2ZXIgPSBuZXcgU2NvcGVPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuc2NoZW1hLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXIgPSBuZXcgTXVsdGltYXA7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWRlbnRpZmllciA9IG5ldyBNYXA7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5zY2hlbWE7XG4gICAgfVxuICAgIGdldCBsb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLmxvZ2dlcjtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlO1xuICAgIH1cbiAgICBnZXQgbW9kdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLnZhbHVlcygpKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVzLnJlZHVjZSgoY29udGV4dHMsIG1vZHVsZSkgPT4gY29udGV4dHMuY29uY2F0KG1vZHVsZS5jb250ZXh0cyksIFtdKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2NvcGVPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNjb3BlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBsb2FkRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMudW5sb2FkSWRlbnRpZmllcihkZWZpbml0aW9uLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBuZXcgTW9kdWxlKHRoaXMuYXBwbGljYXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RNb2R1bGUobW9kdWxlKTtcbiAgICB9XG4gICAgdW5sb2FkSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdE1vZHVsZShtb2R1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbnRleHRGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuY29udGV4dHMuZmluZChjb250ZXh0ID0+IGNvbnRleHQuZWxlbWVudCA9PSBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMuc2NoZW1hLCBlbGVtZW50LCBpZGVudGlmaWVyLCB0aGlzLmxvZ2dlcik7XG4gICAgfVxuICAgIHNjb3BlQ29ubmVjdGVkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyLmFkZChzY29wZS5pZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoc2NvcGUuaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZS5jb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY29wZURpc2Nvbm5lY3RlZChzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3Blc0J5SWRlbnRpZmllci5kZWxldGUoc2NvcGUuaWRlbnRpZmllciwgc2NvcGUpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZ2V0KHNjb3BlLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGlzY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdE1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLnNldChtb2R1bGUuaWRlbnRpZmllciwgbW9kdWxlKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuZ2V0VmFsdWVzRm9yS2V5KG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goc2NvcGUgPT4gbW9kdWxlLmNvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdE1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLmRlbGV0ZShtb2R1bGUuaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyLmdldFZhbHVlc0ZvcktleShtb2R1bGUuaWRlbnRpZmllcik7XG4gICAgICAgIHNjb3Blcy5mb3JFYWNoKHNjb3BlID0+IG1vZHVsZS5kaXNjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0U2NoZW1hID0ge1xuICAgIGNvbnRyb2xsZXJBdHRyaWJ1dGU6IFwiZGF0YS1jb250cm9sbGVyXCIsXG4gICAgYWN0aW9uQXR0cmlidXRlOiBcImRhdGEtYWN0aW9uXCIsXG4gICAgdGFyZ2V0QXR0cmlidXRlOiBcImRhdGEtdGFyZ2V0XCIsXG4gICAgdGFyZ2V0QXR0cmlidXRlRm9yU2NvcGU6IGlkZW50aWZpZXIgPT4gYGRhdGEtJHtpZGVudGlmaWVyfS10YXJnZXRgXG59O1xuXG5jbGFzcyBBcHBsaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgc2NoZW1hID0gZGVmYXVsdFNjaGVtYSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5ID0gKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dGb3JtYXR0ZWRNZXNzYWdlKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJvdXRlciA9IG5ldyBSb3V0ZXIodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydChlbGVtZW50LCBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBuZXcgQXBwbGljYXRpb24oZWxlbWVudCwgc2NoZW1hKTtcbiAgICAgICAgYXBwbGljYXRpb24uc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgYXdhaXQgZG9tUmVhZHkoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdGFydGluZ1wiKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMucm91dGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImFwcGxpY2F0aW9uXCIsIFwic3RhcnRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImFwcGxpY2F0aW9uXCIsIFwic3RvcHBpbmdcIik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucm91dGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdG9wXCIpO1xuICAgIH1cbiAgICByZWdpc3RlcihpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJDb25zdHJ1Y3Rvci5zaG91bGRMb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoeyBpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZChoZWFkLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gQXJyYXkuaXNBcnJheShoZWFkKSA/IGhlYWQgOiBbaGVhZCwgLi4ucmVzdF07XG4gICAgICAgIGRlZmluaXRpb25zLmZvckVhY2goZGVmaW5pdGlvbiA9PiB0aGlzLnJvdXRlci5sb2FkRGVmaW5pdGlvbihkZWZpbml0aW9uKSk7XG4gICAgfVxuICAgIHVubG9hZChoZWFkLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gQXJyYXkuaXNBcnJheShoZWFkKSA/IGhlYWQgOiBbaGVhZCwgLi4ucmVzdF07XG4gICAgICAgIGlkZW50aWZpZXJzLmZvckVhY2goaWRlbnRpZmllciA9PiB0aGlzLnJvdXRlci51bmxvYWRJZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuY29udGV4dHMubWFwKGNvbnRleHQgPT4gY29udGV4dC5jb250cm9sbGVyKTtcbiAgICB9XG4gICAgZ2V0Q29udHJvbGxlckZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMucm91dGVyLmdldENvbnRleHRGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0LmNvbnRyb2xsZXIgOiBudWxsO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYCVzXFxuXFxuJW9cXG5cXG4lb2AsIG1lc3NhZ2UsIGVycm9yLCBkZXRhaWwpO1xuICAgICAgICAoX2EgPSB3aW5kb3cub25lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBtZXNzYWdlLCBcIlwiLCAwLCAwLCBlcnJvcik7XG4gICAgfVxuICAgIGxvZ0Zvcm1hdHRlZE1lc3NhZ2UoaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwgPSB7fSkge1xuICAgICAgICBkZXRhaWwgPSBPYmplY3QuYXNzaWduKHsgYXBwbGljYXRpb246IHRoaXMgfSwgZGV0YWlsKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYCR7aWRlbnRpZmllcn0gIyR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJkZXRhaWxzOlwiLCBPYmplY3QuYXNzaWduKHt9LCBkZXRhaWwpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb21SZWFkeSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzUHJvcGVydGllc0JsZXNzaW5nKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcImNsYXNzZXNcIik7XG4gICAgcmV0dXJuIGNsYXNzZXMucmVkdWNlKChwcm9wZXJ0aWVzLCBjbGFzc0RlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvckNsYXNzRGVmaW5pdGlvbihjbGFzc0RlZmluaXRpb24pKTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3NEZWZpbml0aW9uKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtrZXl9Q2xhc3NgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xhc3NlcyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGNsYXNzZXMuZ2V0QXR0cmlidXRlTmFtZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtrZXl9Q2xhc3Nlc2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5nZXRBbGwoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUoa2V5KX1DbGFzc2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5oYXMoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIFRhcmdldFByb3BlcnRpZXNCbGVzc2luZyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHRhcmdldHMgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgXCJ0YXJnZXRzXCIpO1xuICAgIHJldHVybiB0YXJnZXRzLnJlZHVjZSgocHJvcGVydGllcywgdGFyZ2V0RGVmaW5pdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzRm9yVGFyZ2V0RGVmaW5pdGlvbih0YXJnZXREZWZpbml0aW9uKSk7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gcHJvcGVydGllc0ZvclRhcmdldERlZmluaXRpb24obmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtuYW1lfVRhcmdldGBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRzLmZpbmQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHRhcmdldCBlbGVtZW50IFwiJHtuYW1lfVwiIGZvciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiIGNvbnRyb2xsZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtuYW1lfVRhcmdldHNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldHMuZmluZEFsbChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUobmFtZSl9VGFyZ2V0YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzLmhhcyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIFZhbHVlUHJvcGVydGllc0JsZXNzaW5nKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgdmFsdWVEZWZpbml0aW9uUGFpcnMgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgXCJ2YWx1ZXNcIik7XG4gICAgY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yTWFwID0ge1xuICAgICAgICB2YWx1ZURlc2NyaXB0b3JNYXA6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVEZWZpbml0aW9uUGFpcnMucmVkdWNlKChyZXN1bHQsIHZhbHVlRGVmaW5pdGlvblBhaXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEZXNjcmlwdG9yID0gcGFyc2VWYWx1ZURlZmluaXRpb25QYWlyKHZhbHVlRGVmaW5pdGlvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5kYXRhLmdldEF0dHJpYnV0ZU5hbWVGb3JLZXkodmFsdWVEZXNjcmlwdG9yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbYXR0cmlidXRlTmFtZV06IHZhbHVlRGVzY3JpcHRvciB9KTtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZURlZmluaXRpb25QYWlycy5yZWR1Y2UoKHByb3BlcnRpZXMsIHZhbHVlRGVmaW5pdGlvblBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvclZhbHVlRGVmaW5pdGlvblBhaXIodmFsdWVEZWZpbml0aW9uUGFpcikpO1xuICAgIH0sIHByb3BlcnR5RGVzY3JpcHRvck1hcCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyKTtcbiAgICBjb25zdCB7IGtleSwgbmFtZSwgcmVhZGVyOiByZWFkLCB3cml0ZXI6IHdyaXRlIH0gPSBkZWZpbml0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtuYW1lXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQoa2V5LCB3cml0ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUobmFtZSl9YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhcyhrZXkpIHx8IGRlZmluaXRpb24uaGFzQ3VzdG9tRGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcihbdG9rZW4sIHR5cGVEZWZpbml0aW9uXSkge1xuICAgIHJldHVybiB2YWx1ZURlc2NyaXB0b3JGb3JUb2tlbkFuZFR5cGVEZWZpbml0aW9uKHRva2VuLCB0eXBlRGVmaW5pdGlvbik7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KGNvbnN0YW50KSB7XG4gICAgc3dpdGNoIChjb25zdGFudCkge1xuICAgICAgICBjYXNlIEFycmF5OiByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICBjYXNlIEJvb2xlYW46IHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBOdW1iZXI6IHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICBjYXNlIE9iamVjdDogcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICAgIGNhc2UgU3RyaW5nOiByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZURlZmF1bHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6IHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRlZmF1bHRWYWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZVR5cGVPYmplY3QodHlwZU9iamVjdCkge1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlT2JqZWN0LnR5cGUpO1xuICAgIGlmICh0eXBlRnJvbU9iamVjdCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVUeXBlID0gcGFyc2VWYWx1ZVR5cGVEZWZhdWx0KHR5cGVPYmplY3QuZGVmYXVsdCk7XG4gICAgICAgIGlmICh0eXBlRnJvbU9iamVjdCAhPT0gZGVmYXVsdFZhbHVlVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIFwiJHt0eXBlRnJvbU9iamVjdH1cIiBtdXN0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBkZWZhdWx0IHZhbHVlLiBHaXZlbiBkZWZhdWx0IHZhbHVlOiBcIiR7dHlwZU9iamVjdC5kZWZhdWx0fVwiIGFzIFwiJHtkZWZhdWx0VmFsdWVUeXBlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVGcm9tT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVUeXBlRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVPYmplY3QodHlwZURlZmluaXRpb24pO1xuICAgIGNvbnN0IHR5cGVGcm9tRGVmYXVsdFZhbHVlID0gcGFyc2VWYWx1ZVR5cGVEZWZhdWx0KHR5cGVEZWZpbml0aW9uKTtcbiAgICBjb25zdCB0eXBlRnJvbUNvbnN0YW50ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlRGVmaW5pdGlvbik7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tT2JqZWN0IHx8IHR5cGVGcm9tRGVmYXVsdFZhbHVlIHx8IHR5cGVGcm9tQ29uc3RhbnQ7XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB2YWx1ZSB0eXBlIFwiJHt0eXBlRGVmaW5pdGlvbn1cImApO1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlRm9yRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlRGVmaW5pdGlvbik7XG4gICAgaWYgKGNvbnN0YW50KVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlc0J5VHlwZVtjb25zdGFudF07XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdHlwZURlZmluaXRpb24uZGVmYXVsdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgcmV0dXJuIHR5cGVEZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdG9yRm9yVG9rZW5BbmRUeXBlRGVmaW5pdGlvbih0b2tlbiwgdHlwZURlZmluaXRpb24pIHtcbiAgICBjb25zdCBrZXkgPSBgJHtkYXNoZXJpemUodG9rZW4pfS12YWx1ZWA7XG4gICAgY29uc3QgdHlwZSA9IHBhcnNlVmFsdWVUeXBlRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShrZXkpLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkgeyByZXR1cm4gZGVmYXVsdFZhbHVlRm9yRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbik7IH0sXG4gICAgICAgIGdldCBoYXNDdXN0b21EZWZhdWx0VmFsdWUoKSB7IHJldHVybiBwYXJzZVZhbHVlVHlwZURlZmF1bHQodHlwZURlZmluaXRpb24pICE9PSB1bmRlZmluZWQ7IH0sXG4gICAgICAgIHJlYWRlcjogcmVhZGVyc1t0eXBlXSxcbiAgICAgICAgd3JpdGVyOiB3cml0ZXJzW3R5cGVdIHx8IHdyaXRlcnMuZGVmYXVsdFxuICAgIH07XG59XG5jb25zdCBkZWZhdWx0VmFsdWVzQnlUeXBlID0ge1xuICAgIGdldCBhcnJheSgpIHsgcmV0dXJuIFtdOyB9LFxuICAgIGJvb2xlYW46IGZhbHNlLFxuICAgIG51bWJlcjogMCxcbiAgICBnZXQgb2JqZWN0KCkgeyByZXR1cm4ge307IH0sXG4gICAgc3RyaW5nOiBcIlwiXG59O1xuY29uc3QgcmVhZGVycyA9IHtcbiAgICBhcnJheSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG4gICAgYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISh2YWx1ZSA9PSBcIjBcIiB8fCB2YWx1ZSA9PSBcImZhbHNlXCIpO1xuICAgIH0sXG4gICAgbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH0sXG4gICAgb2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmNvbnN0IHdyaXRlcnMgPSB7XG4gICAgZGVmYXVsdDogd3JpdGVTdHJpbmcsXG4gICAgYXJyYXk6IHdyaXRlSlNPTixcbiAgICBvYmplY3Q6IHdyaXRlSlNPTlxufTtcbmZ1bmN0aW9uIHdyaXRlSlNPTih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB3cml0ZVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xufVxuXG5jbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc2hvdWxkTG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBhcHBsaWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5hcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCB0YXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS50YXJnZXRzO1xuICAgIH1cbiAgICBnZXQgY2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuY2xhc3NlcztcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmRhdGE7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgfVxuICAgIGRpc3BhdGNoKGV2ZW50TmFtZSwgeyB0YXJnZXQgPSB0aGlzLmVsZW1lbnQsIGRldGFpbCA9IHt9LCBwcmVmaXggPSB0aGlzLmlkZW50aWZpZXIsIGJ1YmJsZXMgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHByZWZpeCA/IGAke3ByZWZpeH06JHtldmVudE5hbWV9YCA6IGV2ZW50TmFtZTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbn1cbkNvbnRyb2xsZXIuYmxlc3NpbmdzID0gW0NsYXNzUHJvcGVydGllc0JsZXNzaW5nLCBUYXJnZXRQcm9wZXJ0aWVzQmxlc3NpbmcsIFZhbHVlUHJvcGVydGllc0JsZXNzaW5nXTtcbkNvbnRyb2xsZXIudGFyZ2V0cyA9IFtdO1xuQ29udHJvbGxlci52YWx1ZXMgPSB7fTtcblxuZXhwb3J0IHsgQXBwbGljYXRpb24sIEF0dHJpYnV0ZU9ic2VydmVyLCBDb250ZXh0LCBDb250cm9sbGVyLCBFbGVtZW50T2JzZXJ2ZXIsIEluZGV4ZWRNdWx0aW1hcCwgTXVsdGltYXAsIFN0cmluZ01hcE9ic2VydmVyLCBUb2tlbkxpc3RPYnNlcnZlciwgVmFsdWVMaXN0T2JzZXJ2ZXIsIGFkZCwgZGVmYXVsdFNjaGVtYSwgZGVsLCBmZXRjaCwgcHJ1bmUgfTtcbiIsImltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcbmltcG9ydCBzeW1mb255Q29udHJvbGxlcnMgZnJvbSAnLi93ZWJwYWNrL2xvYWRlciFAc3ltZm9ueS9zdGltdWx1cy1icmlkZ2UvY29udHJvbGxlcnMuanNvbic7XG5cbi8qXG5TdGltdWx1cyBXZWJwYWNrIEhlbHBlcnMgMS4wLjBcbkNvcHlyaWdodCDCqSAyMDIxIEJhc2VjYW1wLCBMTENcbiAqL1xuZnVuY3Rpb24gZGVmaW5pdGlvbnNGcm9tQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQua2V5cygpXG4gICAgICAgIC5tYXAoKGtleSkgPT4gZGVmaW5pdGlvbkZvck1vZHVsZVdpdGhDb250ZXh0QW5kS2V5KGNvbnRleHQsIGtleSkpXG4gICAgICAgIC5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSk7XG59XG5mdW5jdGlvbiBkZWZpbml0aW9uRm9yTW9kdWxlV2l0aENvbnRleHRBbmRLZXkoY29udGV4dCwga2V5KSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGlkZW50aWZpZXJGb3JDb250ZXh0S2V5KGtleSk7XG4gICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25Gb3JNb2R1bGVBbmRJZGVudGlmaWVyKGNvbnRleHQoa2V5KSwgaWRlbnRpZmllcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmaW5pdGlvbkZvck1vZHVsZUFuZElkZW50aWZpZXIobW9kdWxlLCBpZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJvbGxlckNvbnN0cnVjdG9yID0gbW9kdWxlLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBjb250cm9sbGVyQ29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXJDb25zdHJ1Y3RvciB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlkZW50aWZpZXJGb3JDb250ZXh0S2V5KGtleSkge1xuICAgIGNvbnN0IGxvZ2ljYWxOYW1lID0gKGtleS5tYXRjaCgvXig/OlxcLlxcLyk/KC4rKSg/OltfLV1jb250cm9sbGVyXFwuLis/KSQvKSB8fCBbXSlbMV07XG4gICAgaWYgKGxvZ2ljYWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBsb2dpY2FsTmFtZS5yZXBsYWNlKC9fL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCItLVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0U3RpbXVsdXNBcHAoY29udGV4dCkge1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uID0gQXBwbGljYXRpb24uc3RhcnQoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYXBwbGljYXRpb24uZGVidWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBhcHBsaWNhdGlvbi5sb2FkKGRlZmluaXRpb25zRnJvbUNvbnRleHQoY29udGV4dCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXJOYW1lIGluIHN5bWZvbnlDb250cm9sbGVycykge1xuICAgICAgICBpZiAoIXN5bWZvbnlDb250cm9sbGVycy5oYXNPd25Qcm9wZXJ0eShjb250cm9sbGVyTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN5bWZvbnlDb250cm9sbGVyc1tjb250cm9sbGVyTmFtZV0udGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbi5yZWdpc3Rlcihjb250cm9sbGVyTmFtZSwgbW9kdWxlLmRlZmF1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGxpY2F0aW9uO1xufVxuXG5leHBvcnQgeyBzdGFydFN0aW11bHVzQXBwIH07XG4iLCJpbXBvcnQgeyBpc1N0cmluZywgaHlwaGVuYXRlLCBOT09QLCBleHRlbmQsIGlzT2JqZWN0LCBOTywgaXNBcnJheSwgbWFrZU1hcCwgaXNTeW1ib2wsIEVNUFRZX09CSiwgY2FwaXRhbGl6ZSwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgUGF0Y2hGbGFnTmFtZXMsIHNsb3RGbGFnc1RleHQsIGlzT24sIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNSZXNlcnZlZFByb3AsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdE9uV2Fybihtc2cpIHtcclxuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2cubWVzc2FnZX1gKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XHJcbiAgICBjb25zdCBtc2cgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWVcclxuICAgICAgICA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYClcclxuICAgICAgICA6IGNvZGU7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XHJcbiAgICBlcnJvci5jb2RlID0gY29kZTtcclxuICAgIGVycm9yLmxvYyA9IGxvYztcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgLy8gcGFyc2UgZXJyb3JzXHJcbiAgICBbMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovXTogJ0lsbGVnYWwgY29tbWVudC4nLFxyXG4gICAgWzEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovXTogJ0NEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LicsXHJcbiAgICBbMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovXTogJ0R1cGxpY2F0ZSBhdHRyaWJ1dGUuJyxcclxuICAgIFszIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovXTogJ0VuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy4nLFxyXG4gICAgWzQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXHJcbiAgICBbNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzYgLyogRU9GX0lOX0NEQVRBICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uJyxcclxuICAgIFs3IC8qIEVPRl9JTl9DT01NRU5UICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIGNvbW1lbnQuJyxcclxuICAgIFs4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuJyxcclxuICAgIFs5IC8qIEVPRl9JTl9UQUcgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXHJcbiAgICBbMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgY2xvc2VkIGNvbW1lbnQuJyxcclxuICAgIFsxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC4nLFxyXG4gICAgWzEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcclxuICAgIFsxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqL106ICdBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi9dOiAnRW5kIHRhZyBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi9dOiAnV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNiAvKiBORVNURURfQ09NTUVOVCAqL106IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcclxuICAgIFsxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqL106ICdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBhbmQgVSswMDNDICg8KS4nLFxyXG4gICAgWzE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqL106ICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgVSswMDNDICg8KSwgVSswMDNEICg9KSwgYW5kIFUrMDA2MCAoYCkuJyxcclxuICAgIFsxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqL106IFwiQXR0cmlidXRlIG5hbWUgY2Fubm90IHN0YXJ0IHdpdGggJz0nLlwiLFxyXG4gICAgWzIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovXTogXCInPD8nIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC5cIixcclxuICAgIFsyMCAvKiBVTkVYUEVDVEVEX05VTExfQ0hBUkFDVEVSICovXTogYFVuZXhwZWN0ZWQgbnVsbCBjaGFyYWN0ZXIuYCxcclxuICAgIFsyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xyXG4gICAgWzIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxyXG4gICAgWzI0IC8qIFhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXHJcbiAgICBbMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxyXG4gICAgWzI3IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xyXG4gICAgICAgICdOb3RlIHRoYXQgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgY2Fubm90IGNvbnRhaW4gc3BhY2VzLicsXHJcbiAgICBbMjYgLyogWF9NSVNTSU5HX0RJUkVDVElWRV9OQU1FICovXTogJ0xlZ2FsIGRpcmVjdGl2ZSBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgLy8gdHJhbnNmb3JtIGVycm9yc1xyXG4gICAgWzI4IC8qIFhfVl9JRl9OT19FWFBSRVNTSU9OICovXTogYHYtaWYvdi1lbHNlLWlmIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzI5IC8qIFhfVl9JRl9TQU1FX0tFWSAqL106IGB2LWlmL2Vsc2UgYnJhbmNoZXMgbXVzdCB1c2UgdW5pcXVlIGtleXMuYCxcclxuICAgIFszMCAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqL106IGB2LWVsc2Uvdi1lbHNlLWlmIGhhcyBubyBhZGphY2VudCB2LWlmIG9yIHYtZWxzZS1pZi5gLFxyXG4gICAgWzMxIC8qIFhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqL106IGB2LWZvciBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszMiAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtZm9yIGhhcyBpbnZhbGlkIGV4cHJlc3Npb24uYCxcclxuICAgIFszMyAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi9dOiBgPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuYCxcclxuICAgIFszNCAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNSAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqL106IGB2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzM2IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovXTogYFVuZXhwZWN0ZWQgY3VzdG9tIGRpcmVjdGl2ZSBvbiA8c2xvdD4gb3V0bGV0LmAsXHJcbiAgICBbMzcgLyogWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqL106IGBNaXhlZCB2LXNsb3QgdXNhZ2Ugb24gYm90aCB0aGUgY29tcG9uZW50IGFuZCBuZXN0ZWQgPHRlbXBsYXRlPi5gICtcclxuICAgICAgICBgV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgbmFtZWQgc2xvdHMsIGFsbCBzbG90cyBzaG91bGQgdXNlIDx0ZW1wbGF0ZT4gYCArXHJcbiAgICAgICAgYHN5bnRheCB0byBhdm9pZCBzY29wZSBhbWJpZ3VpdHkuYCxcclxuICAgIFszOCAvKiBYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqL106IGBEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gYCxcclxuICAgIFszOSAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqL106IGBFeHRyYW5lb3VzIGNoaWxkcmVuIGZvdW5kIHdoZW4gY29tcG9uZW50IGFscmVhZHkgaGFzIGV4cGxpY2l0bHkgbmFtZWQgYCArXHJcbiAgICAgICAgYGRlZmF1bHQgc2xvdC4gVGhlc2UgY2hpbGRyZW4gd2lsbCBiZSBpZ25vcmVkLmAsXHJcbiAgICBbNDAgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovXTogYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPiB0YWdzLmAsXHJcbiAgICBbNDEgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MiAvKiBYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBtZW1iZXIgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzQzIC8qIFhfVl9NT0RFTF9PTl9TQ09QRV9WQVJJQUJMRSAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuYCxcclxuICAgIFs0NCAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqL106IGBFcnJvciBwYXJzaW5nIEphdmFTY3JpcHQgZXhwcmVzc2lvbjogYCxcclxuICAgIFs0NSAvKiBYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqL106IGA8S2VlcEFsaXZlPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGNvbXBvbmVudC5gLFxyXG4gICAgLy8gZ2VuZXJpYyBlcnJvcnNcclxuICAgIFs0NiAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXHJcbiAgICBbNDcgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovXTogYEVTIG1vZHVsZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ4IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovXTogYFwiY2FjaGVIYW5kbGVyc1wiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHRoZSBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIGVuYWJsZWQuYCxcclxuICAgIFs0OSAvKiBYX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJzY29wZUlkXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIG1vZHVsZSBtb2RlLmAsXHJcbiAgICAvLyBqdXN0IHRvIGZ1bGZpbGwgdHlwZXNcclxuICAgIFs1MCAvKiBfX0VYVEVORF9QT0lOVF9fICovXTogYGBcclxufTtcblxuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcclxuY29uc3QgVEVMRVBPUlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRlbGVwb3J0YCA6IGBgKTtcclxuY29uc3QgU1VTUEVOU0UgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFN1c3BlbnNlYCA6IGBgKTtcclxuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcclxuY29uc3QgQkFTRV9UUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBCYXNlVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IE9QRU5fQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG9wZW5CbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfRUxFTUVOVF9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlRWxlbWVudEJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9FTEVNRU5UX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVFbGVtZW50Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQ29tbWVudFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TVEFUSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVN0YXRpY1ZOb2RlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRElSRUNUSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRGlyZWN0aXZlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9GSUxURVIgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVGaWx0ZXJgIDogYGApO1xyXG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcclxuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xyXG5jb25zdCBSRU5ERVJfU0xPVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xyXG5jb25zdCBUT19ESVNQTEFZX1NUUklORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9EaXNwbGF5U3RyaW5nYCA6IGBgKTtcclxuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG1lcmdlUHJvcHNgIDogYGApO1xyXG5jb25zdCBOT1JNQUxJWkVfQ0xBU1MgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZUNsYXNzYCA6IGBgKTtcclxuY29uc3QgTk9STUFMSVpFX1NUWUxFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVTdHlsZWAgOiBgYCk7XHJcbmNvbnN0IE5PUk1BTElaRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplUHJvcHNgIDogYGApO1xyXG5jb25zdCBHVUFSRF9SRUFDVElWRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgZ3VhcmRSZWFjdGl2ZVByb3BzYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcnNgIDogYGApO1xyXG5jb25zdCBDQU1FTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FtZWxpemVgIDogYGApO1xyXG5jb25zdCBDQVBJVEFMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XHJcbmNvbnN0IFNFVF9CTE9DS19UUkFDS0lORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc2V0QmxvY2tUcmFja2luZ2AgOiBgYCk7XHJcbmNvbnN0IFBVU0hfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9DVFggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhDdHhgIDogYGApO1xyXG5jb25zdCBVTlJFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdW5yZWZgIDogYGApO1xyXG5jb25zdCBJU19SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGlzUmVmYCA6IGBgKTtcclxuY29uc3QgV0lUSF9NRU1PID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoTWVtb2AgOiBgYCk7XHJcbmNvbnN0IElTX01FTU9fU0FNRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNNZW1vU2FtZWAgOiBgYCk7XHJcbi8vIE5hbWUgbWFwcGluZyBmb3IgcnVudGltZSBoZWxwZXJzIHRoYXQgbmVlZCB0byBiZSBpbXBvcnRlZCBmcm9tICd2dWUnIGluXHJcbi8vIGdlbmVyYXRlZCBjb2RlLiBNYWtlIHN1cmUgdGhlc2UgYXJlIGNvcnJlY3RseSBleHBvcnRlZCBpbiB0aGUgcnVudGltZSFcclxuLy8gVXNpbmcgYGFueWAgaGVyZSBiZWNhdXNlIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlLlxyXG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xyXG4gICAgW0ZSQUdNRU5UXTogYEZyYWdtZW50YCxcclxuICAgIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXHJcbiAgICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxyXG4gICAgW0tFRVBfQUxJVkVdOiBgS2VlcEFsaXZlYCxcclxuICAgIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcclxuICAgIFtDUkVBVEVfQkxPQ0tdOiBgY3JlYXRlQmxvY2tgLFxyXG4gICAgW0NSRUFURV9FTEVNRU5UX0JMT0NLXTogYGNyZWF0ZUVsZW1lbnRCbG9ja2AsXHJcbiAgICBbQ1JFQVRFX1ZOT0RFXTogYGNyZWF0ZVZOb2RlYCxcclxuICAgIFtDUkVBVEVfRUxFTUVOVF9WTk9ERV06IGBjcmVhdGVFbGVtZW50Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcclxuICAgIFtDUkVBVEVfU1RBVElDXTogYGNyZWF0ZVN0YXRpY1ZOb2RlYCxcclxuICAgIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RJUkVDVElWRV06IGByZXNvbHZlRGlyZWN0aXZlYCxcclxuICAgIFtSRVNPTFZFX0ZJTFRFUl06IGByZXNvbHZlRmlsdGVyYCxcclxuICAgIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxyXG4gICAgW1JFTkRFUl9MSVNUXTogYHJlbmRlckxpc3RgLFxyXG4gICAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxyXG4gICAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXHJcbiAgICBbVE9fRElTUExBWV9TVFJJTkddOiBgdG9EaXNwbGF5U3RyaW5nYCxcclxuICAgIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcclxuICAgIFtOT1JNQUxJWkVfQ0xBU1NdOiBgbm9ybWFsaXplQ2xhc3NgLFxyXG4gICAgW05PUk1BTElaRV9TVFlMRV06IGBub3JtYWxpemVTdHlsZWAsXHJcbiAgICBbTk9STUFMSVpFX1BST1BTXTogYG5vcm1hbGl6ZVByb3BzYCxcclxuICAgIFtHVUFSRF9SRUFDVElWRV9QUk9QU106IGBndWFyZFJlYWN0aXZlUHJvcHNgLFxyXG4gICAgW1RPX0hBTkRMRVJTXTogYHRvSGFuZGxlcnNgLFxyXG4gICAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcclxuICAgIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxyXG4gICAgW1RPX0hBTkRMRVJfS0VZXTogYHRvSGFuZGxlcktleWAsXHJcbiAgICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxyXG4gICAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxyXG4gICAgW1BPUF9TQ09QRV9JRF06IGBwb3BTY29wZUlkYCxcclxuICAgIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcclxuICAgIFtVTlJFRl06IGB1bnJlZmAsXHJcbiAgICBbSVNfUkVGXTogYGlzUmVmYCxcclxuICAgIFtXSVRIX01FTU9dOiBgd2l0aE1lbW9gLFxyXG4gICAgW0lTX01FTU9fU0FNRV06IGBpc01lbW9TYW1lYFxyXG59O1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVIZWxwZXJzKGhlbHBlcnMpIHtcclxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcclxuICAgICAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcclxuICAgIH0pO1xyXG59XG5cbi8vIEFTVCBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFNvbWUgZXhwcmVzc2lvbnMsIGUuZy4gc2VxdWVuY2UgYW5kIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCBhcmUgbmV2ZXJcclxuLy8gYXNzb2NpYXRlZCB3aXRoIHRlbXBsYXRlIG5vZGVzLCBzbyB0aGVpciBzb3VyY2UgbG9jYXRpb25zIGFyZSBqdXN0IGEgc3R1Yi5cclxuLy8gQ29udGFpbmVyIHR5cGVzIGxpa2UgQ29tcG91bmRFeHByZXNzaW9uIGFsc28gZG9uJ3QgbmVlZCBhIHJlYWwgbG9jYXRpb24uXHJcbmNvbnN0IGxvY1N0dWIgPSB7XHJcbiAgICBzb3VyY2U6ICcnLFxyXG4gICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICAgIGVuZDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMCAvKiBST09UICovLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGhlbHBlcnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGlzQ29tcG9uZW50ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFdJVEhfRElSRUNUSVZFUyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxMyAvKiBWTk9ERV9DQUxMICovLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGRpcmVjdGl2ZXMsXHJcbiAgICAgICAgaXNCbG9jayxcclxuICAgICAgICBkaXNhYmxlVHJhY2tpbmcsXHJcbiAgICAgICAgaXNDb21wb25lbnQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBlbGVtZW50c1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIHByb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNiAvKiBKU19QUk9QRVJUWSAqLyxcclxuICAgICAgICBsb2M6IGxvY1N0dWIsXHJcbiAgICAgICAga2V5OiBpc1N0cmluZyhrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXksIHRydWUpIDoga2V5LFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMgPSBmYWxzZSwgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyAvKiBDQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudDogaXNTdHJpbmcoY29udGVudClcclxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXHJcbiAgICAgICAgICAgIDogY29udGVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNhbGxlZSxcclxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgaXNTbG90LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGluZGV4LCB2YWx1ZSwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgaXNWTm9kZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMSAvKiBKU19CTE9DS19TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgYm9keSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVMaXRlcmFsKGVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi8sXHJcbiAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMyAvKiBKU19JRl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjQgLyogSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxlZnQsXHJcbiAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGV4cHJlc3Npb25zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGlzU3RhdGljRXhwID0gKHApID0+IHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiBwLmlzU3RhdGljO1xyXG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xyXG5mdW5jdGlvbiBpc0NvcmVDb21wb25lbnQodGFnKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdUZWxlcG9ydCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdTdXNwZW5zZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdLZWVwQWxpdmUnKSkge1xyXG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdCYXNlVHJhbnNpdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xyXG5jb25zdCBpc1NpbXBsZUlkZW50aWZpZXIgPSAobmFtZSkgPT4gIW5vbklkZW50aWZpZXJSRS50ZXN0KG5hbWUpO1xyXG5jb25zdCB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgPSAvW0EtWmEtel8kXFx4QTAtXFx1RkZGRl0vO1xyXG5jb25zdCB2YWxpZElkZW50Q2hhclJFID0gL1tcXC5cXD9cXHckXFx4QTAtXFx1RkZGRl0vO1xyXG5jb25zdCB3aGl0ZXNwYWNlUkUgPSAvXFxzK1suW11cXHMqfFxccypbLltdXFxzKy9nO1xyXG4vKipcclxuICogU2ltcGxlIGxleGVyIHRvIGNoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBtZW1iZXIgZXhwcmVzc2lvbi4gVGhpcyBpc1xyXG4gKiBsYXggYW5kIG9ubHkgY2hlY2tzIHZhbGlkaXR5IGF0IHRoZSByb290IGxldmVsIChpLmUuIGRvZXMgbm90IHZhbGlkYXRlIGV4cHNcclxuICogaW5zaWRlIHNxdWFyZSBicmFja2V0cyksIGJ1dCBpdCdzIG9rIHNpbmNlIHRoZXNlIGFyZSBvbmx5IHVzZWQgb24gdGVtcGxhdGVcclxuICogZXhwcmVzc2lvbnMgYW5kIGZhbHNlIHBvc2l0aXZlcyBhcmUgaW52YWxpZCBleHByZXNzaW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcbiAqL1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyID0gKHBhdGgpID0+IHtcclxuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlcyBhcm91bmQgLiBvciBbIGZpcnN0XHJcbiAgICBwYXRoID0gcGF0aC50cmltKCkucmVwbGFjZSh3aGl0ZXNwYWNlUkUsIHMgPT4gcy50cmltKCkpO1xyXG4gICAgbGV0IHN0YXRlID0gMCAvKiBpbk1lbWJlckV4cCAqLztcclxuICAgIGxldCBzdGF0ZVN0YWNrID0gW107XHJcbiAgICBsZXQgY3VycmVudE9wZW5CcmFja2V0Q291bnQgPSAwO1xyXG4gICAgbGV0IGN1cnJlbnRPcGVuUGFyZW5zQ291bnQgPSAwO1xyXG4gICAgbGV0IGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoYXIgPSBwYXRoLmNoYXJBdChpKTtcclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBpbk1lbWJlckV4cCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnWycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBpbkJyYWNrZXRzICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMiAvKiBpblBhcmVucyAqLztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlblBhcmVuc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGkgPT09IDAgPyB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgOiB2YWxpZElkZW50Q2hhclJFKS50ZXN0KGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBpbkJyYWNrZXRzICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIGluU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gY2hhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGBbYCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgXWApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5CcmFja2V0Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogaW5QYXJlbnMgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gJ2AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogaW5TdHJpbmcgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYChgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYClgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV4cCBlbmRzIGFzIGEgY2FsbCB0aGVuIGl0IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5QYXJlbnNDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBpblN0cmluZyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjdXJyZW50U3RyaW5nVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIWN1cnJlbnRPcGVuQnJhY2tldENvdW50ICYmICFjdXJyZW50T3BlblBhcmVuc0NvdW50O1xyXG59O1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ob2RlID0gTk9PUFxyXG4gICAgO1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyXHJcbiAgICA7XHJcbmZ1bmN0aW9uIGdldElubmVyUmFuZ2UobG9jLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgY29uc3Qgc291cmNlID0gbG9jLnNvdXJjZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICBjb25zdCBuZXdMb2MgPSB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHN0YXJ0OiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQpLFxyXG4gICAgICAgIGVuZDogbG9jLmVuZFxyXG4gICAgfTtcclxuICAgIGlmIChsZW5ndGggIT0gbnVsbCkge1xyXG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xvYztcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oZXh0ZW5kKHt9LCBwb3MpLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuLy8gYWR2YW5jZSBieSBtdXRhdGlvbiB3aXRob3V0IGNsb25pbmcgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSwgc2luY2UgdGhpc1xyXG4vLyBnZXRzIGNhbGxlZCBhIGxvdCBpbiB0aGUgcGFyc2VyXHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgbGV0IGxpbmVzQ291bnQgPSAwO1xyXG4gICAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBuZXdsaW5lIGNoYXIgY29kZSAqLykge1xyXG4gICAgICAgICAgICBsaW5lc0NvdW50Kys7XHJcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcclxuICAgIHBvcy5saW5lICs9IGxpbmVzQ291bnQ7XHJcbiAgICBwb3MuY29sdW1uID1cclxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcclxuICAgICAgICAgICAgPyBwb3MuY29sdW1uICsgbnVtYmVyT2ZDaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgIDogbnVtYmVyT2ZDaGFyYWN0ZXJzIC0gbGFzdE5ld0xpbmVQb3M7XHJcbiAgICByZXR1cm4gcG9zO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZERpcihub2RlLCBuYW1lLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgIChhbGxvd0VtcHR5IHx8IHAuZXhwKSAmJlxyXG4gICAgICAgICAgICAoaXNTdHJpbmcobmFtZSkgPyBwLm5hbWUgPT09IG5hbWUgOiBuYW1lLnRlc3QocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRQcm9wKG5vZGUsIG5hbWUsIGR5bmFtaWNPbmx5ID0gZmFsc2UsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUgJiYgKHAudmFsdWUgfHwgYWxsb3dFbXB0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgICAgIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJlxyXG4gICAgICAgICAgICBpc1N0YXRpY0FyZ09mKHAuYXJnLCBuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0aWNBcmdPZihhcmcsIG5hbWUpIHtcclxuICAgIHJldHVybiAhIShhcmcgJiYgaXNTdGF0aWNFeHAoYXJnKSAmJiBhcmcuY29udGVudCA9PT0gbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAoIXAuYXJnIHx8IC8vIHYtYmluZD1cIm9ialwiXHJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cclxuICAgICAgICAgICAgIXAuYXJnLmlzU3RhdGljKSAvLyB2LWJpbmQ6W2Zvb11cclxuICAgICk7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fCBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLztcclxufVxyXG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcclxuICAgIHJldHVybiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nsb3QnO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKTtcclxufVxyXG5mdW5jdGlvbiBpc1Nsb3RPdXRsZXQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZOb2RlSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfVk5PREUgOiBDUkVBVEVfRUxFTUVOVF9WTk9ERTtcclxufVxyXG5mdW5jdGlvbiBnZXRWTm9kZUJsb2NrSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfRUxFTUVOVF9CTE9DSztcclxufVxyXG5jb25zdCBwcm9wc0hlbHBlclNldCA9IG5ldyBTZXQoW05PUk1BTElaRV9QUk9QUywgR1VBUkRfUkVBQ1RJVkVfUFJPUFNdKTtcclxuZnVuY3Rpb24gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMsIGNhbGxQYXRoID0gW10pIHtcclxuICAgIGlmIChwcm9wcyAmJlxyXG4gICAgICAgICFpc1N0cmluZyhwcm9wcykgJiZcclxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCBjYWxsZWUgPSBwcm9wcy5jYWxsZWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjYWxsZWUpICYmIHByb3BzSGVscGVyU2V0LmhhcyhjYWxsZWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcy5hcmd1bWVudHNbMF0sIGNhbGxQYXRoLmNvbmNhdChwcm9wcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbcHJvcHMsIGNhbGxQYXRoXTtcclxufVxyXG5mdW5jdGlvbiBpbmplY3RQcm9wKG5vZGUsIHByb3AsIGNvbnRleHQpIHtcclxuICAgIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAvKipcclxuICAgICAqIDEuIG1lcmdlUHJvcHMoLi4uKVxyXG4gICAgICogMi4gdG9IYW5kbGVycyguLi4pXHJcbiAgICAgKiAzLiBub3JtYWxpemVQcm9wcyguLi4pXHJcbiAgICAgKiA0LiBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMoLi4uKSlcclxuICAgICAqXHJcbiAgICAgKiB3ZSBuZWVkIHRvIGdldCB0aGUgcmVhbCBwcm9wcyBiZWZvcmUgbm9ybWFsaXphdGlvblxyXG4gICAgICovXHJcbiAgICBsZXQgcHJvcHMgPSBub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8gPyBub2RlLnByb3BzIDogbm9kZS5hcmd1bWVudHNbMl07XHJcbiAgICBsZXQgY2FsbFBhdGggPSBbXTtcclxuICAgIGxldCBwYXJlbnRDYWxsO1xyXG4gICAgaWYgKHByb3BzICYmXHJcbiAgICAgICAgIWlzU3RyaW5nKHByb3BzKSAmJlxyXG4gICAgICAgIHByb3BzLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzKTtcclxuICAgICAgICBwcm9wcyA9IHJldFswXTtcclxuICAgICAgICBjYWxsUGF0aCA9IHJldFsxXTtcclxuICAgICAgICBwYXJlbnRDYWxsID0gY2FsbFBhdGhbY2FsbFBhdGgubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHMgPT0gbnVsbCB8fCBpc1N0cmluZyhwcm9wcykpIHtcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAvLyBtZXJnZWQgcHJvcHMuLi4gYWRkIG91cnNcclxuICAgICAgICAvLyBvbmx5IGluamVjdCBrZXkgdG8gb2JqZWN0IGxpdGVyYWwgaWYgaXQncyB0aGUgZmlyc3QgYXJndW1lbnQgc28gdGhhdFxyXG4gICAgICAgIC8vIGlmIGRvZXNuJ3Qgb3ZlcnJpZGUgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSBwcm9wcy5hcmd1bWVudHNbMF07XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhmaXJzdCkgJiYgZmlyc3QudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgZmlyc3QucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlZSA9PT0gVE9fSEFORExFUlMpIHtcclxuICAgICAgICAgICAgICAgIC8vICMyMzY2XHJcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuYXJndW1lbnRzLnVuc2hpZnQoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAhcHJvcHNXaXRoSW5qZWN0aW9uICYmIChwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGxldCBhbHJlYWR5RXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gY2hlY2sgZXhpc3Rpbmcga2V5IHRvIGF2b2lkIG92ZXJyaWRpbmcgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgICAgICAgICBhbHJlYWR5RXhpc3RzID0gcHJvcHMucHJvcGVydGllcy5zb21lKHAgPT4gcC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgcC5rZXkuY29udGVudCA9PT0gcHJvcEtleU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFscmVhZHlFeGlzdHMpIHtcclxuICAgICAgICAgICAgcHJvcHMucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBleHByZXNzaW9uLCByZXR1cm4gYSBtZXJnZWQgcmVwbGFjZW1lbnRcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICBwcm9wc1xyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBoZWxwZXIgY2FsbCwgZS5nLiBgbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSlgLFxyXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgcmV3cml0dGVuIGFzIGBub3JtYWxpemVQcm9wcyhtZXJnZVByb3BzKHsga2V5OiAwIH0sIHByb3BzKSlgLFxyXG4gICAgICAgIC8vIHRoZSBgZ3VhcmRSZWFjdGl2ZVByb3BzYCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWRcclxuICAgICAgICBpZiAocGFyZW50Q2FsbCAmJiBwYXJlbnRDYWxsLmNhbGxlZSA9PT0gR1VBUkRfUkVBQ1RJVkVfUFJPUFMpIHtcclxuICAgICAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICBpZiAocGFyZW50Q2FsbCkge1xyXG4gICAgICAgICAgICBwYXJlbnRDYWxsLmFyZ3VtZW50c1swXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUucHJvcHMgPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHBhcmVudENhbGwpIHtcclxuICAgICAgICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50c1syXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xyXG4gICAgLy8gc2VlIGlzc3VlIzQ0MjIsIHdlIG5lZWQgYWRkaW5nIGlkZW50aWZpZXIgb24gdmFsaWRBc3NldElkIGlmIHZhcmlhYmxlIGBuYW1lYCBoYXMgc3BlY2lmaWMgY2hhcmFjdGVyXHJcbiAgICByZXR1cm4gYF8ke3R5cGV9XyR7bmFtZS5yZXBsYWNlKC9bXlxcd10vZywgKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpID0+IHtcclxuICAgICAgICByZXR1cm4gc2VhcmNoVmFsdWUgPT09ICctJyA/ICdfJyA6IG5hbWUuY2hhckNvZGVBdChyZXBsYWNlVmFsdWUpLnRvU3RyaW5nKCk7XHJcbiAgICB9KX1gO1xyXG59XHJcbi8vIENoZWNrIGlmIGEgbm9kZSBjb250YWlucyBleHByZXNzaW9ucyB0aGF0IHJlZmVyZW5jZSBjdXJyZW50IGNvbnRleHQgc2NvcGUgaWRzXHJcbmZ1bmN0aW9uIGhhc1Njb3BlUmVmKG5vZGUsIGlkcykge1xyXG4gICAgaWYgKCFub2RlIHx8IE9iamVjdC5rZXlzKGlkcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGhhc1Njb3BlUmVmKHAuYXJnLCBpZHMpIHx8IGhhc1Njb3BlUmVmKHAuZXhwLCBpZHMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKGIgPT4gaGFzU2NvcGVSZWYoYiwgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLmNvbmRpdGlvbiwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICghbm9kZS5pc1N0YXRpYyAmJlxyXG4gICAgICAgICAgICAgICAgaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudCkgJiZcclxuICAgICAgICAgICAgICAgICEhaWRzW25vZGUuY29udGVudF0pO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaXNPYmplY3QoYykgJiYgaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNTY29wZVJlZihub2RlLmNvbnRlbnQsIGlkcyk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRNZW1vZWRWTm9kZUNhbGwobm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovICYmIG5vZGUuY2FsbGVlID09PSBXSVRIX01FTU8pIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5hcmd1bWVudHNbMV0ucmV0dXJucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1ha2VCbG9jayhub2RlLCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyLCBpblNTUiB9KSB7XHJcbiAgICBpZiAoIW5vZGUuaXNCbG9jaykge1xyXG4gICAgICAgIG5vZGUuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgIGhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZGVwcmVjYXRpb25EYXRhID0ge1xyXG4gICAgW1wiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFBsYXRmb3JtLW5hdGl2ZSBlbGVtZW50cyB3aXRoIFwiaXNcIiBwcm9wIHdpbGwgbm8gbG9uZ2VyIGJlIGAgK1xyXG4gICAgICAgICAgICBgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgYCArXHJcbiAgICAgICAgICAgIGBwcmVmaXhlZCB3aXRoIFwidnVlOlwiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2N1c3RvbS1lbGVtZW50cy1pbnRlcm9wLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDT01QSUxFUl9WX0JJTkRfU1lOQyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBrZXkgPT4gYC5zeW5jIG1vZGlmaWVyIGZvciB2LWJpbmQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHYtbW9kZWwgd2l0aCBgICtcclxuICAgICAgICAgICAgYGFyZ3VtZW50IGluc3RlYWQuIFxcYHYtYmluZDoke2tleX0uc3luY1xcYCBzaG91bGQgYmUgY2hhbmdlZCB0byBgICtcclxuICAgICAgICAgICAgYFxcYHYtbW9kZWw6JHtrZXl9XFxgLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtbW9kZWwuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAucHJvcCBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQgYW5kIG5vIGxvbmdlciBuZWNlc3NhcnkuIGAgK1xyXG4gICAgICAgICAgICBgVnVlIDMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCBhIGJpbmRpbmcgYXMgRE9NIHByb3BlcnR5IHdoZW4gYXBwcm9wcmlhdGUuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2LWJpbmQ9XCJvYmpcIiB1c2FnZSBpcyBub3cgb3JkZXIgc2Vuc2l0aXZlIGFuZCBiZWhhdmVzIGxpa2UgSmF2YVNjcmlwdCBgICtcclxuICAgICAgICAgICAgYG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSBgICtcclxuICAgICAgICAgICAgYHRoYXQgYXBwZWFycyBiZWZvcmUgdi1iaW5kIGluIHRoZSBjYXNlIG9mIGNvbmZsaWN0LiBgICtcclxuICAgICAgICAgICAgYFRvIHJldGFpbiAyLnggYmVoYXZpb3IsIG1vdmUgdi1iaW5kIHRvIG1ha2UgaXQgdGhlIGZpcnN0IGF0dHJpYnV0ZS4gYCArXHJcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWJpbmQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENPTVBJTEVSX1ZfT05fTkFUSVZFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LW9uLW5hdGl2ZS1tb2RpZmllci1yZW1vdmVkLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIgLyogQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2LWlmIC8gdi1mb3IgcHJlY2VkZW5jZSB3aGVuIHVzZWQgb24gdGhlIHNhbWUgZWxlbWVudCBoYXMgY2hhbmdlZCBgICtcclxuICAgICAgICAgICAgYGluIFZ1ZSAzOiB2LWlmIG5vdyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZSBhbmQgd2lsbCBubyBsb25nZXIgaGF2ZSBgICtcclxuICAgICAgICAgICAgYGFjY2VzcyB0byB2LWZvciBzY29wZSB2YXJpYWJsZXMuIEl0IGlzIGJlc3QgdG8gYXZvaWQgdGhlIGFtYmlndWl0eSBgICtcclxuICAgICAgICAgICAgYHdpdGggPHRlbXBsYXRlPiB0YWdzIG9yIHVzZSBhIGNvbXB1dGVkIHByb3BlcnR5IHRoYXQgZmlsdGVycyB2LWZvciBgICtcclxuICAgICAgICAgICAgYGRhdGEgc291cmNlLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtaWYtdi1mb3IuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYDx0ZW1wbGF0ZT4gd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXMgd2lsbCByZW5kZXIgYXMgYSBuYXRpdmUgdGVtcGxhdGUgYCArXHJcbiAgICAgICAgICAgIGBlbGVtZW50IGluc3RlYWQgb2YgaXRzIGlubmVyIGNvbnRlbnQgaW4gVnVlIDMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2lubGluZS10ZW1wbGF0ZS1hdHRyaWJ1dGUuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBmaWx0ZXJzIGhhdmUgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IGNvbnRleHQub3B0aW9uc1xyXG4gICAgICAgID8gY29udGV4dC5vcHRpb25zLmNvbXBhdENvbmZpZ1xyXG4gICAgICAgIDogY29udGV4dC5jb21wYXRDb25maWc7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZyAmJiBjb25maWdba2V5XTtcclxuICAgIGlmIChrZXkgPT09ICdNT0RFJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCAzOyAvLyBjb21waWxlciBkZWZhdWx0cyB0byB2MyBiZWhhdmlvclxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG1vZGUgPSBnZXRDb21wYXRWYWx1ZSgnTU9ERScsIGNvbnRleHQpO1xyXG4gICAgY29uc3QgdmFsdWUgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xyXG4gICAgLy8gaW4gdjMgbW9kZSwgb25seSBlbmFibGUgaWYgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZVxyXG4gICAgLy8gb3RoZXJ3aXNlIGVuYWJsZSBmb3IgYW55IG5vbi1mYWxzZSB2YWx1ZVxyXG4gICAgcmV0dXJuIG1vZGUgPT09IDMgPyB2YWx1ZSA9PT0gdHJ1ZSA6IHZhbHVlICE9PSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0KTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZW5hYmxlZCkge1xyXG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5hYmxlZDtcclxufVxyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHZhbCA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XHJcbiAgICBpZiAodmFsID09PSAnc3VwcHJlc3Mtd2FybmluZycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xyXG4gICAgY29uc3QgbXNnID0gYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKC4uLmFyZ3MpIDogbWVzc2FnZX0ke2xpbmsgPyBgXFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWA7XHJcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IobXNnKTtcclxuICAgIGVyci5jb2RlID0ga2V5O1xyXG4gICAgaWYgKGxvYylcclxuICAgICAgICBlcnIubG9jID0gbG9jO1xyXG4gICAgY29udGV4dC5vbldhcm4oZXJyKTtcclxufVxuXG4vLyBUaGUgZGVmYXVsdCBkZWNvZGVyIG9ubHkgcHJvdmlkZXMgZXNjYXBlcyBmb3IgY2hhcmFjdGVycyByZXNlcnZlZCBhcyBwYXJ0IG9mXHJcbi8vIHRoZSB0ZW1wbGF0ZSBzeW50YXgsIGFuZCBpcyBvbmx5IHVzZWQgaWYgdGhlIGN1c3RvbSByZW5kZXJlciBkaWQgbm90IHByb3ZpZGVcclxuLy8gYSBwbGF0Zm9ybS1zcGVjaWZpYyBkZWNvZGVyLlxyXG5jb25zdCBkZWNvZGVSRSA9IC8mKGd0fGx0fGFtcHxhcG9zfHF1b3QpOy9nO1xyXG5jb25zdCBkZWNvZGVNYXAgPSB7XHJcbiAgICBndDogJz4nLFxyXG4gICAgbHQ6ICc8JyxcclxuICAgIGFtcDogJyYnLFxyXG4gICAgYXBvczogXCInXCIsXHJcbiAgICBxdW90OiAnXCInXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRQYXJzZXJPcHRpb25zID0ge1xyXG4gICAgZGVsaW1pdGVyczogW2B7e2AsIGB9fWBdLFxyXG4gICAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwIC8qIEhUTUwgKi8sXHJcbiAgICBnZXRUZXh0TW9kZTogKCkgPT4gMCAvKiBEQVRBICovLFxyXG4gICAgaXNWb2lkVGFnOiBOTyxcclxuICAgIGlzUHJlVGFnOiBOTyxcclxuICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXHJcbiAgICBkZWNvZGVFbnRpdGllczogKHJhd1RleHQpID0+IHJhd1RleHQucmVwbGFjZShkZWNvZGVSRSwgKF8sIHAxKSA9PiBkZWNvZGVNYXBbcDFdKSxcclxuICAgIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxyXG4gICAgb25XYXJuOiBkZWZhdWx0T25XYXJuLFxyXG4gICAgY29tbWVudHM6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG59O1xyXG5mdW5jdGlvbiBiYXNlUGFyc2UoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJvb3QocGFyc2VDaGlsZHJlbihjb250ZXh0LCAwIC8qIERBVEEgKi8sIFtdKSwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCByYXdPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyc2VyT3B0aW9ucyk7XHJcbiAgICBsZXQga2V5O1xyXG4gICAgZm9yIChrZXkgaW4gcmF3T3B0aW9ucykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBvcHRpb25zW2tleV0gPVxyXG4gICAgICAgICAgICByYXdPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0UGFyc2VyT3B0aW9uc1trZXldXHJcbiAgICAgICAgICAgICAgICA6IHJhd09wdGlvbnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIGluUHJlOiBmYWxzZSxcclxuICAgICAgICBpblZQcmU6IGZhbHNlLFxyXG4gICAgICAgIG9uV2Fybjogb3B0aW9ucy5vbldhcm5cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgIHdoaWxlICghaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovIHx8IG1vZGUgPT09IDEgLyogUkNEQVRBICovKSB7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChzLCBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVyc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vICd7eydcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICchJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNtYXJrdXAtZGVjbGFyYXRpb24tb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIERPQ1RZUEUgYnkgYSBsaW1pdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhW0NEQVRBWycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucyAhPT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIElOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlbmQtdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMl0gPT09ICc+Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogRW5kICovLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDIueCA8dGVtcGxhdGU+IHdpdGggbm8gZGlyZWN0aXZlIGNvbXBhdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi8sIGNvbnRleHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWcgPT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0LCBub2RlLmxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXaGl0ZXNwYWNlIGhhbmRsaW5nIHN0cmF0ZWd5IGxpa2UgdjJcclxuICAgIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gICAgaWYgKG1vZGUgIT09IDIgLyogUkFXVEVYVCAqLyAmJiBtb2RlICE9PSAxIC8qIFJDREFUQSAqLykge1xyXG4gICAgICAgIGNvbnN0IHNob3VsZENvbmRlbnNlID0gY29udGV4dC5vcHRpb25zLndoaXRlc3BhY2UgIT09ICdwcmVzZXJ2ZSc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblByZSAmJiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEvW15cXHRcXHJcXG5cXGYgXS8udGVzdChub2RlLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIHRoZSBmaXJzdCBvciBsYXN0IG5vZGUsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGFkamFjZW50IHRvIGEgY29tbWVudCwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d28gZWxlbWVudHMgQU5EIGNvbnRhaW5zIG5ld2xpbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5leHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNob3VsZENvbmRlbnNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvW1xcclxcbl0vLnRlc3Qobm9kZS5jb250ZW50KSkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHdoaXRlc3BhY2UgaXMgY29uZGVuc2VkIGludG8gYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZENvbmRlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW4gdGV4dCBhcmUgY29uZGVuc2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0byBhIHNpbmdsZSBzcGFjZS5cclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgvW1xcdFxcclxcblxcZiBdKy9nLCAnICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb21tZW50IG5vZGVzIGlmIGRlc2lyZWQgYnkgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gJiYgIWNvbnRleHQub3B0aW9ucy5jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0LmluUHJlICYmIHBhcmVudCAmJiBjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcocGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgbmV3bGluZSBwZXIgaHRtbCBzcGVjXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2dyb3VwaW5nLWNvbnRlbnQuaHRtbCN0aGUtcHJlLWVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBub2Rlc1swXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0LmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZFdoaXRlc3BhY2UgPyBub2Rlcy5maWx0ZXIoQm9vbGVhbikgOiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwdXNoTm9kZShub2Rlcywgbm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgY29uc3QgcHJldiA9IGxhc3Qobm9kZXMpO1xyXG4gICAgICAgIC8vIE1lcmdlIGlmIGJvdGggdGhpcyBhbmQgdGhlIHByZXZpb3VzIG5vZGUgYXJlIHRleHQgYW5kIHRob3NlIGFyZVxyXG4gICAgICAgIC8vIGNvbnNlY3V0aXZlLiBUaGlzIGhhcHBlbnMgZm9yIGNhc2VzIGxpa2UgXCJhIDwgYlwiLlxyXG4gICAgICAgIGlmIChwcmV2ICYmXHJcbiAgICAgICAgICAgIHByZXYudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgIHByZXYubG9jLmVuZC5vZmZzZXQgPT09IG5vZGUubG9jLnN0YXJ0Lm9mZnNldCkge1xyXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnQgKz0gbm9kZS5jb250ZW50O1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQgPSBub2RlLmxvYy5lbmQ7XHJcbiAgICAgICAgICAgIHByZXYubG9jLnNvdXJjZSArPSBub2RlLmxvYy5zb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgOSk7XHJcbiAgICBjb25zdCBub2RlcyA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMyAvKiBDREFUQSAqLywgYW5jZXN0b3JzKTtcclxuICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNiAvKiBFT0ZfSU5fQ0RBVEEgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ29tbWVudChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgLy8gUmVndWxhciBjb21tZW50LlxyXG4gICAgY29uc3QgbWF0Y2ggPSAvLS0oXFwhKT8+Ly5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDcgLyogRU9GX0lOX0NPTU1FTlQgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG1hdGNoLmluZGV4IDw9IDMpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIC8vIEFkdmFuY2luZyB3aXRoIHJlcG9ydGluZyBuZXN0ZWQgY29tbWVudHMuXHJcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICBsZXQgcHJldkluZGV4ID0gMSwgbmVzdGVkSW5kZXggPSAwO1xyXG4gICAgICAgIHdoaWxlICgobmVzdGVkSW5kZXggPSBzLmluZGV4T2YoJzwhLS0nLCBwcmV2SW5kZXgpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5lc3RlZEluZGV4IC0gcHJldkluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChuZXN0ZWRJbmRleCArIDQgPCBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE2IC8qIE5FU1RFRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2SW5kZXggPSBuZXN0ZWRJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjb250ZW50U3RhcnQgPSBjb250ZXh0LnNvdXJjZVsxXSA9PT0gJz8nID8gMSA6IDI7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKCc+Jyk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQsIGNsb3NlSW5kZXgpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZUluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDMgLyogQ09NTUVOVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICAvLyBTdGFydCB0YWcuXHJcbiAgICBjb25zdCB3YXNJblByZSA9IGNvbnRleHQuaW5QcmU7XHJcbiAgICBjb25zdCB3YXNJblZQcmUgPSBjb250ZXh0LmluVlByZTtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZVRhZyhjb250ZXh0LCAwIC8qIFN0YXJ0ICovLCBwYXJlbnQpO1xyXG4gICAgY29uc3QgaXNQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5QcmUgJiYgIXdhc0luUHJlO1xyXG4gICAgY29uc3QgaXNWUHJlQm91bmRhcnkgPSBjb250ZXh0LmluVlByZSAmJiAhd2FzSW5WUHJlO1xyXG4gICAgaWYgKGVsZW1lbnQuaXNTZWxmQ2xvc2luZyB8fCBjb250ZXh0Lm9wdGlvbnMuaXNWb2lkVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIC8vICM0MDMwIHNlbGYtY2xvc2luZyA8cHJlPiB0YWdcclxuICAgICAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmluUHJlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmluVlByZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIENoaWxkcmVuLlxyXG4gICAgYW5jZXN0b3JzLnB1c2goZWxlbWVudCk7XHJcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5vcHRpb25zLmdldFRleHRNb2RlKGVsZW1lbnQsIHBhcmVudCk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKTtcclxuICAgIGFuY2VzdG9ycy5wb3AoKTtcclxuICAgIC8vIDIueCBpbmxpbmUtdGVtcGxhdGUgY29tcGF0XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gZWxlbWVudC5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdpbmxpbmUtdGVtcGxhdGUnKTtcclxuICAgICAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmXHJcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqLywgY29udGV4dCwgaW5saW5lVGVtcGxhdGVQcm9wLmxvYykpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLmVuZCk7XHJcbiAgICAgICAgICAgIGlubGluZVRlbXBsYXRlUHJvcC52YWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvYy5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAvLyBFbmQgdGFnLlxyXG4gICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKGNvbnRleHQuc291cmNlLCBlbGVtZW50LnRhZykpIHtcclxuICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqLywgMCwgZWxlbWVudC5sb2Muc3RhcnQpO1xyXG4gICAgICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDAgJiYgZWxlbWVudC50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHN0YXJ0c1dpdGgoZmlyc3QubG9jLnNvdXJjZSwgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDggLyogRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsZW1lbnQubG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmNvbnN0IGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcclxuZnVuY3Rpb24gcGFyc2VUYWcoY29udGV4dCwgdHlwZSwgcGFyZW50KSB7XHJcbiAgICAvLyBUYWcgb3Blbi5cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXjxcXC8/KFthLXpdW15cXHRcXHJcXG5cXGYgLz5dKikvaS5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdO1xyXG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXHJcbiAgICBjb25zdCBjdXJzb3IgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjdXJyZW50U291cmNlID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAvLyBjaGVjayA8cHJlPiB0YWdcclxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcodGFnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcy5cclxuICAgIGxldCBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKTtcclxuICAgIC8vIGNoZWNrIHYtcHJlXHJcbiAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLyAmJlxyXG4gICAgICAgICFjb250ZXh0LmluVlByZSAmJlxyXG4gICAgICAgIHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlc2V0IGNvbnRleHRcclxuICAgICAgICBleHRlbmQoY29udGV4dCwgY3Vyc29yKTtcclxuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XHJcbiAgICAgICAgLy8gcmUtcGFyc2UgYXR0cnMgYW5kIGZpbHRlciBvdXQgdi1wcmUgaXRzZWxmXHJcbiAgICAgICAgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkuZmlsdGVyKHAgPT4gcC5uYW1lICE9PSAndi1wcmUnKTtcclxuICAgIH1cclxuICAgIC8vIFRhZyBjbG9zZS5cclxuICAgIGxldCBpc1NlbGZDbG9zaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDkgLyogRU9GX0lOX1RBRyAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgaXNTZWxmQ2xvc2luZyA/IDIgOiAxKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIDIueCBkZXByZWNhdGlvbiBjaGVja3NcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgbGV0IGhhc0lmID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0lmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2ZvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNJZiAmJiBoYXNGb3IpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqLywgY29udGV4dCwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCB0YWdUeXBlID0gMCAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSkge1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMiAvKiBTTE9UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0YWdUeXBlID0gMyAvKiBURU1QTEFURSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NvbXBvbmVudCh0YWcsIHByb3BzLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxIC8qIEVMRU1FTlQgKi8sXHJcbiAgICAgICAgbnMsXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHRhZ1R5cGUsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyxcclxuICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQgLy8gdG8gYmUgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50KHRhZywgcHJvcHMsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQodGFnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdjb21wb25lbnQnIHx8XHJcbiAgICAgICAgL15bQS1aXS8udGVzdCh0YWcpIHx8XHJcbiAgICAgICAgaXNDb3JlQ29tcG9uZW50KHRhZykgfHxcclxuICAgICAgICAob3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQgJiYgb3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQodGFnKSkgfHxcclxuICAgICAgICAob3B0aW9ucy5pc05hdGl2ZVRhZyAmJiAhb3B0aW9ucy5pc05hdGl2ZVRhZyh0YWcpKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgdGFnIHNob3VsZCBiZSBhIG5hdGl2ZSB0YWcsIGJ1dCBjaGVjayBmb3IgcG90ZW50aWFsIFwiaXNcIlxyXG4gICAgLy8gY2FzdGluZ1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnaXMnICYmIHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICAvLyB2LWlzIChUT0RPIERlcHJlY2F0ZSlcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIC8vIDppcyBvbiBwbGFpbiBlbGVtZW50IC0gb25seSB0cmVhdCBhcyBjb21wb25lbnQgaW4gY29tcGF0IG1vZGVcclxuICAgICAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsICdpcycpICYmXHJcbiAgICAgICAgICAgICAgICB0cnVlICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBbXTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJz4nKSAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKSkge1xyXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAzIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcclxuICAgICAgICAvLyBUcmltIHdoaXRlc3BhY2UgYmV0d2VlbiBjbGFzc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb3JlL2lzc3Vlcy80MjUxXHJcbiAgICAgICAgaWYgKGF0dHIudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgYXR0ci52YWx1ZSAmJlxyXG4gICAgICAgICAgICBhdHRyLm5hbWUgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgYXR0ci52YWx1ZS5jb250ZW50ID0gYXR0ci52YWx1ZS5jb250ZW50LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFN0YXJ0ICovKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlteXFx0XFxyXFxuXFxmIC8+XS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIG5hbWVTZXQpIHtcclxuICAgIC8vIE5hbWUuXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiAvPl1bXlxcdFxcclxcblxcZiAvPj1dKi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XHJcbiAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovKTtcclxuICAgIH1cclxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xyXG4gICAgaWYgKG5hbWVbMF0gPT09ICc9Jykge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IC9bXCInPF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcclxuICAgIC8vIFZhbHVlXHJcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KTtcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi1bQS1aYS16MC05LV18OnxcXC58QHwjKS8udGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyg/Ol52LShbYS16MC05LV0rKSk/KD86KD86OnxeXFwufF5AfF4jKShcXFtbXlxcXV0rXFxdfFteXFwuXSspKT8oLispPyQvaS5leGVjKG5hbWUpO1xyXG4gICAgICAgIGxldCBpc1Byb3BTaG9ydGhhbmQgPSBzdGFydHNXaXRoKG5hbWUsICcuJyk7XHJcbiAgICAgICAgbGV0IGRpck5hbWUgPSBtYXRjaFsxXSB8fFxyXG4gICAgICAgICAgICAoaXNQcm9wU2hvcnRoYW5kIHx8IHN0YXJ0c1dpdGgobmFtZSwgJzonKVxyXG4gICAgICAgICAgICAgICAgPyAnYmluZCdcclxuICAgICAgICAgICAgICAgIDogc3RhcnRzV2l0aChuYW1lLCAnQCcpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnb24nXHJcbiAgICAgICAgICAgICAgICAgICAgOiAnc2xvdCcpO1xyXG4gICAgICAgIGxldCBhcmc7XHJcbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2xvdCA9IGRpck5hbWUgPT09ICdzbG90JztcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmxhc3RJbmRleE9mKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCksIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCArIG1hdGNoWzJdLmxlbmd0aCArICgoaXNTbG90ICYmIG1hdGNoWzNdKSB8fCAnJykubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI3IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSwgY29udGVudC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vICMxMjQxIHNwZWNpYWwgY2FzZSBmb3Igdi1zbG90OiB2dWV0aWZ5IHJlbGllcyBleHRlbnNpdmVseSBvbiBzbG90XHJcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyBjb250YWluaW5nIGRvdHMuIHYtc2xvdCBkb2Vzbid0IGhhdmUgYW55IG1vZGlmaWVycyBhbmQgVnVlIDIueFxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydHMgc3VjaCB1c2FnZSBzbyB3ZSBhcmUga2VlcGluZyBpdCBjb25zaXN0ZW50IHdpdGggMi54LlxyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBtYXRjaFszXSB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpY1xyXG4gICAgICAgICAgICAgICAgICAgID8gMyAvKiBDQU5fU1RSSU5HSUZZICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgICAgIGxvY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNRdW90ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVMb2MgPSB2YWx1ZS5sb2M7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0Lm9mZnNldCsrO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5jb2x1bW4rKztcclxuICAgICAgICAgICAgdmFsdWVMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHZhbHVlTG9jLnN0YXJ0LCB2YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgdmFsdWVMb2Muc291cmNlID0gdmFsdWVMb2Muc291cmNlLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gbWF0Y2hbM10gPyBtYXRjaFszXS5zbGljZSgxKS5zcGxpdCgnLicpIDogW107XHJcbiAgICAgICAgaWYgKGlzUHJvcFNob3J0aGFuZClcclxuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3Byb3AnKTtcclxuICAgICAgICAvLyAyLnggY29tcGF0IHYtYmluZDpmb28uc3luYyAtPiB2LW1vZGVsOmZvb1xyXG4gICAgICAgIGlmIChkaXJOYW1lID09PSAnYmluZCcgJiYgYXJnKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3N5bmMnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDT01QSUxFUl9WX0JJTkRfU1lOQyAqLywgY29udGV4dCwgbG9jLCBhcmcubG9jLnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIGRpck5hbWUgPSAnbW9kZWwnO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnNwbGljZShtb2RpZmllcnMuaW5kZXhPZignc3luYycpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGlmaWVycy5pbmNsdWRlcygncHJvcCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovLCBjb250ZXh0LCBsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxyXG4gICAgICAgICAgICBleHA6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdmFsdWVzIGJ5IGB0cmFuc2Zvcm1FeHByZXNzaW9uYCB0byBtYWtlIGl0IGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVycyxcclxuICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIG1pc3NpbmcgZGlyZWN0aXZlIG5hbWUgb3IgaWxsZWdhbCBkaXJlY3RpdmUgbmFtZVxyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiBzdGFydHNXaXRoKG5hbWUsICd2LScpKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI2IC8qIFhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDYgLyogQVRUUklCVVRFICovLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IHF1b3RlID0gY29udGV4dC5zb3VyY2VbMF07XHJcbiAgICBjb25zdCBpc1F1b3RlZCA9IHF1b3RlID09PSBgXCJgIHx8IHF1b3RlID09PSBgJ2A7XHJcbiAgICBpZiAoaXNRdW90ZWQpIHtcclxuICAgICAgICAvLyBRdW90ZWQgdmFsdWUuXHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBVbnF1b3RlZFxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiA+XSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5leHBlY3RlZENoYXJzID0gL1tcIic8PWBdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gdW5leHBlY3RlZENoYXJzLmV4ZWMobWF0Y2hbMF0pKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTggLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovLCBtLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGNsb3NlLCBvcGVuLmxlbmd0aCk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5uZXJTdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGlubmVyRW5kID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCByYXdDb250ZW50TGVuZ3RoKTtcclxuICAgIGNvbnN0IHByZVRyaW1Db250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCByYXdDb250ZW50TGVuZ3RoLCBtb2RlKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XHJcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IHByZVRyaW1Db250ZW50LmluZGV4T2YoY29udGVudCk7XHJcbiAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhd0NvbnRlbnRMZW5ndGggLSAocHJlVHJpbUNvbnRlbnQubGVuZ3RoIC0gY29udGVudC5sZW5ndGggLSBzdGFydE9mZnNldCk7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2UubGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cclxuICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgaW5uZXJTdGFydCwgaW5uZXJFbmQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IGVuZFRva2VucyA9IG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gPyBbJ11dPiddIDogWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xyXG4gICAgbGV0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRUb2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGVuZEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICogVGhpcyB0cmFuc2xhdGVzIEhUTUwgZW50aXRpZXMgaW4gdGhlIHRleHQgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XHJcbiAgICBjb25zdCByYXdUZXh0ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBsZW5ndGgpO1xyXG4gICAgaWYgKG1vZGUgPT09IDIgLyogUkFXVEVYVCAqLyB8fFxyXG4gICAgICAgIG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gfHxcclxuICAgICAgICAhcmF3VGV4dC5pbmNsdWRlcygnJicpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1RleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEQVRBIG9yIFJDREFUQSBjb250YWluaW5nIFwiJlwiXCIuIEVudGl0eSBkZWNvZGluZyByZXF1aXJlZC5cclxuICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLmRlY29kZUVudGl0aWVzKHJhd1RleHQsIG1vZGUgPT09IDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDdXJzb3IoY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGVuZCA9IGVuZCB8fCBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVuZCxcclxuICAgICAgICBzb3VyY2U6IGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsYXN0KHhzKSB7XHJcbiAgICByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzb3VyY2UsIHNlYXJjaFN0cmluZykge1xyXG4gICAgcmV0dXJuIHNvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZUJ5KGNvbnRleHQsIG51bWJlck9mQ2hhcmFjdGVycykge1xyXG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IGNvbnRleHQ7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oY29udGV4dCwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG4gICAgY29udGV4dC5zb3VyY2UgPSBzb3VyY2Uuc2xpY2UobnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlU3BhY2VzKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXFx0XFxyXFxuXFxmIF0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUoc3RhcnQsIGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBudW1iZXJPZkNoYXJhY3RlcnMpLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGVtaXRFcnJvcihjb250ZXh0LCBjb2RlLCBvZmZzZXQsIGxvYyA9IGdldEN1cnNvcihjb250ZXh0KSkge1xyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICAgIGxvYy5vZmZzZXQgKz0gb2Zmc2V0O1xyXG4gICAgICAgIGxvYy5jb2x1bW4gKz0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5vcHRpb25zLm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCB7XHJcbiAgICAgICAgc3RhcnQ6IGxvYyxcclxuICAgICAgICBlbmQ6IGxvYyxcclxuICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XHJcbiAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJzwvJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb2JhYmx5IGJhZCBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3BlbihzLCBhbmNlc3RvcnNbaV0udGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxIC8qIFJDREFUQSAqLzpcclxuICAgICAgICBjYXNlIDIgLyogUkFXVEVYVCAqLzoge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgcGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDMgLyogQ0RBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICddXT4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIXM7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aEVuZFRhZ09wZW4oc291cmNlLCB0YWcpIHtcclxuICAgIHJldHVybiAoc3RhcnRzV2l0aChzb3VyY2UsICc8LycpICYmXHJcbiAgICAgICAgc291cmNlLnNsaWNlKDIsIDIgKyB0YWcubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgIC9bXFx0XFxyXFxuXFxmIC8+XS8udGVzdChzb3VyY2VbMiArIHRhZy5sZW5ndGhdIHx8ICc+JykpO1xyXG59XG5cbmZ1bmN0aW9uIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpIHtcclxuICAgIHdhbGsocm9vdCwgY29udGV4dCwgXHJcbiAgICAvLyBSb290IG5vZGUgaXMgdW5mb3J0dW5hdGVseSBub24taG9pc3RhYmxlIGR1ZSB0byBwb3RlbnRpYWwgcGFyZW50XHJcbiAgICAvLyBmYWxsdGhyb3VnaCBhdHRyaWJ1dGVzLlxyXG4gICAgaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCByb290LmNoaWxkcmVuWzBdKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgIWlzU2xvdE91dGxldChjaGlsZCkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhbGsobm9kZSwgY29udGV4dCwgZG9Ob3RIb2lzdE5vZGUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICAgIGNvbnN0IG9yaWdpbmFsQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICBsZXQgaG9pc3RlZENvdW50ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIG9ubHkgcGxhaW4gZWxlbWVudHMgJiB0ZXh0IGNhbGxzIGFyZSBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICBjaGlsZC50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGVcclxuICAgICAgICAgICAgICAgID8gMCAvKiBOT1RfQ09OU1RBTlQgKi9cclxuICAgICAgICAgICAgICAgIDogZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID49IDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLTEgLyogSE9JU1RFRCAqLyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qIEhPSVNURUQgKi9gIDogYGApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlID0gY29udGV4dC5ob2lzdChjaGlsZC5jb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBjb250YWluIGR5bmFtaWMgY2hpbGRyZW4sIGJ1dCBpdHMgcHJvcHMgbWF5IGJlIGVsaWdpYmxlIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFmbGFnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDUxMiAvKiBORUVEX1BBVENIICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDEgLyogVEVYVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUucHJvcHMgPSBjb250ZXh0LmhvaXN0KHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyA9IGNvbnRleHQuaG9pc3QoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTIgLyogVEVYVF9DQUxMICovICYmXHJcbiAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZC5jb250ZW50LCBjb250ZXh0KSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICBob2lzdGVkQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FsayBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBvbmVudCA9IGNoaWxkLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtZm9yIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtaWYgc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaG9pc3RlZENvdW50ICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcclxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KGNoaWxkcmVuLCBjb250ZXh0LCBub2RlKTtcclxuICAgIH1cclxuICAgIC8vIGFsbCBjaGlsZHJlbiB3ZXJlIGhvaXN0ZWQgLSB0aGUgZW50aXJlIGNoaWxkcmVuIGFycmF5IGlzIGhvaXN0YWJsZS5cclxuICAgIGlmIChob2lzdGVkQ291bnQgJiZcclxuICAgICAgICBob2lzdGVkQ291bnQgPT09IG9yaWdpbmFsQ291bnQgJiZcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSAmJlxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLyAmJlxyXG4gICAgICAgIGlzQXJyYXkobm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuID0gY29udGV4dC5ob2lzdChjcmVhdGVBcnJheUV4cHJlc3Npb24obm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjb25zdGFudENhY2hlLmdldChub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS50YWcgIT09ICdzdmcnICYmXHJcbiAgICAgICAgICAgICAgICBub2RlLnRhZyAhPT0gJ2ZvcmVpZ25PYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRXZlbiBmb3IgYSBub2RlIHdpdGggbm8gcGF0Y2ggZmxhZywgaXQgaXMgcG9zc2libGUgZm9yIGl0IHRvIGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIG5vbi1ob2lzdGFibGUgZXhwcmVzc2lvbnMgdGhhdCByZWZlcnMgdG8gc2NvcGUgdmFyaWFibGVzLCBlLmcuIGNvbXBpbGVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgY29kZWdlbk5vZGUncyBwcm9wcyB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvcHNUeXBlID0gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxyXG4gICAgICAgICAgICAgICAgLy8gdHlwZSwgY2hlY2sgaWYgYW55IG9mIHRoZSBwcm9wcyBjYW4gY2F1c2UgdGhlIHR5cGUgdG8gYmUgbG93ZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgY2FuX3BhdGNoIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGFcclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UeXBlID4gMSAvKiBDQU5fU0tJUF9QQVRDSCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnYmluZCcgJiYgcC5leHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBleHBUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBzdmcvZm9yZWlnbk9iamVjdCBjb3VsZCBiZSBibG9jayBoZXJlLCBob3dldmVyIGlmIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgdGhlbiB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYmxvY2tzIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm9cclxuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSB8fCBpc1N5bWJvbChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGFsbG93SG9pc3RlZEhlbHBlclNldCA9IG5ldyBTZXQoW1xyXG4gICAgTk9STUFMSVpFX0NMQVNTLFxyXG4gICAgTk9STUFMSVpFX1NUWUxFLFxyXG4gICAgTk9STUFMSVpFX1BST1BTLFxyXG4gICAgR1VBUkRfUkVBQ1RJVkVfUFJPUFNcclxuXSk7XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbCh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICFpc1N0cmluZyh2YWx1ZS5jYWxsZWUpICYmXHJcbiAgICAgICAgYWxsb3dIb2lzdGVkSGVscGVyU2V0Lmhhcyh2YWx1ZS5jYWxsZWUpKSB7XHJcbiAgICAgICAgY29uc3QgYXJnID0gdmFsdWUuYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgbmVzdGVkIGhlbHBlciBjYWxsLCBlLmcuIGBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMoZXhwKSlgXHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwoYXJnLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbn1cclxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhub2RlKTtcclxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gcHJvcHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qga2V5VHlwZSA9IGdldENvbnN0YW50VHlwZShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGtleVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZhbHVlVHlwZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzb21lIGhlbHBlciBjYWxscyBjYW4gYmUgaG9pc3RlZCxcclxuICAgICAgICAgICAgICAgIC8vIHN1Y2ggYXMgdGhlIGBub3JtYWxpemVQcm9wc2AgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBmb3IgcHJlLW5vcm1hbGl6ZSBjbGFzcyxcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIHJlc3BlY3QgdGhlIENvbnN0YW50VHlwZSBvZiB0aGUgaGVscGVyJ3MgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xyXG4gICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICByZXR1cm4gY29kZWdlbk5vZGUucHJvcHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGF0Y2hGbGFnKG5vZGUpIHtcclxuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcclxuICAgIHJldHVybiBmbGFnID8gcGFyc2VJbnQoZmxhZywgMTApIDogdW5kZWZpbmVkO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgeyBmaWxlbmFtZSA9ICcnLCBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLCBob2lzdFN0YXRpYyA9IGZhbHNlLCBjYWNoZUhhbmRsZXJzID0gZmFsc2UsIG5vZGVUcmFuc2Zvcm1zID0gW10sIGRpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7fSwgdHJhbnNmb3JtSG9pc3QgPSBudWxsLCBpc0J1aWx0SW5Db21wb25lbnQgPSBOT09QLCBpc0N1c3RvbUVsZW1lbnQgPSBOT09QLCBleHByZXNzaW9uUGx1Z2lucyA9IFtdLCBzY29wZUlkID0gbnVsbCwgc2xvdHRlZCA9IHRydWUsIHNzciA9IGZhbHNlLCBpblNTUiA9IGZhbHNlLCBzc3JDc3NWYXJzID0gYGAsIGJpbmRpbmdNZXRhZGF0YSA9IEVNUFRZX09CSiwgaW5saW5lID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLCBvbldhcm4gPSBkZWZhdWx0T25XYXJuLCBjb21wYXRDb25maWcgfSkge1xyXG4gICAgY29uc3QgbmFtZU1hdGNoID0gZmlsZW5hbWUucmVwbGFjZSgvXFw/LiokLywgJycpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICBzZWxmTmFtZTogbmFtZU1hdGNoICYmIGNhcGl0YWxpemUoY2FtZWxpemUkMShuYW1lTWF0Y2hbMV0pKSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBob2lzdFN0YXRpYyxcclxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXHJcbiAgICAgICAgaXNCdWlsdEluQ29tcG9uZW50LFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcclxuICAgICAgICBzY29wZUlkLFxyXG4gICAgICAgIHNsb3R0ZWQsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIGluU1NSLFxyXG4gICAgICAgIHNzckNzc1ZhcnMsXHJcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxyXG4gICAgICAgIGlubGluZSxcclxuICAgICAgICBpc1RTLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgb25XYXJuLFxyXG4gICAgICAgIGNvbXBhdENvbmZpZyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIHJvb3QsXHJcbiAgICAgICAgaGVscGVyczogbmV3IE1hcCgpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgaG9pc3RzOiBbXSxcclxuICAgICAgICBpbXBvcnRzOiBbXSxcclxuICAgICAgICBjb25zdGFudENhY2hlOiBuZXcgTWFwKCksXHJcbiAgICAgICAgdGVtcHM6IDAsXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIGlkZW50aWZpZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIHNjb3Blczoge1xyXG4gICAgICAgICAgICB2Rm9yOiAwLFxyXG4gICAgICAgICAgICB2U2xvdDogMCxcclxuICAgICAgICAgICAgdlByZTogMCxcclxuICAgICAgICAgICAgdk9uY2U6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcclxuICAgICAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgICAgIGluVk9uY2U6IGZhbHNlLFxyXG4gICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICBoZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSkgfHwgMDtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjb3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuc2V0KG5hbWUsIGN1cnJlbnRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZhbEluZGV4ID0gbm9kZVxyXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcclxuICAgICAgICAgICAgICAgIDogY29udGV4dC5jdXJyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5jaGlsZEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWJsaW5nIG5vZGUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuLnNwbGljZShyZW1vdmFsSW5kZXgsIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Ob2RlUmVtb3ZlZDogKCkgPT4geyB9LFxyXG4gICAgICAgIGFkZElkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob2lzdChleHApIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV4cCkpXHJcbiAgICAgICAgICAgICAgICBleHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV4cCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENBTl9IT0lTVCAqLyk7XHJcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGNvbnRleHQuY2FjaGVkKyssIGV4cCwgaXNWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgb3B0aW9ucyk7XHJcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XHJcbiAgICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xyXG4gICAgICAgIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zLnNzcikge1xyXG4gICAgICAgIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZmluYWxpemUgbWV0YSBpbmZvcm1hdGlvblxyXG4gICAgcm9vdC5oZWxwZXJzID0gWy4uLmNvbnRleHQuaGVscGVycy5rZXlzKCldO1xyXG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XHJcbiAgICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcclxuICAgIHJvb3QuaW1wb3J0cyA9IGNvbnRleHQuaW1wb3J0cztcclxuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XHJcbiAgICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcclxuICAgIHJvb3QuY2FjaGVkID0gY29udGV4dC5jYWNoZWQ7XHJcbiAgICB7XHJcbiAgICAgICAgcm9vdC5maWx0ZXJzID0gWy4uLmNvbnRleHQuZmlsdGVyc107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgLy8gaWYgdGhlIHNpbmdsZSBjaGlsZCBpcyBhbiBlbGVtZW50LCB0dXJuIGl0IGludG8gYSBibG9jay5cclxuICAgICAgICBpZiAoaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkgJiYgY2hpbGQuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGVsZW1lbnQgcm9vdCBpcyBuZXZlciBob2lzdGVkIHNvIGNvZGVnZW5Ob2RlIHdpbGwgbmV2ZXIgYmVcclxuICAgICAgICAgICAgLy8gU2ltcGxlRXhwcmVzc2lvbk5vZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIG1ha2VCbG9jayhjb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgPHNsb3QvPiwgSWZOb2RlLCBGb3JOb2RlOiBhbHJlYWR5IGJsb2Nrcy5cclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cclxuICAgICAgICAgICAgLy8gcm9vdCBjb2RlZ2VuIGZhbGxzIHRocm91Z2ggdmlhIGdlbk5vZGUoKVxyXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyYWdtZW50IGFjdHVhbGx5IGNvbnRhaW5zIGEgc2luZ2xlIHZhbGlkIGNoaWxkIHdpdGhcclxuICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByb290LmNoaWxkcmVuLCBwYXRjaEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3BhdGNoRmxhZ1RleHR9ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUsIHVuZGVmaW5lZCwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSA7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IG5vZGVSZW1vdmVkID0gKCkgPT4ge1xyXG4gICAgICAgIGktLTtcclxuICAgIH07XHJcbiAgICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGNvbnRleHQuY2hpbGRJbmRleCA9IGk7XHJcbiAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkID0gbm9kZVJlbW92ZWQ7XHJcbiAgICAgICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAvLyBhcHBseSB0cmFuc2Zvcm0gcGx1Z2luc1xyXG4gICAgY29uc3QgeyBub2RlVHJhbnNmb3JtcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpXShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAob25FeGl0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9uRXhpdCkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIHJlbW92ZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdCBpbXBvcnQgZm9yIHRoZSBDb21tZW50IHN5bWJvbCwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudCBub2RlcyB3aXRoIGBjcmVhdGVWTm9kZWBcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB0cmF2ZXJzZSwgYnV0IHdlIG5lZWQgdG8gaW5qZWN0IHRvU3RyaW5nIGhlbHBlclxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihUT19ESVNQTEFZX1NUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuYnJhbmNoZXNbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgMCAvKiBST09UICovOlxyXG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIGV4aXQgdHJhbnNmb3Jtc1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGV4aXRGbnNbaV0oKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKG5hbWUsIGZuKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSlcclxuICAgICAgICA/IChuKSA9PiBuID09PSBuYW1lXHJcbiAgICAgICAgOiAobikgPT4gbmFtZS50ZXN0KG4pO1xyXG4gICAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRyYW5zZm9ybXMgYXJlIG5vdCBjb25jZXJuZWQgd2l0aCBzbG90c1xyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gdlNsb3QudHNcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiBwcm9wcy5zb21lKGlzVlNsb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYXJlIHJlbW92ZWQgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3ZSByZW1vdmUgdGhlbSAqYmVmb3JlKiBhcHBseWluZyBzbyB0aGF0IGl0IGNhbiBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgaXRzZWxmIGluIGNhc2UgaXQgbW92ZXMgdGhlIG5vZGUgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpdEZucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKiNfX1BVUkVfXyovYDtcclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzclJ1bnRpbWVNb2R1bGVOYW1lID0gJ3Z1ZS9zZXJ2ZXItcmVuZGVyZXInLCBzc3IgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBpblNTUiA9IGZhbHNlIH0pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBzb3VyY2VNYXAsXHJcbiAgICAgICAgZmlsZW5hbWUsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBvcHRpbWl6ZUltcG9ydHMsXHJcbiAgICAgICAgcnVudGltZUdsb2JhbE5hbWUsXHJcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyUnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIGlzVFMsXHJcbiAgICAgICAgaW5TU1IsXHJcbiAgICAgICAgc291cmNlOiBhc3QubG9jLnNvdXJjZSxcclxuICAgICAgICBjb2RlOiBgYCxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgaW5kZW50TGV2ZWw6IDAsXHJcbiAgICAgICAgcHVyZTogZmFsc2UsXHJcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaGVscGVyKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBba2V5XX1gO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVzaChjb2RlLCBub2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY29kZSArPSBjb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5kZW50KCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCsrY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWluZGVudCh3aXRob3V0TmV3TGluZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0TmV3TGluZSkge1xyXG4gICAgICAgICAgICAgICAgLS1jb250ZXh0LmluZGVudExldmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgtLWNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXdsaW5lKCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKGNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBuZXdsaW5lKG4pIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goJ1xcbicgKyBgICBgLnJlcGVhdChuKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgb3B0aW9ucyk7XHJcbiAgICBpZiAob3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKVxyXG4gICAgICAgIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcclxuICAgIGNvbnN0IHsgbW9kZSwgcHVzaCwgcHJlZml4SWRlbnRpZmllcnMsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUsIHNjb3BlSWQsIHNzciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGhhc0hlbHBlcnMgPSBhc3QuaGVscGVycy5sZW5ndGggPiAwO1xyXG4gICAgY29uc3QgdXNlV2l0aEJsb2NrID0gIXByZWZpeElkZW50aWZpZXJzICYmIG1vZGUgIT09ICdtb2R1bGUnO1xyXG4gICAgLy8gcHJlYW1ibGVzXHJcbiAgICAvLyBpbiBzZXR1cCgpIGlubGluZSBtb2RlLCB0aGUgcHJlYW1ibGUgaXMgZ2VuZXJhdGVkIGluIGEgc3ViIGNvbnRleHRcclxuICAgIC8vIGFuZCByZXR1cm5lZCBzZXBhcmF0ZWx5LlxyXG4gICAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gY29udGV4dDtcclxuICAgIHtcclxuICAgICAgICBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgcHJlYW1ibGVDb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIGVudGVyIHJlbmRlciBmdW5jdGlvblxyXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gc3NyID8gYHNzclJlbmRlcmAgOiBgcmVuZGVyYDtcclxuICAgIGNvbnN0IGFyZ3MgPSBzc3IgPyBbJ19jdHgnLCAnX3B1c2gnLCAnX3BhcmVudCcsICdfYXR0cnMnXSA6IFsnX2N0eCcsICdfY2FjaGUnXTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFyZ3Muam9pbignLCAnKTtcclxuICAgIHtcclxuICAgICAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XHJcbiAgICB9XHJcbiAgICBpbmRlbnQoKTtcclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBwdXNoKGB3aXRoIChfY3R4KSB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgLy8gZnVuY3Rpb24gbW9kZSBjb25zdCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIGluc2lkZSB3aXRoIGJsb2NrXHJcbiAgICAgICAgLy8gYWxzbyB0aGV5IHNob3VsZCBiZSByZW5hbWVkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHVzZXIgcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChoYXNIZWxwZXJzKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHthc3QuaGVscGVyc1xyXG4gICAgICAgICAgICAgICAgLm1hcChzID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWApXHJcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gfSA9IF9WdWVgKTtcclxuICAgICAgICAgICAgcHVzaChgXFxuYCk7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmF0ZSBhc3NldCByZXNvbHV0aW9uIHN0YXRlbWVudHNcclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBnZW5Bc3NldHMoYXN0LmNvbXBvbmVudHMsICdjb21wb25lbnQnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgICAgICBnZW5Bc3NldHMoYXN0LmRpcmVjdGl2ZXMsICdkaXJlY3RpdmUnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5maWx0ZXJzICYmIGFzdC5maWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICBnZW5Bc3NldHMoYXN0LmZpbHRlcnMsICdmaWx0ZXInLCBjb250ZXh0KTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgIHB1c2goYGxldCBgKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC50ZW1wczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHB1c2goYCR7aSA+IDAgPyBgLCBgIDogYGB9X3RlbXAke2l9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCB8fCBhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzKSB7XHJcbiAgICAgICAgcHVzaChgXFxuYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgdGhlIFZOb2RlIHRyZWUgZXhwcmVzc2lvblxyXG4gICAgaWYgKCFzc3IpIHtcclxuICAgICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgZ2VuTm9kZShhc3QuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgbnVsbGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZVdpdGhCbG9jaykge1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgfWApO1xyXG4gICAgfVxyXG4gICAgZGVpbmRlbnQoKTtcclxuICAgIHB1c2goYH1gKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXN0LFxyXG4gICAgICAgIGNvZGU6IGNvbnRleHQuY29kZSxcclxuICAgICAgICBwcmVhbWJsZTogYGAsXHJcbiAgICAgICAgLy8gU291cmNlTWFwR2VuZXJhdG9yIGRvZXMgaGF2ZSB0b0pTT04oKSBtZXRob2QgYnV0IGl0J3Mgbm90IGluIHRoZSB0eXBlc1xyXG4gICAgICAgIG1hcDogY29udGV4dC5tYXAgPyBjb250ZXh0Lm1hcC50b0pTT04oKSA6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBzc3IsIHByZWZpeElkZW50aWZpZXJzLCBwdXNoLCBuZXdsaW5lLCBydW50aW1lTW9kdWxlTmFtZSwgcnVudGltZUdsb2JhbE5hbWUsIHNzclJ1bnRpbWVNb2R1bGVOYW1lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xyXG4gICAgY29uc3QgYWxpYXNIZWxwZXIgPSAocykgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YDtcclxuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXHJcbiAgICAvLyBJbiBwcmVmaXggbW9kZSwgd2UgcGxhY2UgdGhlIGNvbnN0IGRlY2xhcmF0aW9uIGF0IHRvcCBzbyBpdCdzIGRvbmVcclxuICAgIC8vIG9ubHkgb25jZTsgQnV0IGlmIHdlIG5vdCBwcmVmaXhpbmcsIHdlIHBsYWNlIHRoZSBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlXHJcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cclxuICAgIGlmIChhc3QuaGVscGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxyXG4gICAgICAgICAgICAvLyBzYXZlIFZ1ZSBpbiBhIHNlcGFyYXRlIHZhcmlhYmxlIHRvIGF2b2lkIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfVnVlID0gJHtWdWVCaW5kaW5nfVxcbmApO1xyXG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gaGFzIGNoZWNrIGNvc3QsIGJ1dCBob2lzdHMgYXJlIGxpZnRlZCBvdXQgb2YgdGhlIGZ1bmN0aW9uIC0gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIHRoZSBoZWxwZXIgaGVyZS5cclxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNIZWxwZXJzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfRUxFTUVOVF9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfQ09NTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVEVYVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihoZWxwZXIgPT4gYXN0LmhlbHBlcnMuaW5jbHVkZXMoaGVscGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFsaWFzSGVscGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXFxuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBwdXNoKGByZXR1cm4gYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUsIGlzVFMgfSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIodHlwZSA9PT0gJ2ZpbHRlcidcclxuICAgICAgICA/IFJFU09MVkVfRklMVEVSXHJcbiAgICAgICAgOiB0eXBlID09PSAnY29tcG9uZW50J1xyXG4gICAgICAgICAgICA/IFJFU09MVkVfQ09NUE9ORU5UXHJcbiAgICAgICAgICAgIDogUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaWQgPSBhc3NldHNbaV07XHJcbiAgICAgICAgLy8gcG90ZW50aWFsIGNvbXBvbmVudCBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZSBpbmZlcnJlZCBmcm9tIFNGQyBmaWxlbmFtZVxyXG4gICAgICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKCdfX3NlbGYnKTtcclxuICAgICAgICBpZiAobWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIGlkID0gaWQuc2xpY2UoMCwgLTYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdXNoKGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KSR7aXNUUyA/IGAhYCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChpIDwgYXNzZXRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ib2lzdHMoaG9pc3RzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWhvaXN0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnB1cmUgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvaXN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcclxuICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9ob2lzdGVkXyR7aSArIDF9ID0gJHtgYH1gKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGV4dC5wdXJlID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0JDEobikge1xyXG4gICAgcmV0dXJuIChpc1N0cmluZyhuKSB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gMiAvKiBURVhUICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGVzLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtdWx0aWxpbmVzID0gbm9kZXMubGVuZ3RoID4gMyB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJiBub2Rlcy5zb21lKG4gPT4gaXNBcnJheShuKSB8fCAhaXNUZXh0JDEobikpKTtcclxuICAgIGNvbnRleHQucHVzaChgW2ApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMpO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmRlaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LnB1c2goYF1gKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyA9IGZhbHNlLCBjb21tYSA9IHRydWUpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCBub2Rlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1N5bWJvbChub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChjb250ZXh0LmhlbHBlcihub2RlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgQXBwbHkgYXBwcm9wcmlhdGUgdHJhbnNmb3JtcyBmaXJzdC5gKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMyAvKiBWTk9ERV9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTggLyogSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBnZW5Ob2RlTGlzdChub2RlLmJvZHksIGNvbnRleHQsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcclxuICAgICAgICBjYXNlIDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjMgLyogSlNfSUZfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGhhdXN0aXZlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQucHVzaChKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29udGVudCwgaXNTdGF0aWMgfSA9IG5vZGU7XHJcbiAgICBjb250ZXh0LnB1c2goaXNTdGF0aWMgPyBKU09OLnN0cmluZ2lmeShjb250ZW50KSA6IGNvbnRlbnQsIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSlcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICBwdXNoKGAke2hlbHBlcihUT19ESVNQTEFZX1NUUklORyl9KGApO1xyXG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIHB1c2goYFtgKTtcclxuICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgXWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS5pc1N0YXRpYykge1xyXG4gICAgICAgIC8vIG9ubHkgcXVvdGUga2V5cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcclxuICAgICAgICAgICAgPyBub2RlLmNvbnRlbnRcclxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xyXG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goYCR7aGVscGVyKENSRUFURV9DT01NRU5UKX0oJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpfSlgLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nLCBpc0NvbXBvbmVudCB9ID0gbm9kZTtcclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChoZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKSArIGAoYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYCgke2hlbHBlcihPUEVOX0JMT0NLKX0oJHtkaXNhYmxlVHJhY2tpbmcgPyBgdHJ1ZWAgOiBgYH0pLCBgKTtcclxuICAgIH1cclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FsbEhlbHBlciA9IGlzQmxvY2tcclxuICAgICAgICA/IGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpXHJcbiAgICAgICAgOiBnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCk7XHJcbiAgICBwdXNoKGhlbHBlcihjYWxsSGVscGVyKSArIGAoYCwgbm9kZSk7XHJcbiAgICBnZW5Ob2RlTGlzdChnZW5OdWxsYWJsZUFyZ3MoW3RhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wc10pLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGAsIGApO1xyXG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XHJcbiAgICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9IG51bGwpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcChhcmcgPT4gYXJnIHx8IGBudWxsYCk7XHJcbn1cclxuLy8gSmF2YVNjcmlwdFxyXG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChjYWxsZWUgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlO1xyXG4gICAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJlxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvbWUocCA9PiBwLnZhbHVlLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB7YCA6IGB7IGApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBrZXlcclxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYDogYCk7XHJcbiAgICAgICAgLy8gdmFsdWVcclxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIG9ubHkgcmVhY2ggdGhpcyBpZiBpdCdzIG11bHRpbGluZXNcclxuICAgICAgICAgICAgcHVzaChgLGApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbXVsdGlsaW5lcyAmJiBkZWluZGVudCgpO1xyXG4gICAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLmVsZW1lbnRzLCBjb250ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50IH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAvLyB3cmFwIHNsb3QgZnVuY3Rpb25zIHdpdGggb3duZXIgY29udGV4dFxyXG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcclxuICAgIH1cclxuICAgIHB1c2goYChgLCBub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICBnZW5Ob2RlTGlzdChwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgZ2VuTm9kZShwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKSA9PiBgKTtcclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBwdXNoKGB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmV0dXJucykge1xyXG4gICAgICAgIGlmIChuZXdsaW5lKSB7XHJcbiAgICAgICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib2R5KSB7XHJcbiAgICAgICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICBpZiAobm9kZS5pc05vblNjb3BlZFNsb3QpIHtcclxuICAgICAgICAgICAgcHVzaChgLCB1bmRlZmluZWQsIHRydWVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSAhaXNTaW1wbGVJZGVudGlmaWVyKHRlc3QuY29udGVudCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA/IGApO1xyXG4gICAgZ2VuTm9kZShjb25zZXF1ZW50LCBjb250ZXh0KTtcclxuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcclxuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcclxuICAgIHB1c2goYDogYCk7XHJcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovO1xyXG4gICAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICAgIH1cclxuICAgIGdlbk5vZGUoYWx0ZXJuYXRlLCBjb250ZXh0KTtcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICB9XHJcbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgtMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XHJcbiAgICBnZW5Ob2RlKG5vZGUudmFsdWUsIGNvbnRleHQpO1xyXG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xyXG4gICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XWApO1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cblxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkSWRlbnRpZmllcihpZCwgcGFyZW50LCBwYXJlbnRTdGFjaykge1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0luRGVzdHJ1Y3R1cmVBc3NpZ25tZW50KHBhcmVudCwgcGFyZW50U3RhY2spIHtcclxuICAgIGlmIChwYXJlbnQgJiZcclxuICAgICAgICAocGFyZW50LnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgcGFyZW50LnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSkge1xyXG4gICAgICAgIGxldCBpID0gcGFyZW50U3RhY2subGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHBhcmVudFN0YWNrW2ldO1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwLnR5cGUgIT09ICdPYmplY3RQcm9wZXJ0eScgJiYgIXAudHlwZS5lbmRzV2l0aCgnUGF0dGVybicpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB3YWxrRnVuY3Rpb25QYXJhbXMobm9kZSwgb25JZGVudCkge1xyXG4gICAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBleHRyYWN0SWRlbnRpZmllcnMocCkpIHtcclxuICAgICAgICAgICAgb25JZGVudChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhibG9jaywgb25JZGVudCkge1xyXG4gICAgZm9yIChjb25zdCBzdG10IG9mIGJsb2NrLmJvZHkpIHtcclxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2Ygc3RtdC5kZWNsYXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKGRlY2wuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25JZGVudChpZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RtdC50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicgfHxcclxuICAgICAgICAgICAgc3RtdC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSB8fCAhc3RtdC5pZClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBvbklkZW50KHN0bXQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0sIG5vZGVzID0gW10pIHtcclxuICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKHBhcmFtKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XHJcbiAgICAgICAgICAgIGxldCBvYmplY3QgPSBwYXJhbTtcclxuICAgICAgICAgICAgd2hpbGUgKG9iamVjdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZXMucHVzaChvYmplY3QpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHBhcmFtLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvcC5hcmd1bWVudCwgbm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AudmFsdWUsIG5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdBcnJheVBhdHRlcm4nOlxyXG4gICAgICAgICAgICBwYXJhbS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKGVsZW1lbnQsIG5vZGVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1Jlc3RFbGVtZW50JzpcclxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmFyZ3VtZW50LCBub2Rlcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRQYXR0ZXJuJzpcclxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZXM7XHJcbn1cclxuY29uc3QgaXNGdW5jdGlvblR5cGUgPSAobm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XHJcbn07XHJcbmNvbnN0IGlzU3RhdGljUHJvcGVydHkgPSAobm9kZSkgPT4gbm9kZSAmJlxyXG4gICAgKG5vZGUudHlwZSA9PT0gJ09iamVjdFByb3BlcnR5JyB8fCBub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSAmJlxyXG4gICAgIW5vZGUuY29tcHV0ZWQ7XHJcbmNvbnN0IGlzU3RhdGljUHJvcGVydHlLZXkgPSAobm9kZSwgcGFyZW50KSA9PiBpc1N0YXRpY1Byb3BlcnR5KHBhcmVudCkgJiYgcGFyZW50LmtleSA9PT0gbm9kZTtcblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcclxuICAgICgnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzLHR5cGVvZix2b2lkJylcclxuICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcclxuICAgICdcXFxcYicpO1xyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgbm9uLXByZWZpeGVkIGV4cHJlc3Npb24uXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XHJcbiAqIGRvZXNuJ3QgcHJlZml4IGV4cHJlc3Npb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvbnMgYXJlIHZhbGlkYXRlZCBwZXItZGlyZWN0aXZlIHNpbmNlIHNvbWUgZGlyZWN0aXZlc1xyXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXHJcbiAgICBpZiAoIWV4cC50cmltKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihhc1Jhd1N0YXRlbWVudHNcclxuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXHJcbiAgICAgICAgICAgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtZXNzYWdlID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxyXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcclxuICAgICAgICAgICAgLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ0IC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovLCBub2RlLmxvYywgdW5kZWZpbmVkLCBtZXNzYWdlKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAvLyBoYW5kbGUgZGlyZWN0aXZlcyBvbiBlbGVtZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGZvciB2LW9uICYgdi1mb3Igc2luY2UgdGhleSBhcmUgc3BlY2lhbCBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmIChkaXIudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSBkaXIuZXhwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Igd3JhcHBpbmcgaW5saW5lIHN0YXRlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGRpci5uYW1lID09PSAnb24nICYmIGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLm5hbWUgPT09ICdzbG90Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXHJcbi8vIGFsd2F5cyBiZSB1c2VkIHdpdGggYSBsZWFkaW5nICF0cnVlIGNoZWNrIHNvIHRoYXQgaXQgY2FuIGJlXHJcbi8vIHRyZWUtc2hha2VuIGZyb20gdGhlIGJyb3dzZXIgYnVpbGQuXHJcbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxyXG4vLyBzb21lIGV4cHJlc3Npb25zIGxpa2Ugdi1zbG90IHByb3BzICYgdi1mb3IgYWxpYXNlcyBzaG91bGQgYmUgcGFyc2VkIGFzXHJcbi8vIGZ1bmN0aW9uIHBhcmFtc1xyXG5hc1BhcmFtcyA9IGZhbHNlLCBcclxuLy8gdi1vbiBoYW5kbGVyIHZhbHVlcyBtYXkgY29udGFpbiBtdWx0aXBsZSBzdGF0ZW1lbnRzXHJcbmFzUmF3U3RhdGVtZW50cyA9IGZhbHNlLCBsb2NhbFZhcnMgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQuaWRlbnRpZmllcnMpKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgaW4tYnJvd3NlciB2YWxpZGF0aW9uIChzYW1lIGxvZ2ljIGluIDIueClcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKC9eKGlmfGVsc2V8ZWxzZS1pZikkLywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XHJcbiAgICAgICAgLy8gIzE1ODc6IFdlIG5lZWQgdG8gZHluYW1pY2FsbHkgaW5jcmVtZW50IHRoZSBrZXkgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBub2RlJ3Mgc2libGluZyBub2Rlcywgc2luY2UgY2hhaW5lZCB2LWlmL2Vsc2UgYnJhbmNoZXMgYXJlXHJcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcclxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xyXG4gICAgICAgIGxldCBrZXkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAga2V5ICs9IHNpYmxpbmcuYnJhbmNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4aXQgY2FsbGJhY2suIENvbXBsZXRlIHRoZSBjb2RlZ2VuTm9kZSB3aGVuIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW5cclxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbmRpdGlvbiA9IGdldFBhcmVudENvbmRpdGlvbihpZk5vZGUuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZGl0aW9uLmFsdGVybmF0ZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5ICsgaWZOb2RlLmJyYW5jaGVzLmxlbmd0aCAtIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxyXG4gICAgICAgICghZGlyLmV4cCB8fCAhZGlyLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUgJiYgZGlyLmV4cCkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgIGNvbnN0IGlmTm9kZSA9IHtcclxuICAgICAgICAgICAgdHlwZTogOSAvKiBJRiAqLyxcclxuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICAgICAgYnJhbmNoZXM6IFticmFuY2hdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGlmTm9kZSk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbG9jYXRlIHRoZSBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihub2RlKTtcclxuICAgICAgICB3aGlsZSAoaS0tID49IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cy51bnNoaWZ0KHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiZcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgICAgICAhc2libGluZy5jb250ZW50LnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdi1lbHNlIHdhcyBmb2xsb3dlZCBieSB2LWVsc2UtaWZcclxuICAgICAgICAgICAgICAgIGlmIChkaXIubmFtZSA9PT0gJ2Vsc2UtaWYnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlc1tzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBub2RlIHRvIHRoZSBpZiBub2RlJ3MgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICAvLyAjMzYxOSBpZ25vcmUgY29tbWVudHMgaWYgdGhlIHYtaWYgaXMgZGlyZWN0IGNoaWxkIG9mIDx0cmFuc2l0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICEoY29udGV4dC5wYXJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQnVpbHRJblR5cGUoY29udGV4dC5wYXJlbnQudGFnLCAndHJhbnNpdGlvbicpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaC5jaGlsZHJlbiA9IFsuLi5jb21tZW50cywgLi4uYnJhbmNoLmNoaWxkcmVuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHVzZXIgaXMgZm9yY2luZyBzYW1lIGtleSBvbiBkaWZmZXJlbnQgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBicmFuY2gudXNlcktleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVLZXkodXNlcktleSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIFhfVl9JRl9TQU1FX0tFWSAqLywgYnJhbmNoLnVzZXJLZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oc2libGluZywgYnJhbmNoLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgYnJhbmNoIHdhcyByZW1vdmVkLCBpdCB3aWxsIG5vdCBiZSB0cmF2ZXJzZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdHJhdmVyc2UgaGVyZS5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShicmFuY2gsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiBleGl0XHJcbiAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc2V0IGN1cnJlbnROb2RlIGFmdGVyIHRyYXZlcnNhbCB0byBpbmRpY2F0ZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTAgLyogSUZfQlJBTkNIICovLFxyXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgY29uZGl0aW9uOiBkaXIubmFtZSA9PT0gJ2Vsc2UnID8gdW5kZWZpbmVkIDogZGlyLmV4cCxcclxuICAgICAgICBjaGlsZHJlbjogbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovICYmICFmaW5kRGlyKG5vZGUsICdmb3InKVxyXG4gICAgICAgICAgICA/IG5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgOiBbbm9kZV0sXHJcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpIHtcclxuICAgIGlmIChicmFuY2guY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihicmFuY2guY29uZGl0aW9uLCBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpLCBcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBpbiBhc0Jsb2NrOiB0cnVlIHNvIHRoYXQgdGhlIGNvbW1lbnQgbm9kZSBjYWxsXHJcbiAgICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxyXG4gICAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKSwgW1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnXCJ2LWlmXCInIDogJ1wiXCInLFxyXG4gICAgICAgICAgICAndHJ1ZSdcclxuICAgICAgICBdKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDQU5fSE9JU1QgKi8pKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcclxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgZmlyc3RDaGlsZC50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gb3B0aW1pemUgYXdheSBuZXN0ZWQgZnJhZ21lbnRzIHdoZW4gY2hpbGQgaXMgYSBGb3JOb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGZpcnN0Q2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZUNhbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hGbGFnID0gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXHJcbiAgICAgICAgICAgIC8vIHRoZSByZXN0IGJlaW5nIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovO1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIGJyYW5jaC5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IGZpcnN0Q2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZ2V0TWVtb2VkVk5vZGVDYWxsKHJldCk7XHJcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxyXG4gICAgICAgIGlmICh2bm9kZUNhbGwudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICBtYWtlQmxvY2sodm5vZGVDYWxsLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IGJyYW5jaCBrZXlcclxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lS2V5KGEsIGIpIHtcclxuICAgIGlmICghYSB8fCBhLnR5cGUgIT09IGIudHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovKSB7XHJcbiAgICAgICAgaWYgKGEudmFsdWUuY29udGVudCAhPT0gYi52YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RpdmVcclxuICAgICAgICBjb25zdCBleHAgPSBhLmV4cDtcclxuICAgICAgICBjb25zdCBicmFuY2hFeHAgPSBiLmV4cDtcclxuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgIGV4cC5pc1N0YXRpYyAhPT0gYnJhbmNoRXhwLmlzU3RhdGljIHx8XHJcbiAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB0cmFuc2Zvcm1Gb3IgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKCdmb3InLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgcmV0dXJuIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBmb3JOb2RlID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGxvb3AgcmVuZGVyIGZ1bmN0aW9uIGV4cHJlc3Npb24gbm93LCBhbmQgYWRkIHRoZVxyXG4gICAgICAgIC8vIGl0ZXJhdG9yIG9uIGV4aXQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICBjb25zdCByZW5kZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihoZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgaXNUZW1wbGF0ZSA9IGlzVGVtcGxhdGVOb2RlKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG1lbW8gPSBmaW5kRGlyKG5vZGUsICdtZW1vJyk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgKTtcclxuICAgICAgICBjb25zdCBrZXlFeHAgPSBrZXlQcm9wICYmXHJcbiAgICAgICAgICAgIChrZXlQcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oa2V5UHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgOiBrZXlQcm9wLmV4cCk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wID8gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGtleUV4cCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGlzU3RhYmxlRnJhZ21lbnQgPSBmb3JOb2RlLnNvdXJjZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlLmNvbnN0VHlwZSA+IDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RmxhZyA9IGlzU3RhYmxlRnJhZ21lbnRcclxuICAgICAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICAgICAgOiBrZXlQcm9wXHJcbiAgICAgICAgICAgICAgICA/IDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL1xyXG4gICAgICAgICAgICAgICAgOiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLztcclxuICAgICAgICBmb3JOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcmVuZGVyRXhwLCBmcmFnbWVudEZsYWcgK1xyXG4gICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzW2ZyYWdtZW50RmxhZ119ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUgLyogaXNCbG9jayAqLywgIWlzU3RhYmxlRnJhZ21lbnQgLyogZGlzYWJsZVRyYWNraW5nICovLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLywgbm9kZS5sb2MpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpbmlzaCB0aGUgY29kZWdlbiBub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxyXG4gICAgICAgICAgICBsZXQgY2hpbGRCbG9jaztcclxuICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZm9yTm9kZTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgPHRlbXBsYXRlIHYtZm9yPiBrZXkgcGxhY2VtZW50XHJcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSAmJiBpc1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGZpbmRQcm9wKGMsICdrZXknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzMgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovLCBrZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0udHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0KG5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgICAgIDogaXNUZW1wbGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuWzBdIC8vIGFwaS1leHRyYWN0b3Igc29tZWhvdyBmYWlscyB0byBpbmZlciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoc2xvdE91dGxldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gPHNsb3Qgdi1mb3I9XCIuLi5cIj4gb3IgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gc2xvdE91dGxldC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgOmtleT1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW5qZWN0IHRoZSBrZXkgdG8gdGhlIHJlbmRlclNsb3QoKSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9wcyBmb3IgcmVuZGVyU2xvdCBpcyBwYXNzZWQgYXMgdGhlIDNyZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj4gd2l0aCB0ZXh0IG9yIG11bHRpLWVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgZ2VuZXJhdGUgYSBmcmFnbWVudCBibG9jayBmb3IgZWFjaCBsb29wXHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGtleVByb3BlcnR5ID8gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSA6IHVuZGVmaW5lZCwgbm9kZS5jaGlsZHJlbiwgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICtcclxuICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUsIHVuZGVmaW5lZCwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGVsZW1lbnQgdi1mb3IuIERpcmVjdGx5IHVzZSB0aGUgY2hpbGQncyBjb2RlZ2VuTm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1hcmsgaXQgYXMgYSBibG9jay5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjaGlsZHJlblswXVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrICE9PSAhaXNTdGFibGVGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gYmxvY2sgdG8gdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSB2bm9kZSB0byBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2suaXNCbG9jayA9ICFpc1N0YWJsZUZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZW1vKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb29wID0gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCwgW1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWRgKVxyXG4gICAgICAgICAgICAgICAgXSkpO1xyXG4gICAgICAgICAgICAgICAgbG9vcC5ib2R5ID0gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9tZW1vID0gKGAsIG1lbW8uZXhwLCBgKWBdKSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWYgKF9jYWNoZWRgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oa2V5RXhwID8gW2AgJiYgX2NhY2hlZC5rZXkgPT09IGAsIGtleUV4cF0gOiBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgJiYgJHtjb250ZXh0LmhlbHBlclN0cmluZyhJU19NRU1PX1NBTUUpfShfY2FjaGVkLCBfbWVtbykpIHJldHVybiBfY2FjaGVkYFxyXG4gICAgICAgICAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9pdGVtID0gYCwgY2hpbGRCbG9ja10pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9pdGVtLm1lbW8gPSBfbWVtb2ApLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHJldHVybiBfaXRlbWApXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlckV4cC5hcmd1bWVudHMucHVzaChsb29wLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfY2FjaGVgKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihTdHJpbmcoY29udGV4dC5jYWNoZWQrKykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlckV4cC5hcmd1bWVudHMucHVzaChjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0KSwgY2hpbGRCbG9jaywgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcclxuZnVuY3Rpb24gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoIWRpci5leHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBYX1ZfRk9SX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbihcclxuICAgIC8vIGNhbiBvbmx5IGJlIHNpbXBsZSBleHByZXNzaW9uIGJlY2F1c2UgdkZvciB0cmFuc2Zvcm0gaXMgYXBwbGllZFxyXG4gICAgLy8gYmVmb3JlIGV4cHJlc3Npb24gdHJhbnNmb3JtLlxyXG4gICAgZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzIgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHNvdXJjZSwgdmFsdWUsIGtleSwgaW5kZXggfSA9IHBhcnNlUmVzdWx0O1xyXG4gICAgY29uc3QgZm9yTm9kZSA9IHtcclxuICAgICAgICB0eXBlOiAxMSAvKiBGT1IgKi8sXHJcbiAgICAgICAgbG9jOiBkaXIubG9jLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB2YWx1ZUFsaWFzOiB2YWx1ZSxcclxuICAgICAgICBrZXlBbGlhczoga2V5LFxyXG4gICAgICAgIG9iamVjdEluZGV4QWxpYXM6IGluZGV4LFxyXG4gICAgICAgIHBhcnNlUmVzdWx0LFxyXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlTm9kZShub2RlKSA/IG5vZGUuY2hpbGRyZW4gOiBbbm9kZV1cclxuICAgIH07XHJcbiAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGZvck5vZGUpO1xyXG4gICAgLy8gYm9va2tlZXBpbmdcclxuICAgIHNjb3Blcy52Rm9yKys7XHJcbiAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihmb3JOb2RlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc2NvcGVzLnZGb3ItLTtcclxuICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICBvbkV4aXQoKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcclxuLy8gVGhpcyByZWdleCBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIGlmIGtleSBvciBpbmRleCBhbGlhc2VzIGhhdmUgZGVzdHJ1Y3R1cmluZyxcclxuLy8gYnV0IHRob3NlIGRvIG5vdCBtYWtlIHNlbnNlIGluIHRoZSBmaXJzdCBwbGFjZSwgc28gdGhpcyB3b3JrcyBpbiBwcmFjdGljZS5cclxuY29uc3QgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcclxuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGlucHV0LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBsb2MgPSBpbnB1dC5sb2M7XHJcbiAgICBjb25zdCBleHAgPSBpbnB1dC5jb250ZW50O1xyXG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcclxuICAgIGlmICghaW5NYXRjaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXHJcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcclxuICAgICAgICBpbmRleDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGxldCB2YWx1ZUNvbnRlbnQgPSBMSFMudHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IHRyaW1tZWRPZmZzZXQgPSBMSFMuaW5kZXhPZih2YWx1ZUNvbnRlbnQpO1xyXG4gICAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcclxuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XHJcbiAgICAgICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcclxuICAgICAgICBjb25zdCBrZXlDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XHJcbiAgICAgICAgbGV0IGtleU9mZnNldDtcclxuICAgICAgICBpZiAoa2V5Q29udGVudCkge1xyXG4gICAgICAgICAgICBrZXlPZmZzZXQgPSBleHAuaW5kZXhPZihrZXlDb250ZW50LCB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBrZXlDb250ZW50LCBrZXlPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmtleSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXhDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGluZGV4Q29udGVudCwgZXhwLmluZGV4T2YoaW5kZXhDb250ZW50LCByZXN1bHQua2V5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlPZmZzZXQgKyBrZXlDb250ZW50Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmluZGV4LCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2YWx1ZUNvbnRlbnQpIHtcclxuICAgICAgICByZXN1bHQudmFsdWUgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCB2YWx1ZUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC52YWx1ZSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBbGlhc0V4cHJlc3Npb24ocmFuZ2UsIGNvbnRlbnQsIG9mZnNldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGdldElubmVyUmFuZ2UocmFuZ2UsIG9mZnNldCwgY29udGVudC5sZW5ndGgpKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSwgbWVtb0FyZ3MgPSBbXSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVBhcmFtc0xpc3QoW3ZhbHVlLCBrZXksIGluZGV4LCAuLi5tZW1vQXJnc10pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0xpc3QoYXJncykge1xyXG4gICAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJnc1xyXG4gICAgICAgIC5zbGljZSgwLCBpICsgMSlcclxuICAgICAgICAubWFwKChhcmcsIGkpID0+IGFyZyB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfYC5yZXBlYXQoaSArIDEpLCBmYWxzZSkpO1xyXG59XG5cbmNvbnN0IGRlZmF1bHRGYWxsYmFjayA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHVuZGVmaW5lZGAsIGZhbHNlKTtcclxuLy8gQSBOb2RlVHJhbnNmb3JtIHRoYXQ6XHJcbi8vIDEuIFRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgcHJlZml4ZWRcclxuLy8gICAgYnkgdHJhbnNmb3JtRXhwcmVzc2lvbi4gVGhpcyBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGhcclxuLy8gICAgeyBwcmVmaXhJZGVudGlmaWVyczogdHJ1ZSB9LlxyXG4vLyAyLiBUcmFjayB2LXNsb3QgZGVwdGhzIHNvIHRoYXQgd2Uga25vdyBhIHNsb3QgaXMgaW5zaWRlIGFub3RoZXIgc2xvdC5cclxuLy8gICAgTm90ZSB0aGUgZXhpdCBjYWxsYmFjayBpcyBleGVjdXRlZCBiZWZvcmUgYnVpbGRTbG90cygpIG9uIHRoZSBzYW1lIG5vZGUsXHJcbi8vICAgIHNvIG9ubHkgbmVzdGVkIHNsb3RzIHNlZSBwb3NpdGl2ZSBudW1iZXJzLlxyXG5jb25zdCB0cmFja1Nsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKSkge1xyXG4gICAgICAgIC8vIFdlIGFyZSBvbmx5IGNoZWNraW5nIG5vbi1lbXB0eSB2LXNsb3QgaGVyZVxyXG4gICAgICAgIC8vIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBzbG90cyB0aGF0IGludHJvZHVjZSBzY29wZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgY29uc3QgdlNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90Jyk7XHJcbiAgICAgICAgaWYgKHZTbG90KSB7XHJcbiAgICAgICAgICAgIHZTbG90LmV4cDtcclxuICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdCB0cmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyB3aXRoIHYtZm9yLlxyXG4vLyBUaGlzIHRyYW5zZm9ybSBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGggeyBwcmVmaXhJZGVudGlmaWVyczogdHJ1ZSB9XHJcbmNvbnN0IHRyYWNrVkZvclNsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgbGV0IHZGb3I7XHJcbiAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkgJiZcclxuICAgICAgICBub2RlLnByb3BzLnNvbWUoaXNWU2xvdCkgJiZcclxuICAgICAgICAodkZvciA9IGZpbmREaXIobm9kZSwgJ2ZvcicpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICh2Rm9yLnBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKHZGb3IuZXhwLCBjb250ZXh0KSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBrZXksIGluZGV4IH0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWx1ZSAmJiBhZGRJZGVudGlmaWVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGtleSAmJiBhZGRJZGVudGlmaWVycyhrZXkpO1xyXG4gICAgICAgICAgICBpbmRleCAmJiBhZGRJZGVudGlmaWVycyhpbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBrZXkgJiYgcmVtb3ZlSWRlbnRpZmllcnMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICYmIHJlbW92ZUlkZW50aWZpZXJzKGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGJ1aWxkQ2xpZW50U2xvdEZuID0gKHByb3BzLCBjaGlsZHJlbiwgbG9jKSA9PiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocHJvcHMsIGNoaWxkcmVuLCBmYWxzZSAvKiBuZXdsaW5lICovLCB0cnVlIC8qIGlzU2xvdCAqLywgY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bMF0ubG9jIDogbG9jKTtcclxuLy8gSW5zdGVhZCBvZiBiZWluZyBhIERpcmVjdGl2ZVRyYW5zZm9ybSwgdi1zbG90IHByb2Nlc3NpbmcgaXMgY2FsbGVkIGR1cmluZ1xyXG4vLyB0cmFuc2Zvcm1FbGVtZW50IHRvIGJ1aWxkIHRoZSBzbG90cyBvYmplY3QgZm9yIGEgY29tcG9uZW50LlxyXG5mdW5jdGlvbiBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQsIGJ1aWxkU2xvdEZuID0gYnVpbGRDbGllbnRTbG90Rm4pIHtcclxuICAgIGNvbnRleHQuaGVscGVyKFdJVEhfQ1RYKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IHNsb3RzUHJvcGVydGllcyA9IFtdO1xyXG4gICAgY29uc3QgZHluYW1pY1Nsb3RzID0gW107XHJcbiAgICAvLyBJZiB0aGUgc2xvdCBpcyBpbnNpZGUgYSB2LWZvciBvciBhbm90aGVyIHYtc2xvdCwgZm9yY2UgaXQgdG8gYmUgZHluYW1pY1xyXG4gICAgLy8gc2luY2UgaXQgbGlrZWx5IHVzZXMgYSBzY29wZSB2YXJpYWJsZS5cclxuICAgIGxldCBoYXNEeW5hbWljU2xvdHMgPSBjb250ZXh0LnNjb3Blcy52U2xvdCA+IDAgfHwgY29udGV4dC5zY29wZXMudkZvciA+IDA7XHJcbiAgICAvLyAxLiBDaGVjayBmb3Igc2xvdCB3aXRoIHNsb3RQcm9wcyBvbiBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgLy8gICAgPENvbXAgdi1zbG90PVwieyBwcm9wIH1cIi8+XHJcbiAgICBjb25zdCBvbkNvbXBvbmVudFNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90JywgdHJ1ZSk7XHJcbiAgICBpZiAob25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgY29uc3QgeyBhcmcsIGV4cCB9ID0gb25Db21wb25lbnRTbG90O1xyXG4gICAgICAgIGlmIChhcmcgJiYgIWlzU3RhdGljRXhwKGFyZykpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ2RlZmF1bHQnLCB0cnVlKSwgYnVpbGRTbG90Rm4oZXhwLCBjaGlsZHJlbiwgbG9jKSkpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gSXRlcmF0ZSB0aHJvdWdoIGNoaWxkcmVuIGFuZCBjaGVjayBmb3IgdGVtcGxhdGUgc2xvdHNcclxuICAgIC8vICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6Zm9vPVwieyBwcm9wIH1cIj5cclxuICAgIGxldCBoYXNUZW1wbGF0ZVNsb3RzID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzTmFtZWREZWZhdWx0U2xvdCA9IGZhbHNlO1xyXG4gICAgY29uc3QgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4gPSBbXTtcclxuICAgIGNvbnN0IHNlZW5TbG90TmFtZXMgPSBuZXcgU2V0KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdEVsZW1lbnQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBsZXQgc2xvdERpcjtcclxuICAgICAgICBpZiAoIWlzVGVtcGxhdGVOb2RlKHNsb3RFbGVtZW50KSB8fFxyXG4gICAgICAgICAgICAhKHNsb3REaXIgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnc2xvdCcsIHRydWUpKSkge1xyXG4gICAgICAgICAgICAvLyBub3QgYSA8dGVtcGxhdGUgdi1zbG90Piwgc2tpcC5cclxuICAgICAgICAgICAgaWYgKHNsb3RFbGVtZW50LnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ucHVzaChzbG90RWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBoYXMgb24tY29tcG9uZW50IHNsb3QgLSB0aGlzIGlzIGluY29ycmVjdCB1c2FnZS5cclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzcgLyogWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqLywgc2xvdERpci5sb2MpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHNsb3RDaGlsZHJlbiwgbG9jOiBzbG90TG9jIH0gPSBzbG90RWxlbWVudDtcclxuICAgICAgICBjb25zdCB7IGFyZzogc2xvdE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBkZWZhdWx0YCwgdHJ1ZSksIGV4cDogc2xvdFByb3BzLCBsb2M6IGRpckxvYyB9ID0gc2xvdERpcjtcclxuICAgICAgICAvLyBjaGVjayBpZiBuYW1lIGlzIGR5bmFtaWMuXHJcbiAgICAgICAgbGV0IHN0YXRpY1Nsb3ROYW1lO1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChzbG90TmFtZSkpIHtcclxuICAgICAgICAgICAgc3RhdGljU2xvdE5hbWUgPSBzbG90TmFtZSA/IHNsb3ROYW1lLmNvbnRlbnQgOiBgZGVmYXVsdGA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzbG90RnVuY3Rpb24gPSBidWlsZFNsb3RGbihzbG90UHJvcHMsIHNsb3RDaGlsZHJlbiwgc2xvdExvYyk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzbG90IGlzIGNvbmRpdGlvbmFsICh2LWlmL3YtZm9yKVxyXG4gICAgICAgIGxldCB2SWY7XHJcbiAgICAgICAgbGV0IHZFbHNlO1xyXG4gICAgICAgIGxldCB2Rm9yO1xyXG4gICAgICAgIGlmICgodklmID0gZmluZERpcihzbG90RWxlbWVudCwgJ2lmJykpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2SWYuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCBkZWZhdWx0RmFsbGJhY2spKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHZFbHNlID0gZmluZERpcihzbG90RWxlbWVudCwgL15lbHNlKC1pZik/JC8sIHRydWUgLyogYWxsb3dFbXB0eSAqLykpKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWRqYWNlbnQgdi1pZlxyXG4gICAgICAgICAgICBsZXQgaiA9IGk7XHJcbiAgICAgICAgICAgIGxldCBwcmV2O1xyXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldi50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldiAmJiBpc1RlbXBsYXRlTm9kZShwcmV2KSAmJiBmaW5kRGlyKHByZXYsICdpZicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9kZVxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgc2xvdCB0byBwcmV2aW91cyBjb25kaXRpb25hbFxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbmFsID0gZHluYW1pY1Nsb3RzW2R5bmFtaWNTbG90cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb25kaXRpb25hbC5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuYWx0ZXJuYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uYWwuYWx0ZXJuYXRlID0gdkVsc2UuZXhwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odkVsc2UuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCBkZWZhdWx0RmFsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgOiBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIHZFbHNlLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh2Rm9yID0gZmluZERpcihzbG90RWxlbWVudCwgJ2ZvcicpKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHZGb3IucGFyc2VSZXN1bHQgfHxcclxuICAgICAgICAgICAgICAgIHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBkeW5hbWljIHNsb3RzIGFzIGFuIGFycmF5IGFuZCBhZGQgaXQgdG8gdGhlIGNyZWF0ZVNsb3QoKVxyXG4gICAgICAgICAgICAgICAgLy8gYXJncy4gVGhlIHJ1bnRpbWUga25vd3MgaG93IHRvIGhhbmRsZSBpdCBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKHBhcnNlUmVzdWx0KSwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKVxyXG4gICAgICAgICAgICAgICAgXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzIgLyogWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgdkZvci5sb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgZHVwbGljYXRlIHN0YXRpYyBuYW1lc1xyXG4gICAgICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWVuU2xvdE5hbWVzLmhhcyhzdGF0aWNTbG90TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOCAvKiBYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqLywgZGlyTG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWVuU2xvdE5hbWVzLmFkZChzdGF0aWNTbG90TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc05hbWVkRGVmYXVsdFNsb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgIGNvbnN0IGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSA9IChwcm9wcywgY2hpbGRyZW4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZm4gPSBidWlsZFNsb3RGbihwcm9wcywgY2hpbGRyZW4sIGxvYyk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNvbXBhdENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgZm4uaXNOb25TY29wZWRTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGRlZmF1bHRgLCBmbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWhhc1RlbXBsYXRlU2xvdHMpIHtcclxuICAgICAgICAgICAgLy8gaW1wbGljaXQgZGVmYXVsdCBzbG90IChvbiBjb21wb25lbnQpXHJcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGNoaWxkcmVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyAjMzc2NlxyXG4gICAgICAgICAgICAvLyB3aXRoIHdoaXRlc3BhY2U6ICdwcmVzZXJ2ZScsIHdoaXRlc3BhY2VzIGJldHdlZW4gc2xvdHMgd2lsbCBlbmQgdXAgaW5cclxuICAgICAgICAgICAgLy8gaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uIElnbm9yZSBpZiBhbGwgaW1wbGljaXQgY2hpbGRyZW4gYXJlIHdoaXRlc3BhY2VzLlxyXG4gICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5zb21lKG5vZGUgPT4gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSkpIHtcclxuICAgICAgICAgICAgLy8gaW1wbGljaXQgZGVmYXVsdCBzbG90IChtaXhlZCB3aXRoIG5hbWVkIHNsb3RzKVxyXG4gICAgICAgICAgICBpZiAoaGFzTmFtZWREZWZhdWx0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzkgLyogWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi8sIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuWzBdLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNsb3RGbGFnID0gaGFzRHluYW1pY1Nsb3RzXHJcbiAgICAgICAgPyAyIC8qIERZTkFNSUMgKi9cclxuICAgICAgICA6IGhhc0ZvcndhcmRlZFNsb3RzKG5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gMyAvKiBGT1JXQVJERUQgKi9cclxuICAgICAgICAgICAgOiAxIC8qIFNUQUJMRSAqLztcclxuICAgIGxldCBzbG90cyA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oc2xvdHNQcm9wZXJ0aWVzLmNvbmNhdChjcmVhdGVPYmplY3RQcm9wZXJ0eShgX2AsIFxyXG4gICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcclxuICAgIC8vIDEgPSBjb21waWxlZCBhbmQgc3RhdGljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiBBTkQgZGlmZiBhcyBvcHRpbWl6ZWRcclxuICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oc2xvdEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3Nsb3RGbGFnc1RleHRbc2xvdEZsYWddfSAqL2AgOiBgYCksIGZhbHNlKSkpLCBsb2MpO1xyXG4gICAgaWYgKGR5bmFtaWNTbG90cy5sZW5ndGgpIHtcclxuICAgICAgICBzbG90cyA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9TTE9UUyksIFtcclxuICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkeW5hbWljU2xvdHMpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNsb3RzLFxyXG4gICAgICAgIGhhc0R5bmFtaWNTbG90c1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBidWlsZER5bmFtaWNTbG90KG5hbWUsIGZuKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYG5hbWVgLCBuYW1lKSxcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZm5gLCBmbilcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkcmVuKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxIC8qIEVMRU1FTlQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmJyYW5jaGVzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gMiAvKiBURVhUICovICYmIG5vZGUudHlwZSAhPT0gMTIgLyogVEVYVF9DQUxMICovKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovXHJcbiAgICAgICAgPyAhIW5vZGUuY29udGVudC50cmltKClcclxuICAgICAgICA6IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZS5jb250ZW50KTtcclxufVxuXG4vLyBzb21lIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIChlLmcuIHYtbW9kZWwpIG1heSByZXR1cm4gYSBzeW1ib2wgZm9yIHJ1bnRpbWVcclxuLy8gaW1wb3J0LCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxyXG5jb25zdCBkaXJlY3RpdmVJbXBvcnRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBnZW5lcmF0ZSBhIEphdmFTY3JpcHQgQVNUIGZvciB0aGlzIGVsZW1lbnQncyBjb2RlZ2VuXHJcbmNvbnN0IHRyYW5zZm9ybUVsZW1lbnQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgLy8gcGVyZm9ybSB0aGUgd29yayBvbiBleGl0LCBhZnRlciBhbGwgY2hpbGQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXHJcbiAgICAvLyBwcm9jZXNzZWQgYW5kIG1lcmdlZC5cclxuICAgIHJldHVybiBmdW5jdGlvbiBwb3N0VHJhbnNmb3JtRWxlbWVudCgpIHtcclxuICAgICAgICBub2RlID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICBpZiAoIShub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAobm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdGFnLCBwcm9wcyB9ID0gbm9kZTtcclxuICAgICAgICBjb25zdCBpc0NvbXBvbmVudCA9IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgLy8gVGhlIGdvYWwgb2YgdGhlIHRyYW5zZm9ybSBpcyB0byBjcmVhdGUgYSBjb2RlZ2VuTm9kZSBpbXBsZW1lbnRpbmcgdGhlXHJcbiAgICAgICAgLy8gVk5vZGVDYWxsIGludGVyZmFjZS5cclxuICAgICAgICBsZXQgdm5vZGVUYWcgPSBpc0NvbXBvbmVudFxyXG4gICAgICAgICAgICA/IHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQpXHJcbiAgICAgICAgICAgIDogYFwiJHt0YWd9XCJgO1xyXG4gICAgICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9IGlzT2JqZWN0KHZub2RlVGFnKSAmJiB2bm9kZVRhZy5jYWxsZWUgPT09IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XHJcbiAgICAgICAgbGV0IHZub2RlUHJvcHM7XHJcbiAgICAgICAgbGV0IHZub2RlQ2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHZub2RlUGF0Y2hGbGFnO1xyXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgIGxldCB2bm9kZUR5bmFtaWNQcm9wcztcclxuICAgICAgICBsZXQgZHluYW1pY1Byb3BOYW1lcztcclxuICAgICAgICBsZXQgdm5vZGVEaXJlY3RpdmVzO1xyXG4gICAgICAgIGxldCBzaG91bGRVc2VCbG9jayA9IFxyXG4gICAgICAgIC8vIGR5bmFtaWMgY29tcG9uZW50IG1heSByZXNvbHZlIHRvIHBsYWluIGVsZW1lbnRzXHJcbiAgICAgICAgaXNEeW5hbWljQ29tcG9uZW50IHx8XHJcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBURUxFUE9SVCB8fFxyXG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gU1VTUEVOU0UgfHxcclxuICAgICAgICAgICAgKCFpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gPHN2Zz4gYW5kIDxmb3JlaWduT2JqZWN0PiBtdXN0IGJlIGZvcmNlZCBpbnRvIGJsb2NrcyBzbyB0aGF0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGluc2lkZSBnZXQgcHJvcGVyIGlzU1ZHIGZsYWcgYXQgcnVudGltZS4gKCM2MzksICM2NDMpXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IHdlYi1zcGVjaWZpYywgYnV0IHNwbGl0dGluZyB0aGUgbG9naWMgb3V0IG9mIGNvcmVcclxuICAgICAgICAgICAgICAgIC8vIGxlYWRzIHRvIHRvbyBtdWNoIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbiAgICAgICAgICAgICAgICAodGFnID09PSAnc3ZnJyB8fCB0YWcgPT09ICdmb3JlaWduT2JqZWN0JykpO1xyXG4gICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcHNCdWlsZFJlc3VsdCA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZub2RlUHJvcHMgPSBwcm9wc0J1aWxkUmVzdWx0LnByb3BzO1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSBwcm9wc0J1aWxkUmVzdWx0LnBhdGNoRmxhZztcclxuICAgICAgICAgICAgZHluYW1pY1Byb3BOYW1lcyA9IHByb3BzQnVpbGRSZXN1bHQuZHluYW1pY1Byb3BOYW1lcztcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHByb3BzQnVpbGRSZXN1bHQuZGlyZWN0aXZlcztcclxuICAgICAgICAgICAgdm5vZGVEaXJlY3RpdmVzID1cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkaXJlY3RpdmVzLm1hcChkaXIgPT4gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAocHJvcHNCdWlsZFJlc3VsdC5zaG91bGRVc2VCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGVUYWcgPT09IEtFRVBfQUxJVkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIGEgYnVpbHQtaW4gY29tcG9uZW50LCB3ZSBjb21waWxlIEtlZXBBbGl2ZSB3aXRoIHJhdyBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBzbG90IGZ1bmN0aW9ucyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluc2lkZSBUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBvciBvdGhlciBUcmFuc2l0aW9uLXdyYXBwaW5nIEhPQ3MuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIHdpdGggYmxvY2sgb3B0aW1pemF0aW9ucywgd2UgbmVlZCB0bzpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEZvcmNlIGtlZXAtYWxpdmUgaW50byBhIGJsb2NrLiBUaGlzIGF2b2lkcyBpdHMgY2hpbGRyZW4gYmVpbmdcclxuICAgICAgICAgICAgICAgIC8vICAgIGNvbGxlY3RlZCBieSBhIHBhcmVudCBibG9jay5cclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIDIuIEZvcmNlIGtlZXAtYWxpdmUgdG8gYWx3YXlzIGJlIHVwZGF0ZWQsIHNpbmNlIGl0IHVzZXMgcmF3IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDUgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCBpcyBub3QgYSByZWFsIGNvbXBvbmVudCBhbmQgaGFzIGRlZGljYXRlZCBydW50aW1lIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gVEVMRVBPUlQgJiZcclxuICAgICAgICAgICAgICAgIC8vIGV4cGxhaW5lZCBhYm92ZS5cclxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBLRUVQX0FMSVZFO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkQnVpbGRBc1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNsb3RzLCBoYXNEeW5hbWljU2xvdHMgfSA9IGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB2bm9kZVRhZyAhPT0gVEVMRVBPUlQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZC50eXBlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGR5bmFtaWMgdGV4dCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMSAvKiBURVhUICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBkaXJlY3RseSBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gKHBsYWluIC8gaW50ZXJwb2xhdGlvbiAvIGV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCB8fCB0eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhdGNoRmxhZyAmIGR5bmFtaWNQcm9wTmFtZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBmbGFncyAobmVnYXRpdmUgYW5kIG11dHVhbGx5IGV4Y2x1c2l2ZSlcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtQYXRjaEZsYWdOYW1lc1twYXRjaEZsYWddfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiaXR3aXNlIGZsYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoUGF0Y2hGbGFnTmFtZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG4gPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChuID0+IFBhdGNoRmxhZ05hbWVzW25dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtmbGFnTmFtZXN9ICovYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gU3RyaW5nKHBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMgJiYgZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlRHluYW1pY1Byb3BzID0gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhkeW5hbWljUHJvcE5hbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHZub2RlVGFnLCB2bm9kZVByb3BzLCB2bm9kZUNoaWxkcmVuLCB2bm9kZVBhdGNoRmxhZywgdm5vZGVEeW5hbWljUHJvcHMsIHZub2RlRGlyZWN0aXZlcywgISFzaG91bGRVc2VCbG9jaywgZmFsc2UgLyogZGlzYWJsZVRyYWNraW5nICovLCBpc0NvbXBvbmVudCwgbm9kZS5sb2MpO1xyXG4gICAgfTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dCwgc3NyID0gZmFsc2UpIHtcclxuICAgIGxldCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIC8vIDEuIGR5bmFtaWMgY29tcG9uZW50XHJcbiAgICBjb25zdCBpc0V4cGxpY2l0RHluYW1pYyA9IGlzQ29tcG9uZW50VGFnKHRhZyk7XHJcbiAgICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChub2RlLCAnaXMnKTtcclxuICAgIGlmIChpc1Byb3ApIHtcclxuICAgICAgICBpZiAoaXNFeHBsaWNpdER5bmFtaWMgfHxcclxuICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovLCBjb250ZXh0KSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwID0gaXNQcm9wLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovXHJcbiAgICAgICAgICAgICAgICA/IGlzUHJvcC52YWx1ZSAmJiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGlzUHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgOiBpc1Byb3AuZXhwO1xyXG4gICAgICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCksIFtcclxuICAgICAgICAgICAgICAgICAgICBleHBcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJlxyXG4gICAgICAgICAgICBpc1Byb3AudmFsdWUuY29udGVudC5zdGFydHNXaXRoKCd2dWU6JykpIHtcclxuICAgICAgICAgICAgLy8gPGJ1dHRvbiBpcz1cInZ1ZTp4eHhcIj5cclxuICAgICAgICAgICAgLy8gaWYgbm90IDxjb21wb25lbnQ+LCBvbmx5IGlzIHZhbHVlIHRoYXQgc3RhcnRzIHdpdGggXCJ2dWU6XCIgd2lsbCBiZVxyXG4gICAgICAgICAgICAvLyB0cmVhdGVkIGFzIGNvbXBvbmVudCBieSB0aGUgcGFyc2UgcGhhc2UgYW5kIHJlYWNoIGhlcmUsIHVubGVzcyBpdCdzXHJcbiAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdoZXJlIGFsbCBpcyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgY29tcG9uZW50c1xyXG4gICAgICAgICAgICB0YWcgPSBpc1Byb3AudmFsdWUuY29udGVudC5zbGljZSg0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAxLjUgdi1pcyAoVE9ETzogRGVwcmVjYXRlKVxyXG4gICAgY29uc3QgaXNEaXIgPSAhaXNFeHBsaWNpdER5bmFtaWMgJiYgZmluZERpcihub2RlLCAnaXMnKTtcclxuICAgIGlmIChpc0RpciAmJiBpc0Rpci5leHApIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCksIFtcclxuICAgICAgICAgICAgaXNEaXIuZXhwXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBidWlsdC1pbiBjb21wb25lbnRzIChUZWxlcG9ydCwgVHJhbnNpdGlvbiwgS2VlcEFsaXZlLCBTdXNwZW5zZS4uLilcclxuICAgIGNvbnN0IGJ1aWx0SW4gPSBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpO1xyXG4gICAgaWYgKGJ1aWx0SW4pIHtcclxuICAgICAgICAvLyBidWlsdC1pbnMgYXJlIHNpbXBseSBmYWxsdGhyb3VnaHMgLyBoYXZlIHNwZWNpYWwgaGFuZGxpbmcgZHVyaW5nIHNzclxyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gaW1wb3J0IHRoZWlyIHJ1bnRpbWUgZXF1aXZhbGVudHNcclxuICAgICAgICBpZiAoIXNzcilcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoYnVpbHRJbik7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWx0SW47XHJcbiAgICB9XHJcbiAgICAvLyA1LiB1c2VyIGNvbXBvbmVudCAocmVzb2x2ZSlcclxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcclxuICAgIGNvbnRleHQuY29tcG9uZW50cy5hZGQodGFnKTtcclxuICAgIHJldHVybiB0b1ZhbGlkQXNzZXRJZCh0YWcsIGBjb21wb25lbnRgKTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIHByb3BzID0gbm9kZS5wcm9wcywgc3NyID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgdGFnLCBsb2M6IGVsZW1lbnRMb2MsIGNoaWxkcmVuIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IG1lcmdlQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZURpcmVjdGl2ZXMgPSBbXTtcclxuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMDtcclxuICAgIGxldCBzaG91bGRVc2VCbG9jayA9IGZhbHNlO1xyXG4gICAgLy8gcGF0Y2hGbGFnIGFuYWx5c2lzXHJcbiAgICBsZXQgcGF0Y2hGbGFnID0gMDtcclxuICAgIGxldCBoYXNSZWYgPSBmYWxzZTtcclxuICAgIGxldCBoYXNDbGFzc0JpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBoYXNEeW5hbWljS2V5cyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xyXG4gICAgY29uc3QgZHluYW1pY1Byb3BOYW1lcyA9IFtdO1xyXG4gICAgY29uc3QgYW5hbHl6ZVBhdGNoRmxhZyA9ICh7IGtleSwgdmFsdWUgfSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBrZXkuY29udGVudDtcclxuICAgICAgICAgICAgY29uc3QgaXNFdmVudEhhbmRsZXIgPSBpc09uKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICBpc0V2ZW50SGFuZGxlciAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCB0aGUgZmxhZyBmb3IgY2xpY2sgaGFuZGxlcnMgYmVjYXVzZSBoeWRyYXRpb24gZ2l2ZXMgY2xpY2tcclxuICAgICAgICAgICAgICAgIC8vIGRlZGljYXRlZCBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbmNsaWNrJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCB2LW1vZGVsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnb25VcGRhdGU6bW9kZWxWYWx1ZScgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgb25Wbm9kZVhYWCBob29rc1xyXG4gICAgICAgICAgICAgICAgIWlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0V2ZW50SGFuZGxlciAmJiBpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgKCh2YWx1ZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBpcyBhIGNhY2hlZCBoYW5kbGVyIG9yIGhhcyBjb25zdGFudCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xyXG4gICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNDbGFzc0JpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIGhhc1N0eWxlQmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgZHluYW1pYyBjbGFzcyBhbmQgc3R5bGUgYmluZGluZyBvZiB0aGUgY29tcG9uZW50IGFzIGR5bmFtaWMgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAobmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lID09PSAnc3R5bGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxvYywgbmFtZSwgdmFsdWUgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xyXG4gICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnNjb3Blcy52Rm9yID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZfZm9yJywgdHJ1ZSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3RydWUnKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgaXMgb24gPGNvbXBvbmVudD4sIG9yIGlzPVwidnVlOnh4eFwiXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaXMnICYmXHJcbiAgICAgICAgICAgICAgICAoaXNDb21wb25lbnRUYWcodGFnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKG5hbWUsIHRydWUsIGdldElubmVyUmFuZ2UobG9jLCAwLCBuYW1lLmxlbmd0aCkpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHZhbHVlID8gdmFsdWUuY29udGVudCA6ICcnLCBpc1N0YXRpYywgdmFsdWUgPyB2YWx1ZS5sb2MgOiBsb2MpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcclxuICAgICAgICAgICAgY29uc3QgaXNWQmluZCA9IG5hbWUgPT09ICdiaW5kJztcclxuICAgICAgICAgICAgY29uc3QgaXNWT24gPSBuYW1lID09PSAnb24nO1xyXG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MCAvKiBYX1ZfU0xPVF9NSVNQTEFDRUQgKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2Uvdi1tZW1vIC0gdGhleSBhcmUgaGFuZGxlZCBieSBkZWRpY2F0ZWQgdHJhbnNmb3Jtcy5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdvbmNlJyB8fCBuYW1lID09PSAnbWVtbycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1pcyBhbmQgOmlzIG9uIDxjb21wb25lbnQ+XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaXMnIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNWQmluZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhdGljQXJnT2YoYXJnLCAnaXMnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbiBpbiBTU1IgY29tcGlsYXRpb25cclxuICAgICAgICAgICAgaWYgKGlzVk9uICYmIHNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXHJcbiAgICAgICAgICAgIChpc1ZCaW5kICYmIGlzU3RhdGljQXJnT2YoYXJnLCAna2V5JykpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBpbmxpbmUgYmVmb3JlLXVwZGF0ZSBob29rcyBuZWVkIHRvIGZvcmNlIGJsb2NrIHNvIHRoYXQgaXQgaXMgaW52b2tlZFxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAoaXNWT24gJiYgaGFzQ2hpbGRyZW4gJiYgaXNTdGF0aWNBcmdPZihhcmcsICd2dWU6YmVmb3JlLXVwZGF0ZScpKSkge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1ZCaW5kICYmIGlzU3RhdGljQXJnT2YoYXJnLCAncmVmJykgJiYgY29udGV4dC5zY29wZXMudkZvciA+IDApIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZfZm9yJywgdHJ1ZSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3RydWUnKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igdi1iaW5kIGFuZCB2LW9uIHdpdGggbm8gYXJndW1lbnRcclxuICAgICAgICAgICAgaWYgKCFhcmcgJiYgKGlzVkJpbmQgfHwgaXNWT24pKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZCaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIueCB2LWJpbmQgb2JqZWN0IG9yZGVyIGNvbXBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJvcGVydGllcy5zb21lKCh7IGtleSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFrZXkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5LmNvbnRlbnQgIT09ICdjbGFzcycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LmNvbnRlbnQgIT09ICdzdHlsZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzT24oa2V5LmNvbnRlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVycmlkYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiIC8qIENPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi8sIGNvbnRleHQsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy51bnNoaWZ0KGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtb249XCJvYmpcIiAtPiB0b0hhbmRsZXJzKG9iailcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBjb250ZXh0LmhlbHBlcihUT19IQU5ETEVSUyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtleHBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGlzVkJpbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAzNCAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMzUgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlVHJhbnNmb3JtID0gY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgYnVpbHQtaW4gZGlyZWN0aXZlIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIG5lZWRSdW50aW1lIH0gPSBkaXJlY3RpdmVUcmFuc2Zvcm0ocHJvcCwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAhc3NyICYmIHByb3BzLmZvckVhY2goYW5hbHl6ZVBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goLi4ucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW1ib2wobmVlZFJ1bnRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUltcG9ydE1hcC5zZXQocHJvcCwgbmVlZFJ1bnRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBidWlsdC1pbiB0cmFuc2Zvcm0sIHRoaXMgaXMgYSB1c2VyIGN1c3RvbSBkaXJlY3RpdmUuXHJcbiAgICAgICAgICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcnMgbWF5IHVzZSBiZWZvcmVVcGRhdGUgc28gdGhleSBuZWVkIHRvIGZvcmNlIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gZW5zdXJlIGJlZm9yZS11cGRhdGUgZ2V0cyBjYWxsZWQgYmVmb3JlIGNoaWxkcmVuIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHByb3BzRXhwcmVzc2lvbiA9IHVuZGVmaW5lZDtcclxuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXHJcbiAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmdlQXJncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBtZXJnZUFyZ3NbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0Y2hGbGFnIGFuYWx5c2lzXHJcbiAgICBpZiAoaGFzRHluYW1pY0tleXMpIHtcclxuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChoYXNDbGFzc0JpbmRpbmcgJiYgIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIENMQVNTICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzU3R5bGVCaW5kaW5nICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gNCAvKiBTVFlMRSAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA4IC8qIFBST1BTICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXNob3VsZFVzZUJsb2NrICYmXHJcbiAgICAgICAgKHBhdGNoRmxhZyA9PT0gMCB8fCBwYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSAmJlxyXG4gICAgICAgIChoYXNSZWYgfHwgaGFzVm5vZGVIb29rIHx8IHJ1bnRpbWVEaXJlY3RpdmVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDUxMiAvKiBORUVEX1BBVENIICovO1xyXG4gICAgfVxyXG4gICAgLy8gcHJlLW5vcm1hbGl6ZSBwcm9wcywgU1NSIGlzIHNraXBwZWQgZm9yIG5vd1xyXG4gICAgaWYgKCFjb250ZXh0LmluU1NSICYmIHByb3BzRXhwcmVzc2lvbikge1xyXG4gICAgICAgIHN3aXRjaCAocHJvcHNFeHByZXNzaW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgICAgIC8vIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gdi1iaW5kLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHN0aWxsIG5lZWQgdG8gZGVhbCB3aXRoIGR5bmFtaWMga2V5IGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIGxldCBjbGFzc0tleUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVLZXlJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc0R5bmFtaWNLZXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tpXS5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RhdGljRXhwKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jb250ZW50ID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0tleUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY29udGVudCA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVLZXlJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWtleS5pc0hhbmRsZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHluYW1pY0tleSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbY2xhc3NLZXlJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVByb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tzdHlsZUtleUluZGV4XTtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGR5bmFtaWMga2V5XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0R5bmFtaWNLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9DTEFTUyksIFtjbGFzc1Byb3AudmFsdWVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNTdGF0aWNFeHAoc3R5bGVQcm9wLnZhbHVlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3RhdGljIHN0eWxlIGlzIGNvbXBpbGVkIGludG8gYW4gb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgYGhhc1N0eWxlQmluZGluZ2AgdG8gZW5zdXJlIHRoYXQgaXQgaXMgYSBkeW5hbWljIHN0eWxlIGJpbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc1N0eWxlQmluZGluZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIHdpdGggc3RhdGljIGxpdGVyYWwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1NUWUxFKSwgW3N0eWxlUHJvcC52YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMga2V5IGJpbmRpbmcsIHdyYXAgd2l0aCBgbm9ybWFsaXplUHJvcHNgXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSwgW3Byb3BzRXhwcmVzc2lvbl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2VQcm9wcyBjYWxsLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmRcclxuICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihHVUFSRF9SRUFDVElWRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHJ1bnRpbWVEaXJlY3RpdmVzLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLFxyXG4gICAgICAgIHNob3VsZFVzZUJsb2NrXHJcbiAgICB9O1xyXG59XHJcbi8vIERlZHVwZSBwcm9wcyBpbiBhbiBvYmplY3QgbGl0ZXJhbC5cclxuLy8gTGl0ZXJhbCBkdXBsaWNhdGVkIGF0dHJpYnV0ZXMgd291bGQgaGF2ZSBiZWVuIHdhcm5lZCBkdXJpbmcgdGhlIHBhcnNlIHBoYXNlLFxyXG4vLyBob3dldmVyLCBpdCdzIHBvc3NpYmxlIHRvIGVuY291bnRlciBkdXBsaWNhdGVkIGBvblhYWGAgaGFuZGxlcnMgd2l0aCBkaWZmZXJlbnRcclxuLy8gbW9kaWZpZXJzLiBXZSBhbHNvIG5lZWQgdG8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIGNsYXNzIC8gc3R5bGUgYXR0cmlidXRlcy5cclxuLy8gLSBvblhYWCBoYW5kbGVycyAvIHN0eWxlOiBtZXJnZSBpbnRvIGFycmF5XHJcbi8vIC0gY2xhc3M6IG1lcmdlIGludG8gc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBjb25jYXRlbmF0aW9uXHJcbmZ1bmN0aW9uIGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcykge1xyXG4gICAgY29uc3Qga25vd25Qcm9wcyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGRlZHVwZWQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIC8vIGR5bmFtaWMga2V5cyBhcmUgYWx3YXlzIGFsbG93ZWRcclxuICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovIHx8ICFwcm9wLmtleS5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IGtub3duUHJvcHMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJyB8fCBuYW1lID09PSAnY2xhc3MnIHx8IGlzT24obmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlQXNBcnJheShleGlzdGluZywgcHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWR1cGVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcclxuICAgIGlmIChleGlzdGluZy52YWx1ZS50eXBlID09PSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBkaXJBcmdzID0gW107XHJcbiAgICBjb25zdCBydW50aW1lID0gZGlyZWN0aXZlSW1wb3J0TWFwLmdldChkaXIpO1xyXG4gICAgaWYgKHJ1bnRpbWUpIHtcclxuICAgICAgICAvLyBidWlsdC1pbiBkaXJlY3RpdmUgd2l0aCBydW50aW1lXHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGNvbnRleHQuaGVscGVyU3RyaW5nKHJ1bnRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RJUkVDVElWRSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlcy5hZGQoZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcclxuICAgIGlmIChkaXIuZXhwKVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuZXhwKTtcclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuYXJnKTtcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWRpci5hcmcpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRydWVFeHByZXNzaW9uID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgICAgIGRpckFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRpci5tb2RpZmllcnMubWFwKG1vZGlmaWVyID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbikpLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyQXJncywgZGlyLmxvYyk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xyXG4gICAgbGV0IHByb3BzTmFtZXNTdHJpbmcgPSBgW2A7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xyXG4gICAgICAgIGlmIChpIDwgbCAtIDEpXHJcbiAgICAgICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gJywgJztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wc05hbWVzU3RyaW5nICsgYF1gO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xyXG4gICAgcmV0dXJuIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgdGFnID09PSAnQ29tcG9uZW50JztcclxufVxuXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcblxuY29uc3QgdHJhbnNmb3JtU2xvdE91dGxldCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoaXNTbG90T3V0bGV0KG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdE5hbWUsIHNsb3RQcm9wcyB9ID0gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc2xvdEFyZ3MgPSBbXHJcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXHJcbiAgICAgICAgICAgIHNsb3ROYW1lLFxyXG4gICAgICAgICAgICAne30nLFxyXG4gICAgICAgICAgICAndW5kZWZpbmVkJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXTtcclxuICAgICAgICBsZXQgZXhwZWN0ZWRMZW4gPSAyO1xyXG4gICAgICAgIGlmIChzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgc2xvdEFyZ3NbMl0gPSBzbG90UHJvcHM7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzbG90QXJnc1szXSA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5zY29wZUlkICYmICFjb250ZXh0LnNsb3R0ZWQpIHtcclxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbG90QXJncy5zcGxpY2UoZXhwZWN0ZWRMZW4pOyAvLyByZW1vdmUgdW51c2VkIGFyZ3VtZW50c1xyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfU0xPVCksIHNsb3RBcmdzLCBsb2MpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgc2xvdE5hbWUgPSBgXCJkZWZhdWx0XCJgO1xyXG4gICAgbGV0IHNsb3RQcm9wcyA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IG5vbk5hbWVQcm9wcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICduYW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gSlNPTi5zdHJpbmdpZnkocC52YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAubmFtZSA9IGNhbWVsaXplKHAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCAnbmFtZScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBwLmV4cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmFyZyAmJiBpc1N0YXRpY0V4cChwLmFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzKTtcclxuICAgICAgICBzbG90UHJvcHMgPSBwcm9wcztcclxuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzYgLyogWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi8sIGRpcmVjdGl2ZXNbMF0ubG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzbG90TmFtZSxcclxuICAgICAgICBzbG90UHJvcHNcclxuICAgIH07XHJcbn1cblxuY29uc3QgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3woYXN5bmNcXHMqKT9cXChbXildKj9cXCkpXFxzKj0+fF5cXHMqKGFzeW5jXFxzKyk/ZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvYywgbW9kaWZpZXJzLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZGlyLmV4cCAmJiAhbW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM1IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIGxldCBldmVudE5hbWU7XHJcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGxldCByYXdOYW1lID0gYXJnLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gZGVwcmVjYXRlIEB2bm9kZVhYWCB1c2FnZVxyXG4gICAgICAgICAgICBpZiAocmF3TmFtZS5zdGFydHNXaXRoKCd2dWU6JykpIHtcclxuICAgICAgICAgICAgICAgIHJhd05hbWUgPSBgdm5vZGUtJHtyYXdOYW1lLnNsaWNlKDQpfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMsIGF1dG8gY29udmVydCBpdCB0byBjYW1lbENhc2UuIFNlZSBpc3N1ZSAjMjI0OVxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHRvSGFuZGxlcktleShjYW1lbGl6ZSQxKHJhd05hbWUpKSwgdHJ1ZSwgYXJnLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAjMjM4OFxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgLFxyXG4gICAgICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGFscmVhZHkgYSBjb21wb3VuZCBleHByZXNzaW9uLlxyXG4gICAgICAgIGV2ZW50TmFtZSA9IGFyZztcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGApO1xyXG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGVyIHByb2Nlc3NpbmdcclxuICAgIGxldCBleHAgPSBkaXIuZXhwO1xyXG4gICAgaWYgKGV4cCAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgZXhwID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IHNob3VsZENhY2hlID0gY29udGV4dC5jYWNoZUhhbmRsZXJzICYmICFleHAgJiYgIWNvbnRleHQuaW5WT25jZTtcclxuICAgIGlmIChleHApIHtcclxuICAgICAgICBjb25zdCBpc01lbWJlckV4cCA9IGlzTWVtYmVyRXhwcmVzc2lvbihleHAuY29udGVudCk7XHJcbiAgICAgICAgY29uc3QgaXNJbmxpbmVTdGF0ZW1lbnQgPSAhKGlzTWVtYmVyRXhwIHx8IGZuRXhwUkUudGVzdChleHAuY29udGVudCkpO1xyXG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlU3RhdGVtZW50cyA9IGV4cC5jb250ZW50LmluY2x1ZGVzKGA7YCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBmYWxzZSwgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzSW5saW5lU3RhdGVtZW50IHx8IChzaG91bGRDYWNoZSAmJiBpc01lbWJlckV4cCkpIHtcclxuICAgICAgICAgICAgLy8gd3JhcCBpbmxpbmUgc3RhdGVtZW50IGluIGEgZnVuY3Rpb24gZXhwcmVzc2lvblxyXG4gICAgICAgICAgICBleHAgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IGAkZXZlbnRgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtgYH0oLi4uYXJncylgfSA9PiAke2hhc011bHRpcGxlU3RhdGVtZW50cyA/IGB7YCA6IGAoYH1gLFxyXG4gICAgICAgICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgICAgICAgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYH1gIDogYClgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCByZXQgPSB7XHJcbiAgICAgICAgcHJvcHM6IFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgKCkgPT4ge31gLCBmYWxzZSwgbG9jKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG4gICAgLy8gYXBwbHkgZXh0ZW5kZWQgY29tcGlsZXIgYXVnbWVudG9yXHJcbiAgICBpZiAoYXVnbWVudG9yKSB7XHJcbiAgICAgICAgcmV0ID0gYXVnbWVudG9yKHJldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcclxuICAgICAgICAvLyBjYWNoZSBoYW5kbGVycyBzbyB0aGF0IGl0J3MgYWx3YXlzIHRoZSBzYW1lIGhhbmRsZXIgYmVpbmcgcGFzc2VkIGRvd24uXHJcbiAgICAgICAgLy8gdGhpcyBhdm9pZHMgdW5uZWNlc3NhcnkgcmUtcmVuZGVycyB3aGVuIHVzZXJzIHVzZSBpbmxpbmUgaGFuZGxlcnMgb25cclxuICAgICAgICAvLyBjb21wb25lbnRzLlxyXG4gICAgICAgIHJldC5wcm9wc1swXS52YWx1ZSA9IGNvbnRleHQuY2FjaGUocmV0LnByb3BzWzBdLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIG1hcmsgdGhlIGtleSBhcyBoYW5kbGVyIGZvciBwcm9wcyBub3JtYWxpemF0aW9uIGNoZWNrXHJcbiAgICByZXQucHJvcHMuZm9yRWFjaChwID0+IChwLmtleS5pc0hhbmRsZXJLZXkgPSB0cnVlKSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xuXG4vLyB2LWJpbmQgd2l0aG91dCBhcmcgaXMgaGFuZGxlZCBkaXJlY3RseSBpbiAuL3RyYW5zZm9ybUVsZW1lbnRzLnRzIGR1ZSB0byBpdCBhZmZlY3RpbmdcclxuLy8gY29kZWdlbiBmb3IgdGhlIGVudGlyZSBwcm9wcyBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGhlcmUgaXMgb25seSBmb3Igdi1iaW5kXHJcbi8vICp3aXRoKiBhcmdzLlxyXG5jb25zdCB0cmFuc2Zvcm1CaW5kID0gKGRpciwgX25vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBtb2RpZmllcnMsIGxvYyB9ID0gZGlyO1xyXG4gICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgIGlmIChhcmcudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAoYCk7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYCkgfHwgXCJcImApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgIGFyZy5jb250ZW50ID0gYCR7YXJnLmNvbnRlbnR9IHx8IFwiXCJgO1xyXG4gICAgfVxyXG4gICAgLy8gLnN5bmMgaXMgcmVwbGFjZWQgYnkgdi1tb2RlbDphcmdcclxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykpIHtcclxuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZSQxKGFyZy5jb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfSgke2FyZy5jb250ZW50fSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KGApO1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY29udGV4dC5pblNTUikge1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xyXG4gICAgICAgICAgICBpbmplY3RQcmVmaXgoYXJnLCAnLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdhdHRyJykpIHtcclxuICAgICAgICAgICAgaW5qZWN0UHJlZml4KGFyZywgJ14nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWV4cCB8fFxyXG4gICAgICAgIChleHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM0IC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlLCBsb2MpKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgZXhwKV1cclxuICAgIH07XHJcbn07XHJcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xyXG4gICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBhcmcuY29udGVudCA9IHByZWZpeCArIGFyZy5jb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBgXFxgJHtwcmVmaXh9XFwkeyR7YXJnLmNvbnRlbnR9fVxcYGA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCcke3ByZWZpeH0nICsgKGApO1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICB9XHJcbn07XG5cbi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgYW5kIGV4cHJlc3Npb25zIGludG8gYSBzaW5nbGUgZXhwcmVzc2lvblxyXG4vLyBlLmcuIDxkaXY+YWJjIHt7IGQgfX0ge3sgZSB9fTwvZGl2PiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBleHByZXNzaW9uIG5vZGUgYXMgY2hpbGQuXHJcbmNvbnN0IHRyYW5zZm9ybVRleHQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMCAvKiBST09UICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDExIC8qIEZPUiAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTAgLyogSUZfQlJBTkNIICovKSB7XHJcbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgdHJhbnNmb3JtIG9uIG5vZGUgZXhpdCBzbyB0aGF0IGFsbCBleHByZXNzaW9ucyBoYXZlIGFscmVhZHlcclxuICAgICAgICAvLyBiZWVuIHByb2Nlc3NlZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHQobmV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBjaGlsZHJlbltpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlIGludG8gY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGAgKyBgLCBuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhhc1RleHQgfHxcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IHdpdGggYSBzaW5nbGUgdGV4dCBjaGlsZCwgbGVhdmUgaXRcclxuICAgICAgICAgICAgICAgIC8vIGFzLWlzIHNpbmNlIHRoZSBydW50aW1lIGhhcyBkZWRpY2F0ZWQgZmFzdCBwYXRoIGZvciB0aGlzIGJ5IGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbXBvbmVudCByb290IGl0J3MgYWx3YXlzIG5vcm1hbGl6ZWQgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDAgLyogUk9PVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAjMzc1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcmVjdGl2ZXMgY2FuIHBvdGVudGlhbGx5IGFkZCBET00gZWxlbWVudHMgYXJiaXRyYXJpbHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQgYXQgcnVudGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgYWNjaWRlbnRhbGx5IG92ZXJ3cml0aW5nIHRoZSBET00gZWxlbWVudHMgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggY3VzdG9tIGRpcmVjdGl2ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9kZS5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbcC5uYW1lXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbXBhdCBtb2RlLCA8dGVtcGxhdGU+IHRhZ3Mgd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBmcmFnbWVudCBzbyBpdHMgY2hpbGRyZW4gbXVzdCBiZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIGludG8gdm5vZGVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShub2RlLnRhZyA9PT0gJ3RlbXBsYXRlJykpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmUtY29udmVydCB0ZXh0IG5vZGVzIGludG8gY3JlYXRlVGV4dFZOb2RlKHRleHQpIGNhbGxzIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RleHQoY2hpbGQpIHx8IGNoaWxkLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxBcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlVGV4dFZOb2RlIGRlZmF1bHRzIHRvIHNpbmdsZSB3aGl0ZXNwYWNlLCBzbyBpZiBpdCBpcyBhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIHNwYWNlIHRoZSBjb2RlIGNvdWxkIGJlIGFuIGVtcHR5IGNhbGwgdG8gc2F2ZSBieXRlcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gMiAvKiBURVhUICovIHx8IGNoaWxkLmNvbnRlbnQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayBkeW5hbWljIHRleHQgd2l0aCBmbGFnIHNvIGl0IGdldHMgcGF0Y2hlZCBpbnNpZGUgYSBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaCgxIC8qIFRFWFQgKi8gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1sxIC8qIFRFWFQgKi9dfSAqL2AgOiBgYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTIgLyogVEVYVF9DQUxMICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjaGlsZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlOiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfVEVYVCksIGNhbGxBcmdzKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCBzZWVuID0gbmV3IFdlYWtTZXQoKTtcclxuY29uc3QgdHJhbnNmb3JtT25jZSA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgZmluZERpcihub2RlLCAnb25jZScsIHRydWUpKSB7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKG5vZGUpIHx8IGNvbnRleHQuaW5WT25jZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4uYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRleHQuaW5WT25jZSA9IHRydWU7XHJcbiAgICAgICAgY29udGV4dC5oZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250ZXh0LmluVk9uY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgY3VyID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1ci5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlID0gY29udGV4dC5jYWNoZShjdXIuY29kZWdlbk5vZGUsIHRydWUgLyogaXNWTm9kZSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBhcmcgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDEgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xyXG4gICAgY29uc3QgZXhwU3RyaW5nID0gZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gPyBleHAuY29udGVudCA6IHJhd0V4cDtcclxuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cclxuICAgIC8vIF91bnJlZihleHApXHJcbiAgICBjb250ZXh0LmJpbmRpbmdNZXRhZGF0YVtyYXdFeHBdO1xyXG4gICAgY29uc3QgbWF5YmVSZWYgPSAhdHJ1ZSAgICAvKiBTRVRVUF9DT05TVCAqLztcclxuICAgIGlmICghZXhwU3RyaW5nLnRyaW0oKSB8fFxyXG4gICAgICAgICghaXNNZW1iZXJFeHByZXNzaW9uKGV4cFN0cmluZykgJiYgIW1heWJlUmVmKSkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQyIC8qIFhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZXhwLmxvYykpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcE5hbWUgPSBhcmcgPyBhcmcgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdtb2RlbFZhbHVlJywgdHJ1ZSk7XHJcbiAgICBjb25zdCBldmVudE5hbWUgPSBhcmdcclxuICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgPyBgb25VcGRhdGU6JHthcmcuY29udGVudH1gXHJcbiAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFsnXCJvblVwZGF0ZTpcIiArICcsIGFyZ10pXHJcbiAgICAgICAgOiBgb25VcGRhdGU6bW9kZWxWYWx1ZWA7XHJcbiAgICBsZXQgYXNzaWdubWVudEV4cDtcclxuICAgIGNvbnN0IGV2ZW50QXJnID0gY29udGV4dC5pc1RTID8gYCgkZXZlbnQ6IGFueSlgIDogYCRldmVudGA7XHJcbiAgICB7XHJcbiAgICAgICAgYXNzaWdubWVudEV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgIGAke2V2ZW50QXJnfSA9PiAoKGAsXHJcbiAgICAgICAgICAgIGV4cCxcclxuICAgICAgICAgICAgYCkgPSAkZXZlbnQpYFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcHMgPSBbXHJcbiAgICAgICAgLy8gbW9kZWxWYWx1ZTogZm9vXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkocHJvcE5hbWUsIGRpci5leHApLFxyXG4gICAgICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGFzc2lnbm1lbnRFeHApXHJcbiAgICBdO1xyXG4gICAgLy8gbW9kZWxNb2RpZmllcnM6IHsgZm9vOiB0cnVlLCBcImJhci1iYXpcIjogdHJ1ZSB9XHJcbiAgICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnNcclxuICAgICAgICAgICAgLm1hcChtID0+IChpc1NpbXBsZUlkZW50aWZpZXIobSkgPyBtIDogSlNPTi5zdHJpbmdpZnkobSkpICsgYDogdHJ1ZWApXHJcbiAgICAgICAgICAgIC5qb2luKGAsIGApO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZ1xyXG4gICAgICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgICAgID8gYCR7YXJnLmNvbnRlbnR9TW9kaWZpZXJzYFxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2FyZywgJyArIFwiTW9kaWZpZXJzXCInXSlcclxuICAgICAgICAgICAgOiBgbW9kZWxNb2RpZmllcnNgO1xyXG4gICAgICAgIHByb3BzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXJzS2V5LCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB7ICR7bW9kaWZpZXJzfSB9YCwgZmFsc2UsIGRpci5sb2MsIDIgLyogQ0FOX0hPSVNUICovKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMgPSBbXSkge1xyXG4gICAgcmV0dXJuIHsgcHJvcHMgfTtcclxufVxuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xyXG5jb25zdCB0cmFuc2Zvcm1GaWx0ZXIgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLykge1xyXG4gICAgICAgIC8vIGZpbHRlciByZXdyaXRlIGlzIGFwcGxpZWQgYmVmb3JlIGV4cHJlc3Npb24gdHJhbnNmb3JtIHNvIG9ubHlcclxuICAgICAgICAvLyBzaW1wbGUgZXhwcmVzc2lvbnMgYXJlIHBvc3NpYmxlIGF0IHRoaXMgc3RhZ2VcclxuICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHByb3ApID0+IHtcclxuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgIHByb3AubmFtZSAhPT0gJ2ZvcicgJiZcclxuICAgICAgICAgICAgICAgIHByb3AuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKHByb3AuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUZpbHRlcihjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihjaGlsZC5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBleHAgPSBub2RlLmNvbnRlbnQ7XHJcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcclxuICAgIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gICAgbGV0IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgICBsZXQgY3VybHkgPSAwO1xyXG4gICAgbGV0IHNxdWFyZSA9IDA7XHJcbiAgICBsZXQgcGFyZW4gPSAwO1xyXG4gICAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XHJcbiAgICBsZXQgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByZXYgPSBjO1xyXG4gICAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoaW5TaW5nbGUpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluRG91YmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluUmVnZXgpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluUmVnZXggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHg3YyAmJiAvLyBwaXBlXHJcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3YyAmJlxyXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N2MgJiZcclxuICAgICAgICAgICAgIWN1cmx5ICYmXHJcbiAgICAgICAgICAgICFzcXVhcmUgJiZcclxuICAgICAgICAgICAgIXBhcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDIyOlxyXG4gICAgICAgICAgICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXCJcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyNzpcclxuICAgICAgICAgICAgICAgICAgICBpblNpbmdsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vICdcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg2MDpcclxuICAgICAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYFxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIChcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyOTpcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyApXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWI6XHJcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg1ZDpcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUtLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXVxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDdiOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cmx5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg3ZDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJseS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIC9cclxuICAgICAgICAgICAgICAgIGxldCBqID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJyAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xyXG4gICAgICAgIGZpbHRlcnMucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xyXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX0ZJTFRFUlwiIC8qIENPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQsIG5vZGUubG9jKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb250ZW50ID0gZXhwcmVzc2lvbjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cmFwRmlsdGVyKGV4cCwgZmlsdGVyLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0ZJTFRFUik7XHJcbiAgICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsdGVycy5hZGQoZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQoZmlsdGVyLCAnZmlsdGVyJyl9KCR7ZXhwfSlgO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcclxuICAgICAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMuYWRkKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChuYW1lLCAnZmlsdGVyJyl9KCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcclxuICAgIH1cclxufVxuXG5jb25zdCBzZWVuJDEgPSBuZXcgV2Vha1NldCgpO1xyXG5jb25zdCB0cmFuc2Zvcm1NZW1vID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IGZpbmREaXIobm9kZSwgJ21lbW8nKTtcclxuICAgICAgICBpZiAoIWRpciB8fCBzZWVuJDEuaGFzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VlbiQxLmFkZChub2RlKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGUgfHxcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZSAmJiBjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub24tY29tcG9uZW50IHN1YiB0cmVlIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VCbG9jayhjb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoV0lUSF9NRU1PKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5leHAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHVuZGVmaW5lZCwgY29kZWdlbk5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGBfY2FjaGVgLFxyXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyhjb250ZXh0LmNhY2hlZCsrKVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT25jZSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtSWYsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU1lbW8sXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUZvcixcclxuICAgICAgICAgICAgLi4uKFt0cmFuc2Zvcm1GaWx0ZXJdICksXHJcbiAgICAgICAgICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXVxyXG4gICAgICAgICAgICAgICAgICAgIDogW10pLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1TbG90T3V0bGV0LFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1FbGVtZW50LFxyXG4gICAgICAgICAgICB0cmFja1Nsb3RTY29wZXMsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVRleHRcclxuICAgICAgICBdLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb246IHRyYW5zZm9ybU9uLFxyXG4gICAgICAgICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxyXG4gICAgICAgICAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWxcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG59XHJcbi8vIHdlIG5hbWUgaXQgYGJhc2VDb21waWxlYCBzbyB0aGF0IGhpZ2hlciBvcmRlciBjb21waWxlcnMgbGlrZVxyXG4vLyBAdnVlL2NvbXBpbGVyLWRvbSBjYW4gZXhwb3J0IGBjb21waWxlYCB3aGlsZSByZS1leHBvcnRpbmcgZXZlcnl0aGluZyBlbHNlLlxyXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xyXG4gICAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnbW9kdWxlJztcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeElkZW50aWZpZXJzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NiAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTW9kdWxlTW9kZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDcgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcHJlZml4SWRlbnRpZmllcnMgPSAhdHJ1ZSA7XHJcbiAgICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ4IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5zY29wZUlkICYmICFpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDkgLyogWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc3QgPSBpc1N0cmluZyh0ZW1wbGF0ZSkgPyBiYXNlUGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIDogdGVtcGxhdGU7XHJcbiAgICBjb25zdCBbbm9kZVRyYW5zZm9ybXMsIGRpcmVjdGl2ZVRyYW5zZm9ybXNdID0gZ2V0QmFzZVRyYW5zZm9ybVByZXNldCgpO1xyXG4gICAgdHJhbnNmb3JtKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcclxuICAgICAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgZGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9IC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICAgIClcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzXHJcbiAgICB9KSk7XHJcbn1cblxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcblxuZXhwb3J0IHsgQkFTRV9UUkFOU0lUSU9OLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX0VMRU1FTlRfQkxPQ0ssIENSRUFURV9FTEVNRU5UX1ZOT0RFLCBDUkVBVEVfU0xPVFMsIENSRUFURV9TVEFUSUMsIENSRUFURV9URVhULCBDUkVBVEVfVk5PREUsIEZSQUdNRU5ULCBHVUFSRF9SRUFDVElWRV9QUk9QUywgSVNfTUVNT19TQU1FLCBJU19SRUYsIEtFRVBfQUxJVkUsIE1FUkdFX1BST1BTLCBOT1JNQUxJWkVfQ0xBU1MsIE5PUk1BTElaRV9QUk9QUywgTk9STUFMSVpFX1NUWUxFLCBPUEVOX0JMT0NLLCBQT1BfU0NPUEVfSUQsIFBVU0hfU0NPUEVfSUQsIFJFTkRFUl9MSVNULCBSRU5ERVJfU0xPVCwgUkVTT0xWRV9DT01QT05FTlQsIFJFU09MVkVfRElSRUNUSVZFLCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5ULCBSRVNPTFZFX0ZJTFRFUiwgU0VUX0JMT0NLX1RSQUNLSU5HLCBTVVNQRU5TRSwgVEVMRVBPUlQsIFRPX0RJU1BMQVlfU1RSSU5HLCBUT19IQU5ETEVSUywgVE9fSEFORExFUl9LRVksIFVOUkVGLCBXSVRIX0NUWCwgV0lUSF9ESVJFQ1RJVkVTLCBXSVRIX01FTU8sIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkRGlyZWN0aXZlQXJncywgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY2hlY2tDb21wYXRFbmFibGVkLCBjcmVhdGVBcnJheUV4cHJlc3Npb24sIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVCbG9ja1N0YXRlbWVudCwgY3JlYXRlQ2FjaGVFeHByZXNzaW9uLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24sIGNyZWF0ZUZvckxvb3BQYXJhbXMsIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiwgY3JlYXRlSWZTdGF0ZW1lbnQsIGNyZWF0ZUludGVycG9sYXRpb24sIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24sIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQsIGNyZWF0ZVJvb3QsIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSwgY3JlYXRlVGVtcGxhdGVMaXRlcmFsLCBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0LCBjcmVhdGVWTm9kZUNhbGwsIGV4dHJhY3RJZGVudGlmaWVycywgZmluZERpciwgZmluZFByb3AsIGdlbmVyYXRlLCBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0LCBnZXRJbm5lclJhbmdlLCBnZXRNZW1vZWRWTm9kZUNhbGwsIGdldFZOb2RlQmxvY2tIZWxwZXIsIGdldFZOb2RlSGVscGVyLCBoYXNEeW5hbWljS2V5VkJpbmQsIGhhc1Njb3BlUmVmLCBoZWxwZXJOYW1lTWFwLCBpbmplY3RQcm9wLCBpc0J1aWx0SW5UeXBlLCBpc0NvcmVDb21wb25lbnQsIGlzRnVuY3Rpb25UeXBlLCBpc0luRGVzdHJ1Y3R1cmVBc3NpZ25tZW50LCBpc01lbWJlckV4cHJlc3Npb24sIGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIsIGlzTWVtYmVyRXhwcmVzc2lvbk5vZGUsIGlzUmVmZXJlbmNlZElkZW50aWZpZXIsIGlzU2ltcGxlSWRlbnRpZmllciwgaXNTbG90T3V0bGV0LCBpc1N0YXRpY0FyZ09mLCBpc1N0YXRpY0V4cCwgaXNTdGF0aWNQcm9wZXJ0eSwgaXNTdGF0aWNQcm9wZXJ0eUtleSwgaXNUZW1wbGF0ZU5vZGUsIGlzVGV4dCwgaXNWU2xvdCwgbG9jU3R1YiwgbWFrZUJsb2NrLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBwcm9jZXNzRXhwcmVzc2lvbiwgcHJvY2Vzc0ZvciwgcHJvY2Vzc0lmLCBwcm9jZXNzU2xvdE91dGxldCwgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgcmVzb2x2ZUNvbXBvbmVudFR5cGUsIHRvVmFsaWRBc3NldElkLCB0cmFja1Nsb3RTY29wZXMsIHRyYWNrVkZvclNsb3RTY29wZXMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtQmluZCwgdHJhbnNmb3JtRWxlbWVudCwgdHJhbnNmb3JtRXhwcmVzc2lvbiwgdHJhbnNmb3JtTW9kZWwsIHRyYW5zZm9ybU9uLCB0cmF2ZXJzZU5vZGUsIHdhbGtCbG9ja0RlY2xhcmF0aW9ucywgd2Fsa0Z1bmN0aW9uUGFyYW1zLCB3YWxrSWRlbnRpZmllcnMsIHdhcm5EZXByZWNhdGlvbiB9O1xuIiwiaW1wb3J0IHsgcmVnaXN0ZXJSdW50aW1lSGVscGVycywgaXNCdWlsdEluVHlwZSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBpc1N0YXRpY0V4cCwgY2hlY2tDb21wYXRFbmFibGVkLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc1ZvaWRUYWcsIGlzSFRNTFRhZywgaXNTVkdUYWcsIG1ha2VNYXAsIHBhcnNlU3RyaW5nU3R5bGUsIGNhcGl0YWxpemUsIGV4dGVuZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xyXG5jb25zdCBWX01PREVMX0NIRUNLQk9YID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxDaGVja2JveGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfU0VMRUNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxTZWxlY3RgIDogYGApO1xyXG5jb25zdCBWX01PREVMX0RZTkFNSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbER5bmFtaWNgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfTU9ESUZJRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYCk7XHJcbmNvbnN0IFZfT05fV0lUSF9LRVlTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25LZXlzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX1NIT1cgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZTaG93YCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT05fR1JPVVAgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYCk7XHJcbnJlZ2lzdGVyUnVudGltZUhlbHBlcnMoe1xyXG4gICAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxyXG4gICAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxyXG4gICAgW1ZfTU9ERUxfVEVYVF06IGB2TW9kZWxUZXh0YCxcclxuICAgIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxyXG4gICAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcclxuICAgIFtWX09OX1dJVEhfTU9ESUZJRVJTXTogYHdpdGhNb2RpZmllcnNgLFxyXG4gICAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcclxuICAgIFtWX1NIT1ddOiBgdlNob3dgLFxyXG4gICAgW1RSQU5TSVRJT05dOiBgVHJhbnNpdGlvbmAsXHJcbiAgICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXHJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGRlY29kZXI7XHJcbmZ1bmN0aW9uIGRlY29kZUh0bWxCcm93c2VyKHJhdywgYXNBdHRyID0gZmFsc2UpIHtcclxuICAgIGlmICghZGVjb2Rlcikge1xyXG4gICAgICAgIGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIH1cclxuICAgIGlmIChhc0F0dHIpIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IGA8ZGl2IGZvbz1cIiR7cmF3LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKX1cIj5gO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVyLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgnZm9vJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IHJhdztcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3N0eWxlLGlmcmFtZSxzY3JpcHQsbm9zY3JpcHQnLCB0cnVlKTtcclxuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGlzVm9pZFRhZyxcclxuICAgIGlzTmF0aXZlVGFnOiB0YWcgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcclxuICAgIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXHJcbiAgICBpc0J1aWx0SW5Db21wb25lbnQ6ICh0YWcpID0+IHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbkdyb3VwYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT05fR1JPVVA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXHJcbiAgICBnZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpIHtcclxuICAgICAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMiAvKiBNQVRIX01MICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnYW5ub3RhdGlvbi14bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNWRyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShhID0+IGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICBhLm5hbWUgPT09ICdlbmNvZGluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBhLnZhbHVlICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAoYS52YWx1ZS5jb250ZW50ID09PSAndGV4dC9odG1sJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnZhbHVlLmNvbnRlbnQgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgvXm0oPzpbaW9uc118dGV4dCkkLy50ZXN0KHBhcmVudC50YWcpICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtZ2x5cGgnICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtYWxpZ25tYXJrJykge1xyXG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICYmIG5zID09PSAxIC8qIFNWRyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAnZGVzYycgfHxcclxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBNQVRIX01MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBucztcclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1odG1sLWZyYWdtZW50c1xyXG4gICAgZ2V0VGV4dE1vZGUoeyB0YWcsIG5zIH0pIHtcclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnIHx8IHRhZyA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUkNEQVRBICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Jhd1RleHRDb250YWluZXIodGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUkFXVEVYVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMCAvKiBEQVRBICovO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQYXJzZSBpbmxpbmUgQ1NTIHN0cmluZ3MgZm9yIHN0YXRpYyBzdHlsZSBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0LlxyXG4vLyBUaGlzIGlzIGEgTm9kZVRyYW5zZm9ybSBzaW5jZSBpdCB3b3JrcyBvbiB0aGUgc3RhdGljIGBzdHlsZWAgYXR0cmlidXRlIGFuZFxyXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxyXG4vLyBzdHlsZT1cImNvbG9yOiByZWRcIiAtPiA6c3R5bGU9J3sgXCJjb2xvclwiOiBcInJlZFwiIH0nXHJcbi8vIEl0IGlzIHRoZW4gcHJvY2Vzc2VkIGJ5IGB0cmFuc2Zvcm1FbGVtZW50YCBhbmQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZFxyXG4vLyBwcm9wcy5cclxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBub2RlID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwIHdpdGggYW4gZXhwcmVzc2lvbiBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBiaW5kYCxcclxuICAgICAgICAgICAgICAgICAgICBhcmc6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCk7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihKU09OLnN0cmluZ2lmeShub3JtYWxpemVkKSwgZmFsc2UsIGxvYywgMyAvKiBDQU5fU1RSSU5HSUZZICovKTtcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MpIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XHJcbn1cclxuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFs1MCAvKiBYX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovXTogYHYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MSAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovXTogYHYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MiAvKiBYX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovXTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MyAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovXTogYHYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1NCAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5gLFxyXG4gICAgWzU1IC8qIFhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqL106IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcclxuICAgIFs1NiAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXHJcbiAgICBbNTcgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcclxuICAgIFs1OCAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1OSAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqL106IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxyXG4gICAgWzYwIC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi9dOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTAgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MSAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGlubmVySFRNTGAsIHRydWUsIGxvYyksIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MyAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlclN0cmluZyhUT19ESVNQTEFZX1NUUklORyksIFtleHBdLCBsb2MpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgYmFzZVJlc3VsdCA9IHRyYW5zZm9ybU1vZGVsJDEoZGlyLCBub2RlLCBjb250ZXh0KTtcclxuICAgIC8vIGJhc2UgdHJhbnNmb3JtIGhhcyBlcnJvcnMgT1IgY29tcG9uZW50IHYtbW9kZWwgKG9ubHkgbmVlZCBwcm9wcylcclxuICAgIGlmICghYmFzZVJlc3VsdC5wcm9wcy5sZW5ndGggfHwgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5hcmcpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NSAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi8sIGRpci5hcmcubG9jKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpbmRQcm9wKG5vZGUsICd2YWx1ZScpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NyAvKiBYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi8sIHZhbHVlLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gY29udGV4dC5pc0N1c3RvbUVsZW1lbnQodGFnKTtcclxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHxcclxuICAgICAgICB0YWcgPT09ICd0ZXh0YXJlYScgfHxcclxuICAgICAgICB0YWcgPT09ICdzZWxlY3QnIHx8XHJcbiAgICAgICAgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9URVhUO1xyXG4gICAgICAgIGxldCBpc0ludmFsaWRUeXBlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpbmRQcm9wKG5vZGUsIGB0eXBlYCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDp0eXBlPVwiZm9vXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0NIRUNLQk9YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkVHlwZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NiAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBiaW5kaW5ncyB3aXRoIGR5bmFtaWMga2V5cywgd2hpY2ggY2FuIHBvc3NpYmx5IGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIFwidHlwZVwiLlxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1NFTEVDVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRleHRhcmVhXHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcnVudGltZSBkaXJlY3RpdmVcclxuICAgICAgICAvLyBieSByZXR1cm5pbmcgdGhlIGhlbHBlciBzeW1ib2wgdmlhIG5lZWRSdW50aW1lXHJcbiAgICAgICAgLy8gdGhlIGltcG9ydCB3aWxsIHJlcGxhY2VkIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxyXG4gICAgICAgIGlmICghaXNJbnZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICBiYXNlUmVzdWx0Lm5lZWRSdW50aW1lID0gY29udGV4dC5oZWxwZXIoZGlyZWN0aXZlVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU0IC8qIFhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSB2bW9kZWwgZG9lc24ndCBuZWVkIHRoZSBgbW9kZWxWYWx1ZWAgcHJvcHMgc2luY2UgdGhleSBhcmUgYWxzb1xyXG4gICAgLy8gcGFzc2VkIHRvIHRoZSBydW50aW1lIGFzIGBiaW5kaW5nLnZhbHVlYC4gcmVtb3ZpbmcgaXQgcmVkdWNlcyBjb2RlIHNpemUuXHJcbiAgICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIocCA9PiAhKHAua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICBwLmtleS5jb250ZW50ID09PSAnbW9kZWxWYWx1ZScpKTtcclxuICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG59O1xuXG5jb25zdCBpc0V2ZW50T3B0aW9uTW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XHJcbmNvbnN0IGlzTm9uS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIGV2ZW50IHByb3BhZ2F0aW9uIG1hbmFnZW1lbnRcclxuYHN0b3AscHJldmVudCxzZWxmLGAgK1xyXG4gICAgLy8gc3lzdGVtIG1vZGlmaWVycyArIGV4YWN0XHJcbiAgICBgY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCxgICtcclxuICAgIC8vIG1vdXNlXHJcbiAgICBgbWlkZGxlYCk7XHJcbi8vIGxlZnQgJiByaWdodCBjb3VsZCBiZSBtb3VzZSBvciBrZXkgbW9kaWZpZXJzIGJhc2VkIG9uIGV2ZW50IHR5cGVcclxuY29uc3QgbWF5YmVLZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnbGVmdCxyaWdodCcpO1xyXG5jb25zdCBpc0tleWJvYXJkRXZlbnQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYG9ua2V5dXAsb25rZXlkb3duLG9ua2V5cHJlc3NgLCB0cnVlKTtcclxuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycywgY29udGV4dCwgbG9jKSA9PiB7XHJcbiAgICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IG5vbktleU1vZGlmaWVycyA9IFtdO1xyXG4gICAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBtb2RpZmllcnNbaV07XHJcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnbmF0aXZlJyAmJlxyXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENPTVBJTEVSX1ZfT05fTkFUSVZFICovLCBjb250ZXh0LCBsb2MpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50T3B0aW9uTW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIGV2ZW50T3B0aW9uTW9kaWZpZXJzOiBtb2RpZmllcnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIoKSBvcHRpb25zLFxyXG4gICAgICAgICAgICAvLyBlLmcuIC5wYXNzaXZlICYgLmNhcHR1cmVcclxuICAgICAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW50aW1lTW9kaWZpZXJzOiBtb2RpZmllcnMgdGhhdCBuZWVkcyBydW50aW1lIGd1YXJkc1xyXG4gICAgICAgICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleU1vZGlmaWVycyxcclxuICAgICAgICBub25LZXlNb2RpZmllcnMsXHJcbiAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcclxuICAgIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBpc1N0YXRpY0V4cChrZXkpICYmIGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkgPT09ICdvbmNsaWNrJztcclxuICAgIHJldHVybiBpc1N0YXRpY0NsaWNrXHJcbiAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV2ZW50LCB0cnVlKVxyXG4gICAgICAgIDoga2V5LnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi9cclxuICAgICAgICAgICAgPyBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBgKWBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgOiBrZXk7XHJcbn07XHJcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU9uJDEoZGlyLCBub2RlLCBjb250ZXh0LCBiYXNlUmVzdWx0ID0+IHtcclxuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gZGlyO1xyXG4gICAgICAgIGlmICghbW9kaWZpZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XHJcbiAgICAgICAgbGV0IHsga2V5LCB2YWx1ZTogaGFuZGxlckV4cCB9ID0gYmFzZVJlc3VsdC5wcm9wc1swXTtcclxuICAgICAgICBjb25zdCB7IGtleU1vZGlmaWVycywgbm9uS2V5TW9kaWZpZXJzLCBldmVudE9wdGlvbk1vZGlmaWVycyB9ID0gcmVzb2x2ZU1vZGlmaWVycyhrZXksIG1vZGlmaWVycywgY29udGV4dCwgZGlyLmxvYyk7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygncmlnaHQnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbkNvbnRleHRtZW51YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ21pZGRsZScpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uTW91c2V1cGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX01PRElGSUVSUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub25LZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBpZiBldmVudCBuYW1lIGlzIGR5bmFtaWMsIGFsd2F5cyB3cmFwIHdpdGgga2V5cyBndWFyZFxyXG4gICAgICAgICAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGtleU1vZGlmaWVycylcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudE9wdGlvbk1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKGNhcGl0YWxpemUpLmpvaW4oJycpO1xyXG4gICAgICAgICAgICBrZXkgPSBpc1N0YXRpY0V4cChrZXkpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5LmNvbnRlbnR9JHttb2RpZmllclBvc3RmaXh9YCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgKGAsIGtleSwgYCkgKyBcIiR7bW9kaWZpZXJQb3N0Zml4fVwiYF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgaGFuZGxlckV4cCldXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TaG93ID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OCAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtdLFxyXG4gICAgICAgIG5lZWRSdW50aW1lOiBjb250ZXh0LmhlbHBlcihWX1NIT1cpXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB3YXJuVHJhbnNpdGlvbkNoaWxkcmVuID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1OSAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcclxuICAgIC8vICMxMzUyIGZpbHRlciBvdXQgcG90ZW50aWFsIGNvbW1lbnQgbm9kZXMuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IChub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLyAmJlxyXG4gICAgICAgICEoYy50eXBlID09PSAyIC8qIFRFWFQgKi8gJiYgIWMuY29udGVudC50cmltKCkpKSk7XHJcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHxcclxuICAgICAgICBjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8gfHxcclxuICAgICAgICAoY2hpbGQudHlwZSA9PT0gOSAvKiBJRiAqLyAmJiBjaGlsZC5icmFuY2hlcy5zb21lKGhhc011bHRpcGxlQ2hpbGRyZW4pKSk7XHJcbn1cblxuY29uc3QgaWdub3JlU2lkZUVmZmVjdFRhZ3MgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWcgPT09ICdzY3JpcHQnIHx8IG5vZGUudGFnID09PSAnc3R5bGUnKSkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDYwIC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IERPTU5vZGVUcmFuc2Zvcm1zID0gW1xyXG4gICAgdHJhbnNmb3JtU3R5bGUsXHJcbiAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gW3dhcm5UcmFuc2l0aW9uQ2hpbGRyZW5dIDogW10pXHJcbl07XHJcbmNvbnN0IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7XHJcbiAgICBjbG9hazogbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSxcclxuICAgIGh0bWw6IHRyYW5zZm9ybVZIdG1sLFxyXG4gICAgdGV4dDogdHJhbnNmb3JtVlRleHQsXHJcbiAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWwsXHJcbiAgICBvbjogdHJhbnNmb3JtT24sXHJcbiAgICBzaG93OiB0cmFuc2Zvcm1TaG93XHJcbn07XHJcbmZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGJhc2VDb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgPHNjcmlwdD4gYW5kIDx0YWc+XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHB1dCBpbnNpZGUgRE9NTm9kZVRyYW5zZm9ybXMgYmVjYXVzZSB0aGF0IGxpc3QgaXMgdXNlZFxyXG4gICAgICAgICAgICAvLyBieSBjb21waWxlci1zc3IgdG8gZ2VuZXJhdGUgdm5vZGUgZmFsbGJhY2sgYnJhbmNoZXNcclxuICAgICAgICAgICAgaWdub3JlU2lkZUVmZmVjdFRhZ3MsXHJcbiAgICAgICAgICAgIC4uLkRPTU5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSlcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgRE9NRGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9KSxcclxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbCBcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gYmFzZVBhcnNlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMpKTtcclxufVxuXG5leHBvcnQgeyBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBET01Ob2RlVHJhbnNmb3JtcywgVFJBTlNJVElPTiwgVFJBTlNJVElPTl9HUk9VUCwgVl9NT0RFTF9DSEVDS0JPWCwgVl9NT0RFTF9EWU5BTUlDLCBWX01PREVMX1JBRElPLCBWX01PREVMX1NFTEVDVCwgVl9NT0RFTF9URVhULCBWX09OX1dJVEhfS0VZUywgVl9PTl9XSVRIX01PRElGSUVSUywgVl9TSE9XLCBjb21waWxlLCBjcmVhdGVET01Db21waWxlckVycm9yLCBwYXJzZSwgcGFyc2VyT3B0aW9ucywgdHJhbnNmb3JtU3R5bGUgfTtcbiIsImV4cG9ydCBjb25zdCBIT09LX1NFVFVQID0gJ2RldnRvb2xzLXBsdWdpbjpzZXR1cCc7XG5leHBvcnQgY29uc3QgSE9PS19QTFVHSU5fU0VUVElOR1NfU0VUID0gJ3BsdWdpbjpzZXR0aW5nczpzZXQnO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldERldnRvb2xzR2xvYmFsSG9vaygpIHtcbiAgICByZXR1cm4gZ2V0VGFyZ2V0KCkuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICA6IHt9O1xufVxuZXhwb3J0IGNvbnN0IGlzUHJveHlBdmFpbGFibGUgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG4iLCJpbXBvcnQgeyBnZXRUYXJnZXQsIGdldERldnRvb2xzR2xvYmFsSG9vaywgaXNQcm94eUF2YWlsYWJsZSB9IGZyb20gJy4vZW52JztcbmltcG9ydCB7IEhPT0tfU0VUVVAgfSBmcm9tICcuL2NvbnN0JztcbmltcG9ydCB7IEFwaVByb3h5IH0gZnJvbSAnLi9wcm94eSc7XG5leHBvcnQgKiBmcm9tICcuL2FwaSc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbic7XG5leHBvcnQgKiBmcm9tICcuL3RpbWUnO1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwRGV2dG9vbHNQbHVnaW4ocGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbikge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBwbHVnaW5EZXNjcmlwdG9yO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCgpO1xuICAgIGNvbnN0IGhvb2sgPSBnZXREZXZ0b29sc0dsb2JhbEhvb2soKTtcbiAgICBjb25zdCBlbmFibGVQcm94eSA9IGlzUHJveHlBdmFpbGFibGUgJiYgZGVzY3JpcHRvci5lbmFibGVFYXJseVByb3h5O1xuICAgIGlmIChob29rICYmICh0YXJnZXQuX19WVUVfREVWVE9PTFNfUExVR0lOX0FQSV9BVkFJTEFCTEVfXyB8fCAhZW5hYmxlUHJveHkpKSB7XG4gICAgICAgIGhvb2suZW1pdChIT09LX1NFVFVQLCBwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gZW5hYmxlUHJveHkgPyBuZXcgQXBpUHJveHkoZGVzY3JpcHRvciwgaG9vaykgOiBudWxsO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTlNfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5TX18gfHwgW107XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICBwbHVnaW5EZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgc2V0dXBGbixcbiAgICAgICAgICAgIHByb3h5LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3h5KVxuICAgICAgICAgICAgc2V0dXBGbihwcm94eS5wcm94aWVkVGFyZ2V0KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQgfSBmcm9tICcuL2NvbnN0JztcbmltcG9ydCB7IG5vdyB9IGZyb20gJy4vdGltZSc7XG5leHBvcnQgY2xhc3MgQXBpUHJveHkge1xuICAgIGNvbnN0cnVjdG9yKHBsdWdpbiwgaG9vaykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0UXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5vblF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICB0aGlzLmhvb2sgPSBob29rO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3MgPSB7fTtcbiAgICAgICAgaWYgKHBsdWdpbi5zZXR0aW5ncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBpbiBwbHVnaW4uc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcGx1Z2luLnNldHRpbmdzW2lkXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U2V0dGluZ3NbaWRdID0gaXRlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYWxTZXR0aW5nc1NhdmVJZCA9IGBfX3Z1ZS1kZXZ0b29scy1wbHVnaW4tc2V0dGluZ3NfXyR7cGx1Z2luLmlkfWA7XG4gICAgICAgIGxldCBjdXJyZW50U2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U2V0dGluZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTZXR0aW5nc1NhdmVJZCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXcpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50U2V0dGluZ3MsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNldHRpbmdzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFNldHRpbmdzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTZXR0aW5nc1NhdmVJZCwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZ3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3coKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgIGhvb2sub24oSE9PS19QTFVHSU5fU0VUVElOR1NfU0VULCAocGx1Z2luSWQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbklkID09PSB0aGlzLnBsdWdpbi5pZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhbGxiYWNrcy5zZXRTZXR0aW5ncyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94aWVkT24gPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Lm9uW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm94aWVkVGFyZ2V0ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94aWVkT247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKHRoaXMuZmFsbGJhY2tzKS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0UXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4geyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWxsYmFja3NbcHJvcF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UmVhbFRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9uUXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Lm9uW2l0ZW0ubWV0aG9kXSguLi5pdGVtLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnRhcmdldFF1ZXVlKSB7XG4gICAgICAgICAgICBpdGVtLnJlc29sdmUoYXdhaXQgdGhpcy50YXJnZXRbaXRlbS5tZXRob2RdKC4uLml0ZW0uYXJncykpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwibGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVyZm9ybWFuY2VTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBnbG9iYWwucGVyZl9ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcmZvcm1hbmNlKSkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBwZXJmID0gZ2xvYmFsLnBlcmZfaG9va3MucGVyZm9ybWFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIGlzUGVyZm9ybWFuY2VTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpO1xufVxuIiwiaW1wb3J0IHsgZXh0ZW5kLCBpc0FycmF5LCBpc01hcCwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgaGFzT3duLCBpc09iamVjdCwgaGFzQ2hhbmdlZCwgbWFrZU1hcCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBkZWYsIGlzRnVuY3Rpb24sIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XHJcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG5jbGFzcyBFZmZlY3RTY29wZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcclxuICAgICAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPVxyXG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKHRoaXMpIC0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBydW4oZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb24oKSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgb2ZmKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBzdG9wKGZyb21QYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgbGV0IGksIGw7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbmVzdGVkIHNjb3BlLCBkZXJlZmVyZW5jZSBmcm9tIHBhcmVudCB0byBhdm9pZCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcclxuICAgIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlY29yZEVmZmVjdFNjb3BlKGVmZmVjdCwgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZSkge1xyXG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcclxuICAgIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcclxufVxyXG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbikge1xyXG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVgICtcclxuICAgICAgICAgICAgYCB0byBiZSBhc3NvY2lhdGVkIHdpdGguYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcclxuICAgIGNvbnN0IGRlcCA9IG5ldyBTZXQoZWZmZWN0cyk7XHJcbiAgICBkZXAudyA9IDA7XHJcbiAgICBkZXAubiA9IDA7XHJcbiAgICByZXR1cm4gZGVwO1xyXG59O1xyXG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xyXG5jb25zdCBuZXdUcmFja2VkID0gKGRlcCkgPT4gKGRlcC5uICYgdHJhY2tPcEJpdCkgPiAwO1xyXG5jb25zdCBpbml0RGVwTWFya2VycyA9ICh7IGRlcHMgfSkgPT4ge1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0udyB8PSB0cmFja09wQml0OyAvLyBzZXQgd2FzIHRyYWNrZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHB0ciA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlcCA9IGRlcHNbaV07XHJcbiAgICAgICAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwLmRlbGV0ZShlZmZlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwc1twdHIrK10gPSBkZXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2xlYXIgYml0c1xyXG4gICAgICAgICAgICBkZXAudyAmPSB+dHJhY2tPcEJpdDtcclxuICAgICAgICAgICAgZGVwLm4gJj0gfnRyYWNrT3BCaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gcHRyO1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBUaGUgbnVtYmVyIG9mIGVmZmVjdHMgY3VycmVudGx5IGJlaW5nIHRyYWNrZWQgcmVjdXJzaXZlbHkuXHJcbmxldCBlZmZlY3RUcmFja0RlcHRoID0gMDtcclxubGV0IHRyYWNrT3BCaXQgPSAxO1xyXG4vKipcclxuICogVGhlIGJpdHdpc2UgdHJhY2sgbWFya2VycyBzdXBwb3J0IGF0IG1vc3QgMzAgbGV2ZWxzIG9mIHJlY3Vyc2lvbi5cclxuICogVGhpcyB2YWx1ZSBpcyBjaG9zZW4gdG8gZW5hYmxlIG1vZGVybiBKUyBlbmdpbmVzIHRvIHVzZSBhIFNNSSBvbiBhbGwgcGxhdGZvcm1zLlxyXG4gKiBXaGVuIHJlY3Vyc2lvbiBkZXB0aCBpcyBncmVhdGVyLCBmYWxsIGJhY2sgdG8gdXNpbmcgYSBmdWxsIGNsZWFudXAuXHJcbiAqL1xyXG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XHJcbmxldCBhY3RpdmVFZmZlY3Q7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcclxuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcclxuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xyXG4gICAgY29uc3RydWN0b3IoZm4sIHNjaGVkdWxlciA9IG51bGwsIHNjb3BlKSB7XHJcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBzY29wZSk7XHJcbiAgICB9XHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGFyZW50ID0gYWN0aXZlRWZmZWN0O1xyXG4gICAgICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcclxuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCArK2VmZmVjdFRyYWNrRGVwdGg7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICAgICAgICAgIGluaXREZXBNYXJrZXJzKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgICAgICAgICAgZmluYWxpemVEZXBNYXJrZXJzKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gbGFzdFNob3VsZFRyYWNrO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGlmIChmbi5lZmZlY3QpIHtcclxuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcclxuICAgIH1cclxuICAgIGNvbnN0IF9lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xyXG4gICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpXHJcbiAgICAgICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBfZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcclxuICAgIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xyXG4gICAgcmV0dXJuIHJ1bm5lcjtcclxufVxyXG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xyXG4gICAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XHJcbn1cclxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XHJcbn1cclxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcclxuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcclxuICAgICAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgICAgIGRlcHNNYXAuc2V0KGtleSwgKGRlcCA9IGNyZWF0ZURlcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICA/IHsgZWZmZWN0OiBhY3RpdmVFZmZlY3QsIHRhcmdldCwgdHlwZSwga2V5IH1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdHJhY2tFZmZlY3RzKGRlcCwgZXZlbnRJbmZvKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICBsZXQgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxuICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICBpZiAoIW5ld1RyYWNrZWQoZGVwKSkge1xyXG4gICAgICAgICAgICBkZXAubiB8PSB0cmFja09wQml0OyAvLyBzZXQgbmV3bHkgdHJhY2tlZFxyXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9ICF3YXNUcmFja2VkKGRlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gRnVsbCBjbGVhbnVwIG1vZGUuXHJcbiAgICAgICAgc2hvdWxkVHJhY2sgPSAhZGVwLmhhcyhhY3RpdmVFZmZlY3QpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZFRyYWNrKSB7XHJcbiAgICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdC5vblRyYWNrKE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3RcclxuICAgICAgICAgICAgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xyXG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIC8vIG5ldmVyIGJlZW4gdHJhY2tlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBkZXBzID0gW107XHJcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIENMRUFSICovKSB7XHJcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhbGwgZWZmZWN0cyBmb3IgdGFyZ2V0XHJcbiAgICAgICAgZGVwcyA9IFsuLi5kZXBzTWFwLnZhbHVlcygpXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ2xlbmd0aCcgJiYgaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgPj0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzY2hlZHVsZSBydW5zIGZvciBTRVQgfCBBREQgfCBERUxFVEVcclxuICAgICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbHNvIHJ1biBmb3IgaXRlcmF0aW9uIGtleSBvbiBBREQgfCBERUxFVEUgfCBNYXAuU0VUXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhZGRcIiAvKiBBREQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgaW5kZXggYWRkZWQgdG8gYXJyYXkgLT4gbGVuZ3RoIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoJ2xlbmd0aCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCIgLyogREVMRVRFICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2V0XCIgLyogU0VUICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8geyB0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQgfVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgaWYgKGRlcHNbMF0pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSwgZXZlbnRJbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKGRlcCkge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKC4uLmRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cyksIGV2ZW50SW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcclxuICAgIC8vIHNwcmVhZCBpbnRvIGFycmF5IGZvciBzdGFiaWxpemF0aW9uXHJcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBpc0FycmF5KGRlcCkgPyBkZXAgOiBbLi4uZGVwXSkge1xyXG4gICAgICAgIGlmIChlZmZlY3QgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QuYWxsb3dSZWN1cnNlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9uVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlcihleHRlbmQoeyBlZmZlY3QgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3Quc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Quc2NoZWR1bGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcclxuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcclxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxyXG4gICAgLmZpbHRlcihpc1N5bWJvbCkpO1xyXG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xyXG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xyXG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcclxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyojX19QVVJFX18qLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xyXG4gICAgWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovICYmXHJcbiAgICAgICAgICAgIHJlY2VpdmVyID09PVxyXG4gICAgICAgICAgICAgICAgKGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFjdGl2ZU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIGRvZXMgbm90IGFwcGx5IGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhaXNJbnRlZ2VyS2V5KGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XHJcbiAgICAgICAgICAgIC8vIGFuZCByZWFjdGl2ZSBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHNldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSlcclxuICAgICAgICAgICAgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGhcclxuICAgICAgICAgICAgOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgdGFyZ2V0IGlzIHNvbWV0aGluZyB1cCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIG9yaWdpbmFsXHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcclxuICAgIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNBcnJheSh0YXJnZXQpID8gJ2xlbmd0aCcgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbn1cclxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0LFxyXG4gICAgc2V0LFxyXG4gICAgZGVsZXRlUHJvcGVydHksXHJcbiAgICBoYXMsXHJcbiAgICBvd25LZXlzXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxyXG4gICAgc2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIG11dGFibGVIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93R2V0LFxyXG4gICAgc2V0OiBzaGFsbG93U2V0XHJcbn0pO1xyXG4vLyBQcm9wcyBoYW5kbGVycyBhcmUgc3BlY2lhbCBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBzaG91bGQgbm90IHVud3JhcCB0b3AtbGV2ZWxcclxuLy8gcmVmcyAoaW4gb3JkZXIgdG8gYWxsb3cgcmVmcyB0byBiZSBleHBsaWNpdGx5IHBhc3NlZCBkb3duKSwgYnV0IHNob3VsZFxyXG4vLyByZXRhaW4gdGhlIHJlYWN0aXZpdHkgb2YgdGhlIG5vcm1hbCByZWFkb25seSBvYmplY3QuXHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XHJcbn0pO1xuXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xyXG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xyXG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgLy8gIzE3NzI6IHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpIHNob3VsZCByZXR1cm4gcmVhZG9ubHkgKyByZWFjdGl2ZSB2ZXJzaW9uXHJcbiAgICAvLyBvZiB0aGUgdmFsdWVcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywgcmF3S2V5KTtcclxuICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xyXG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gIzM2MDIgcmVhZG9ubHkocmVhY3RpdmUoTWFwKSlcclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgbmVzdGVkIHJlYWN0aXZlIGBNYXBgIGNhbiBkbyB0cmFja2luZyBmb3IgaXRzZWxmXHJcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCByYXdLZXkpO1xyXG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5XHJcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcclxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbn1cclxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywgdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgaWYgKGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IGlzTWFwKHRhcmdldClcclxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcclxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgIGlmIChoYWRJdGVtcykge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xyXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcclxuICAgICAgICAgICAgLy8gMi4gdGhlIHZhbHVlIHJlY2VpdmVkIHNob3VsZCBiZSBhIGNvcnJlc3BvbmRpbmcgcmVhY3RpdmUvcmVhZG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09ICdlbnRyaWVzJyB8fCAobWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXApO1xyXG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xyXG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmXHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcclxuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXHJcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XHJcbiAgICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcclxuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgIF07XHJcbn1cclxuY29uc3QgW211dGFibGVJbnN0cnVtZW50YXRpb25zLCByZWFkb25seUluc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXSA9IC8qICNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XHJcbiAgICAgICAgPyBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgOiBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XHJcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcclxufTtcclxuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgYCArXHJcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xyXG4gICAgICAgICAgICBgQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgYCArXHJcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICAgIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSlcclxuICAgICAgICA/IDAgLyogSU5WQUxJRCAqL1xyXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxyXG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXHJcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcclxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cclxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xyXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGlzIGFscmVhZHkgYSBQcm94eSwgcmV0dXJuIGl0LlxyXG4gICAgLy8gZXhjZXB0aW9uOiBjYWxsaW5nIHJlYWRvbmx5KCkgb24gYSByZWFjdGl2ZSBvYmplY3RcclxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXSAmJlxyXG4gICAgICAgICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGFscmVhZHkgaGFzIGNvcnJlc3BvbmRpbmcgUHJveHlcclxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGEgd2hpdGVsaXN0IG9mIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cclxuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcclxuICAgIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKTtcclxuICAgIH1cclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogSVNfU0hBTExPVyAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xyXG4gICAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogU0tJUCAqLywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiB0cmFja1JlZlZhbHVlKHJlZikge1xyXG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xyXG4gICAgICAgIHJlZiA9IHRvUmF3KHJlZik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIEdFVCAqLyxcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYWNrRWZmZWN0cyhyZWYuZGVwIHx8IChyZWYuZGVwID0gY3JlYXRlRGVwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZlZhbHVlKHJlZiwgbmV3VmFsKSB7XHJcbiAgICByZWYgPSB0b1JhdyhyZWYpO1xyXG4gICAgaWYgKHJlZi5kZXApIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKHJlZi5kZXAsIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBTRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZScsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMocmVmLmRlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVmKHIpIHtcclxuICAgIHJldHVybiAhIShyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiByZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcclxuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xyXG59XHJcbmNsYXNzIFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIF9fdl9pc1NoYWxsb3cpIHtcclxuICAgICAgICB0aGlzLl9fdl9pc1NoYWxsb3cgPSBfX3ZfaXNTaGFsbG93O1xyXG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIG5ld1ZhbCA9IHRoaXMuX192X2lzU2hhbGxvdyA/IG5ld1ZhbCA6IHRvUmF3KG5ld1ZhbCk7XHJcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsLCB0aGlzLl9yYXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fX3ZfaXNTaGFsbG93ID8gbmV3VmFsIDogdG9SZWFjdGl2ZShuZXdWYWwpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcywgbmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIHRyaWdnZXJSZWZWYWx1ZShyZWYsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XHJcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcclxufVxyXG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxyXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcylcclxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXHJcbiAgICAgICAgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XHJcbn1cclxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2tSZWZWYWx1ZSh0aGlzKSwgKCkgPT4gdHJpZ2dlclJlZlZhbHVlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9nZXQgPSBnZXQ7XHJcbiAgICAgICAgdGhpcy5fc2V0ID0gc2V0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9zZXQobmV3VmFsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzUHJveHkob2JqZWN0KSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xyXG4gICAgcmV0dXJuIGlzUmVmKHZhbClcclxuICAgICAgICA/IHZhbFxyXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSk7XHJcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seSwgaXNTU1IpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xyXG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcclxuICAgICAgICB0aGlzLmVmZmVjdC5hY3RpdmUgPSB0aGlzLl9jYWNoZWFibGUgPSAhaXNTU1I7XHJcbiAgICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dID0gaXNSZWFkb25seTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICB0cmFja1JlZlZhbHVlKHNlbGYpO1xyXG4gICAgICAgIGlmIChzZWxmLl9kaXJ0eSB8fCAhc2VsZi5fY2FjaGVhYmxlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgc2V0dGVyO1xyXG4gICAgY29uc3Qgb25seUdldHRlciA9IGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKTtcclxuICAgIGlmIChvbmx5R2V0dGVyKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xyXG4gICAgICAgIHNldHRlciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IE5PT1A7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xyXG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjUmVmID0gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgb25seUdldHRlciB8fCAhc2V0dGVyLCBpc1NTUik7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcclxuICAgICAgICBjUmVmLmVmZmVjdC5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XHJcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBjUmVmO1xyXG59XG5cbnZhciBfYTtcclxuY29uc3QgdGljayA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgcXVldWVkID0gZmFsc2U7XHJcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xyXG4gICAgcXVldWUucHVzaChmbik7XHJcbiAgICBpZiAoIXF1ZXVlZCkge1xyXG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgdGljay50aGVuKGZsdXNoKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZmx1c2ggPSAoKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcXVldWVbaV0oKTtcclxuICAgIH1cclxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICBxdWV1ZWQgPSBmYWxzZTtcclxufTtcclxuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzW19hXSA9IHRydWU7XHJcbiAgICAgICAgbGV0IGNvbXBhcmVUYXJnZXQ7XHJcbiAgICAgICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoY29tcHV0ZWRUcmlnZ2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVUYXJnZXQgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlZHVsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWZmZWN0LmFjdGl2ZSAmJiB0aGlzLl9nZXQoKSAhPT0gdmFsdWVUb0NvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgdXBzdHJlYW0gY29tcHV0ZWRzIGFyZSBub3RpZmllZCBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZVxyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgaW52YWxpZGF0aW9uIGluIGNhc2Ugb2Ygc3luYyBhY2Nlc3M7IG5vcm1hbCBlZmZlY3RzIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQgdG8gYmUgdHJpZ2dlcmVkIGluIHNjaGVkdWxlci5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmRlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNvbXB1dGVkIGluc3RhbmNlb2YgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY2hlZHVsZXIodHJ1ZSAvKiBjb21wdXRlZFRyaWdnZXIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgX2dldCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9IHRoaXMuZWZmZWN0LnJ1bigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xyXG4gICAgfVxyXG59XHJcbl9hID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovO1xyXG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xyXG4gICAgcmV0dXJuIG5ldyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbChnZXR0ZXIpO1xyXG59XG5cbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGRlZmVycmVkQ29tcHV0ZWQsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBpc1NoYWxsb3cgYXMgaXNTaGFsbG93JDEsIGlzUmVhY3RpdmUsIFJlYWN0aXZlRWZmZWN0LCByZWYsIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIEVmZmVjdFNjb3BlLCBtYXJrUmF3LCBwcm94eVJlZnMsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBFTVBUWV9PQkosIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIGh5cGhlbmF0ZSwgY2FtZWxpemUsIGlzT24sIGhhc093biwgaXNNb2RlbExpc3RlbmVyLCBoYXNDaGFuZ2VkLCByZW1vdmUsIGlzT2JqZWN0LCBpc1NldCwgaXNNYXAsIGlzUGxhaW5PYmplY3QsIGludm9rZUFycmF5Rm5zLCBkZWYsIGlzUmVzZXJ2ZWRQcm9wLCBFTVBUWV9BUlIsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgbWFrZU1hcCwgaXNCdWlsdEluRGlyZWN0aXZlLCBOTywgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XHJcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xyXG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XHJcbiAgICBzdGFjay5wb3AoKTtcclxufVxyXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcclxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XHJcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xyXG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogQVBQX1dBUk5fSEFORExFUiAqLywgW1xyXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcclxuICAgICAgICAgICAgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XHJcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xyXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXHJcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXHJcbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xyXG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gICAgY29uc3QgbG9ncyA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb2dzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcclxuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcclxuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XHJcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XHJcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcclxuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxyXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICByZXMucHVzaChgIC4uLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcclxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XHJcbiAgICBbXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqL106ICdzZXJ2ZXJQcmVmZXRjaCBob29rJyxcclxuICAgIFtcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXHJcbiAgICBbXCJjXCIgLyogQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxyXG4gICAgW1wiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXHJcbiAgICBbXCJtXCIgLyogTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcclxuICAgIFtcInVcIiAvKiBVUERBVEVEICovXTogJ3VwZGF0ZWQnLFxyXG4gICAgW1wiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcclxuICAgIFtcInVtXCIgLyogVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcclxuICAgIFtcImFcIiAvKiBBQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZGFcIiAvKiBERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcclxuICAgIFtcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXHJcbiAgICBbXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcclxuICAgIFswIC8qIFNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcclxuICAgIFsxIC8qIFJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxyXG4gICAgWzIgLyogV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcclxuICAgIFszIC8qIFdBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxyXG4gICAgWzQgLyogV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxyXG4gICAgWzUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzcgLyogVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcclxuICAgIFs4IC8qIERJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcclxuICAgIFs5IC8qIFRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxyXG4gICAgWzEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxyXG4gICAgWzExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcclxuICAgIFsxMiAvKiBGVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcclxuICAgIFsxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxyXG4gICAgWzE0IC8qIFNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xyXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZSdcclxufTtcclxuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgbGV0IHJlcztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcclxuICAgICAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcclxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgZmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQcmVGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcHJlRmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XHJcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XHJcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xyXG59XHJcbi8vICMyNzY4XHJcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXHJcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcclxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcclxuICAgIC8vIHRoZSBzdGFydCBpbmRleCBzaG91bGQgYmUgYGZsdXNoSW5kZXggKyAxYFxyXG4gICAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XHJcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xyXG4gICAgICAgIG1pZGRsZUpvYklkIDwgaWQgPyAoc3RhcnQgPSBtaWRkbGUgKyAxKSA6IChlbmQgPSBtaWRkbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXJ0O1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xyXG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXHJcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBzZWFyY2ggaW5kZXggaW5jbHVkZXMgdGhlIGN1cnJlbnQgam9iIHRoYXQgaXMgYmVpbmcgcnVuXHJcbiAgICAvLyBzbyBpdCBjYW5ub3QgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgYWdhaW4uXHJcbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xyXG4gICAgLy8gYWxsb3cgaXQgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgLSBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvXHJcbiAgICAvLyBlbnN1cmUgaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcC5cclxuICAgIGlmICgoIXF1ZXVlLmxlbmd0aCB8fFxyXG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpICYmXHJcbiAgICAgICAgam9iICE9PSBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IpIHtcclxuICAgICAgICBpZiAoam9iLmlkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2IuaWQpLCAwLCBqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUZsdXNoKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcclxuICAgIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcclxuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcclxuICAgIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XHJcbiAgICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcclxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVDYihjYiwgYWN0aXZlUXVldWUsIHBlbmRpbmdRdWV1ZSwgaW5kZXgpIHtcclxuICAgIGlmICghaXNBcnJheShjYikpIHtcclxuICAgICAgICBpZiAoIWFjdGl2ZVF1ZXVlIHx8XHJcbiAgICAgICAgICAgICFhY3RpdmVRdWV1ZS5pbmNsdWRlcyhjYiwgY2IuYWxsb3dSZWN1cnNlID8gaW5kZXggKyAxIDogaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKGNiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBpZiBjYiBpcyBhbiBhcnJheSwgaXQgaXMgYSBjb21wb25lbnQgbGlmZWN5Y2xlIGhvb2sgd2hpY2ggY2FuIG9ubHkgYmVcclxuICAgICAgICAvLyB0cmlnZ2VyZWQgYnkgYSBqb2IsIHdoaWNoIGlzIGFscmVhZHkgZGVkdXBlZCBpbiB0aGUgbWFpbiBxdWV1ZSwgc29cclxuICAgICAgICAvLyB3ZSBjYW4gc2tpcCBkdXBsaWNhdGUgY2hlY2sgaGVyZSB0byBpbXByb3ZlIHBlcmZcclxuICAgICAgICBwZW5kaW5nUXVldWUucHVzaCguLi5jYik7XHJcbiAgICB9XHJcbiAgICBxdWV1ZUZsdXNoKCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQcmVGbHVzaENiKGNiKSB7XHJcbiAgICBxdWV1ZUNiKGNiLCBhY3RpdmVQcmVGbHVzaENicywgcGVuZGluZ1ByZUZsdXNoQ2JzLCBwcmVGbHVzaEluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XHJcbiAgICBxdWV1ZUNiKGNiLCBhY3RpdmVQb3N0Rmx1c2hDYnMsIHBlbmRpbmdQb3N0Rmx1c2hDYnMsIHBvc3RGbHVzaEluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYiA9IG51bGwpIHtcclxuICAgIGlmIChwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gcGFyZW50Sm9iO1xyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gWy4uLm5ldyBTZXQocGVuZGluZ1ByZUZsdXNoQ2JzKV07XHJcbiAgICAgICAgcGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocHJlRmx1c2hJbmRleCA9IDA7IHByZUZsdXNoSW5kZXggPCBhY3RpdmVQcmVGbHVzaENicy5sZW5ndGg7IHByZUZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUHJlRmx1c2hDYnNbcHJlRmx1c2hJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcHJlRmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuICAgICAgICAvLyByZWN1cnNpdmVseSBmbHVzaCB1bnRpbCBpdCBkcmFpbnNcclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xyXG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxyXG4gICAgICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcclxuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcclxuICAgIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcclxuICAgIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZCBzbyBpdHMgcmVuZGVyIGVmZmVjdCB3aWxsIGhhdmUgc21hbGxlclxyXG4gICAgLy8gICAgcHJpb3JpdHkgbnVtYmVyKVxyXG4gICAgLy8gMi4gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB1cGRhdGUsXHJcbiAgICAvLyAgICBpdHMgdXBkYXRlIGNhbiBiZSBza2lwcGVkLlxyXG4gICAgcXVldWUuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAvLyBjb25kaXRpb25hbCB1c2FnZSBvZiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZSBtdXN0IGJlIGRldGVybWluZWQgb3V0IG9mXHJcbiAgICAvLyB0cnkgLi4uIGNhdGNoIGJsb2NrIHNpbmNlIFJvbGx1cCBieSBkZWZhdWx0IGRlLW9wdGltaXplcyB0cmVlc2hha2luZ1xyXG4gICAgLy8gaW5zaWRlIHRyeS1jYXRjaC4gVGhpcyBjYW4gbGVhdmUgYWxsIHdhcm5pbmcgY29kZSB1bnNoYWtlZC4gQWx0aG91Z2hcclxuICAgIC8vIHRoZXkgd291bGQgZ2V0IGV2ZW50dWFsbHkgc2hha2VuIGJ5IGEgbWluaWZpZXIgbGlrZSB0ZXJzZXIsIHNvbWUgbWluaWZpZXJzXHJcbiAgICAvLyB3b3VsZCBmYWlsIHRvIGRvIHRoYXQgKGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzE2MTApXHJcbiAgICBjb25zdCBjaGVjayA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYilcclxuICAgICAgICA6IE5PT1A7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGpvYiAmJiBqb2IuYWN0aXZlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVjayhqb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgcnVubmluZzpgLCBqb2IuaWQpXHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XHJcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XHJcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcclxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXHJcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICB9XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xyXG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwLnNldChpZCwge1xyXG4gICAgICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxyXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIHJlY29yZCAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50KVxyXG4gICAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XHJcbiAgICAvLyB1cGRhdGUgaW5pdGlhbCBkZWYgKGZvciBub3QteWV0LXJlbmRlcmVkIGNvbXBvbmVudHMpXHJcbiAgICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xyXG4gICAgLy8gY3JlYXRlIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgdXBkYXRlc1xyXG4gICAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XHJcbiAgICAgICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxyXG4gICAgICAgICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAyLiBtYXJrIGRlZmluaXRpb24gZGlydHkuIFRoaXMgZm9yY2VzIHRoZSByZW5kZXJlciB0byByZXBsYWNlIHRoZVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgb24gcGF0Y2guXHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGludmFsaWRhdGUgb3B0aW9ucyByZXNvbHV0aW9uIGNhY2hlXHJcbiAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIC8vIDQuIGFjdHVhbGx5IHVwZGF0ZVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gZWxlbWVudFxyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHRoZSBpbm5lciBjb21wb25lbnQgb2YgYW4gYXN5bmMgY3VzdG9tIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gaW52b2tlIHRvIHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50LnR5cGUuX19hc3luY0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNS4gbWFrZSBzdXJlIHRvIGNsZWFudXAgZGlydHkgaG1yIGNvbXBvbmVudHMgYWZ0ZXIgdXBkYXRlXHJcbiAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xyXG4gICAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xyXG4gICAgICAgIGlmIChrZXkgIT09ICdfX2ZpbGUnICYmICEoa2V5IGluIG5ld0NvbXApKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxubGV0IGJ1ZmZlciA9IFtdO1xyXG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gZW1pdChldmVudCwgLi4uYXJncykge1xyXG4gICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcclxuICAgICAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBkZXZ0b29scyA9IGhvb2s7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChcclxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXHJcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxyXG4gICAgLy8gKCM0ODE1KVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxyXG4gICAgICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJlxyXG4gICAgICAgIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxyXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcGxheSA9ICh0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9XHJcbiAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdKTtcclxuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xyXG4gICAgICAgICAgICBzZXREZXZ0b29sc0hvb2sobmV3SG9vaywgdGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXHJcbiAgICAgICAgLy8gYXQgYWxsLCBhbmQga2VlcGluZyB0aGUgYnVmZmVyIHdpbGwgY2F1c2UgbWVtb3J5IGxlYWtzICgjNDczOClcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAzMDAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vbi1icm93c2VyIGVudiwgYXNzdW1lIG5vdCBpbnN0YWxsZWRcclxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xyXG4gICAgZW1pdChcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xyXG4gICAgICAgIEZyYWdtZW50LFxyXG4gICAgICAgIFRleHQsXHJcbiAgICAgICAgQ29tbWVudCxcclxuICAgICAgICBTdGF0aWNcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcclxuICAgIGVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IFxyXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSBcclxuLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcclxuICAgIHJldHVybiAoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgZW1pdChob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHVuZGVmaW5lZCwgY29tcG9uZW50KTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcclxuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcclxuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgZW1pdChcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LCBldmVudCwgcGFyYW1zKTtcclxufVxuXG5mdW5jdGlvbiBlbWl0JDEoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IGVtaXRzT3B0aW9ucywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXHJcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcclxuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcclxuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gYS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1iZXIpIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcclxuICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcclxuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGhhbmRsZXJOYW1lO1xyXG4gICAgbGV0IGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpKV0gfHxcclxuICAgICAgICAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXHJcbiAgICAgICAgcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkpXTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhbHNvIHRyaWdnZXIga2ViYWItY2FzZSBlcXVpdmFsZW50XHJcbiAgICAvLyBmb3IgcHJvcHMgcGFzc2VkIHZpYSBrZWJhYi1jYXNlXHJcbiAgICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XHJcbiAgICAgICAgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKSldO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcclxuICAgIGlmIChvbmNlSGFuZGxlcikge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKG9uY2VIYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcclxuICAgIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG4vLyBDaGVjayBpZiBhbiBpbmNvbWluZyBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXIuXHJcbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxyXG4vLyBib3RoIGNvbnNpZGVyZWQgbWF0Y2hlZCBsaXN0ZW5lcnMuXHJcbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCAnJyk7XHJcbiAgICByZXR1cm4gKGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGtleSkpO1xyXG59XG5cbi8qKlxyXG4gKiBtYXJrIHRoZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZSBmb3IgYXNzZXQgcmVzb2x1dGlvbiAoZS5nLlxyXG4gKiByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlKSBkdXJpbmcgcmVuZGVyXHJcbiAqL1xyXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxuLyoqXHJcbiAqIE5vdGU6IHJlbmRlcmluZyBjYWxscyBtYXliZSBuZXN0ZWQuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXJlbnQgcmVuZGVyaW5nXHJcbiAqIGluc3RhbmNlIGlmIHByZXNlbnQsIHdoaWNoIHNob3VsZCBiZSByZXN0b3JlZCBhZnRlciB0aGUgcmVuZGVyIGlzIGRvbmU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaSlcclxuICogLy8gLi4ucmVuZGVyXHJcbiAqIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSAoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQpIHx8IG51bGw7XHJcbiAgICByZXR1cm4gcHJldjtcclxufVxyXG4vKipcclxuICogU2V0IHNjb3BlIGlkIHdoZW4gY3JlYXRpbmcgaG9pc3RlZCB2bm9kZXMuXHJcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gaWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlY2huaWNhbGx5IHdlIG5vIGxvbmdlciBuZWVkIHRoaXMgYWZ0ZXIgMy4wLjggYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgc2FtZVxyXG4gKiBBUEkgZm9yIGJhY2t3YXJkcyBjb21wYXQgdy8gY29kZSBnZW5lcmF0ZWQgYnkgY29tcGlsZXJzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxufVxyXG4vKipcclxuICogT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xyXG4vKipcclxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90IC8vIGZhbHNlIG9ubHlcclxuKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICAgIGlmIChmbi5fbikge1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIC8vIElmIGEgdXNlciBjYWxscyBhIGNvbXBpbGVkIHNsb3QgaW5zaWRlIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiAoIzE3NDUpLCBpdFxyXG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXHJcbiAgICAgICAgLy8gZm9yY2UgYmFpbCBvdXQgd2hlbiBpbnZva2luZyBhIGNvbXBpbGVkIHNsb3QgKGluZGljYXRlZCBieSB0aGUgLl9kIGZsYWcpLlxyXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLCBzbyB3ZSBmbGlwIHRoZVxyXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIG1hcmsgbm9ybWFsaXplZCB0byBhdm9pZCBkdXBsaWNhdGVkIHdyYXBwaW5nXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcclxuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gdm5vZGUudHMgLT4gbm9ybWFsaXplQ2hpbGRyZW4oKSB0byBzZXQgdGhlIHNsb3RcclxuICAgIC8vIHJlbmRlcmluZyBmbGFnLlxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XHJcbiAgICAvLyBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHRcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cclxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXHJcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxyXG4gKi9cclxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XHJcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCwgaW5oZXJpdEF0dHJzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcclxuICAgIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIC8vIHdpdGhQcm94eSBpcyBhIHByb3h5IHdpdGggYSBkaWZmZXJlbnQgYGhhc2AgdHJhcCBvbmx5IGZvclxyXG4gICAgICAgICAgICAvLyBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrLlxyXG4gICAgICAgICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xyXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIuY2FsbChwcm94eVRvVXNlLCBwcm94eVRvVXNlLCByZW5kZXJDYWNoZSwgcHJvcHMsIHNldHVwU3RhdGUsIGRhdGEsIGN0eCkpO1xyXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlciA9IENvbXBvbmVudDtcclxuICAgICAgICAgICAgLy8gaW4gZGV2LCBtYXJrIGF0dHJzIGFjY2Vzc2VkIGlmIG9wdGlvbmFsIHByb3BzIChhdHRycyA9PT0gcHJvcHMpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYXR0cnMgPT09IHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICA/IHJlbmRlcihwcm9wcywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogeyBhdHRycywgc2xvdHMsIGVtaXQgfSlcclxuICAgICAgICAgICAgICAgIDogcmVuZGVyKHByb3BzLCBudWxsIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovKSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHNcclxuICAgICAgICAgICAgICAgID8gYXR0cnNcclxuICAgICAgICAgICAgICAgIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEgLyogUkVOREVSX0ZVTkNUSU9OICovKTtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcclxuICAgIH1cclxuICAgIC8vIGF0dHIgbWVyZ2luZ1xyXG4gICAgLy8gaW4gZGV2IG1vZGUsIGNvbW1lbnRzIGFyZSBwcmVzZXJ2ZWQsIGFuZCBpdCdzIHBvc3NpYmxlIGZvciBhIHRlbXBsYXRlXHJcbiAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XHJcbiAgICBsZXQgcm9vdCA9IHJlc3VsdDtcclxuICAgIGxldCBzZXRSb290ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSAvKiBFTEVNRU5UICovIHwgNiAvKiBDT01QT05FTlQgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB2LW1vZGVsIGxpc3RlbmVyIChvblVwZGF0ZTp4eHgpIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjbGFyZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wLCBpdCBpbmRpY2F0ZXMgdGhpcyBjb21wb25lbnQgZXhwZWN0cyB0byBoYW5kbGUgdi1tb2RlbCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGZhbGx0aHJvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQ6ICMxNTQzLCAjMTY0MywgIzE5ODlcclxuICAgICAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoZmFsbHRocm91Z2hBdHRycywgcHJvcHNPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgb25gLCBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIHRvIHJlZmxlY3QgZXZlbnQgY2FzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXh0cmFBdHRycy5qb2luKCcsICcpfSkgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXZlbnRBdHRycy5qb2luKCcsICcpfSkgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gaW5oZXJpdCBkaXJlY3RpdmVzXHJcbiAgICBpZiAodm5vZGUuZGlycykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgd2FybihgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcclxuICAgIH1cclxuICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICBgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcclxuICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gJ3YtaWYnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaW5nbGVSb290O1xyXG59XHJcbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xyXG4gICAgbGV0IHJlcztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIHJldHVybiAodm5vZGUuc2hhcGVGbGFnICYgKDYgLyogQ09NUE9ORU5UICovIHwgMSAvKiBFTEVNRU5UICovKSB8fFxyXG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQgLy8gcG90ZW50aWFsIHYtaWYgYnJhbmNoIHN3aXRjaFxyXG4gICAgKTtcclxufTtcclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XHJcbiAgICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xyXG4gICAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xyXG4gICAgLy8gUGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiB3YXMgaG90LXVwZGF0ZWQuIFNpbmNlIHRoaXMgbWF5IGhhdmVcclxuICAgIC8vIGNhdXNlZCB0aGUgY2hpbGQgY29tcG9uZW50J3Mgc2xvdHMgY29udGVudCB0byBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG9cclxuICAgIC8vIGZvcmNlIHRoZSBjaGlsZCB0byB1cGRhdGUgYXMgd2VsbC5cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGZvcmNlIGNoaWxkIHVwZGF0ZSBmb3IgcnVudGltZSBkaXJlY3RpdmUgb3IgdHJhbnNpdGlvbiBvbiBjb21wb25lbnQgdm5vZGUuXHJcbiAgICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovKSB7XHJcbiAgICAgICAgICAgIC8vIHNsb3QgY29udGVudCB0aGF0IHJlZmVyZW5jZXMgdmFsdWVzIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLFxyXG4gICAgICAgICAgICAvLyBlLmcuIGluIGEgdi1mb3JcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgdGhpcyBmbGFnIGluZGljYXRlcyBwcm9wcyBhcmUgYWx3YXlzIG5vbi1udWxsXHJcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgdGFrZW4gYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXHJcbiAgICAgICAgLy8gc28gcHJlc2VuY2Ugb2YgYW55IGNoaWxkcmVuIGxlYWRzIHRvIGEgZm9yY2VkIHVwZGF0ZVxyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XHJcbiAgICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XHJcbiAgICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCAvLyBIb3N0Tm9kZVxyXG4pIHtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcclxuLy8gU3VzcGVuc2UgZXhwb3NlcyBhIGNvbXBvbmVudC1saWtlIEFQSSwgYW5kIGlzIHRyZWF0ZWQgbGlrZSBhIGNvbXBvbmVudFxyXG4vLyBpbiB0aGUgY29tcGlsZXIsIGJ1dCBpbnRlcm5hbGx5IGl0J3MgYSBzcGVjaWFsIGJ1aWx0LWluIHR5cGUgdGhhdCBob29rc1xyXG4vLyBkaXJlY3RseSBpbnRvIHRoZSByZW5kZXJlci5cclxuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xyXG4gICAgbmFtZTogJ1N1c3BlbnNlJyxcclxuICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcclxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXHJcbiAgICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcclxuICAgIC8vIGludGVybmFscy5cclxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBcclxuICAgIC8vIHBsYXRmb3JtLXNwZWNpZmljIGltcGwgcGFzc2VkIGZyb20gcmVuZGVyZXJcclxuICAgIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRTdXNwZW5zZShuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXHJcbiAgICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXHJcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cclxufTtcclxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcclxuY29uc3QgU3VzcGVuc2UgPSAoU3VzcGVuc2VJbXBsICk7XHJcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xyXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcclxuICAgICAgICBldmVudExpc3RlbmVyKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XHJcbiAgICAvLyBzdGFydCBtb3VudGluZyB0aGUgY29udGVudCBzdWJ0cmVlIGluIGFuIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICBwYXRjaChudWxsLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIGhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XHJcbiAgICAgICAgLy8gaGFzIGFzeW5jXHJcbiAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUGVuZGluZycpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcclxuICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxyXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLnNzRmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFN1c3BlbnNlIGhhcyBubyBhc3luYyBkZXBzLiBKdXN0IHJlc29sdmUuXHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IChuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlKTtcclxuICAgIHN1c3BlbnNlLnZub2RlID0gbjI7XHJcbiAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xyXG4gICAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xyXG4gICAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xyXG4gICAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xyXG4gICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyBzYW1lIHJvb3QgdHlwZSBidXQgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICBwYXRjaChwZW5kaW5nQnJhbmNoLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9nZ2xlZCBiZWZvcmUgcGVuZGluZyB0cmVlIGlzIHJlc29sdmVkXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRvZ2dsZWQgYmVmb3JlIGh5ZHJhdGlvbiBpcyBmaW5pc2hlZCwgdGhlIGN1cnJlbnQgRE9NIHRyZWUgaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB2YWxpZC4gc2V0IGl0IGFzIHRoZSBhY3RpdmUgYnJhbmNoIHNvIGl0IHdpbGwgYmUgdW5tb3VudGVkXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBlbmRpbmcgSUQuIHRoaXMgaXMgdXNlZCB0byBpbnZhbGlkYXRlIGFzeW5jIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAvLyByZXNldCBzdXNwZW5zZSBzdGF0ZVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5kZXBzID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBlZmZlY3RzIGZyb20gcGVuZGluZyBicmFuY2hcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBpbiBmYWxsYmFjayBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGVkIFwiYmFja1wiIHRvIGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVkIHRvIGEgM3JkIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgZGlkIG5vdCBjaGFuZ2UsIGp1c3Qgbm9ybWFsIHBhdGNoXHJcbiAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBub2RlIHRvZ2dsZWRcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBwZW5kaW5nIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChuMiwgJ29uUGVuZGluZycpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBwZW5kaW5nIGJyYW5jaCBpbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjb25zb2xlLmluZm9gIGNhbm5vdCBiZSBudWxsIGVycm9yXHJcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IHVubW91bnQsIG46IG5leHQsIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHRvTnVtYmVyKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnRpbWVvdXQpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBpc1NWRyxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBkZXBzOiAwLFxyXG4gICAgICAgIHBlbmRpbmdJZDogMCxcclxuICAgICAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgPyB0aW1lb3V0IDogLTEsXHJcbiAgICAgICAgYWN0aXZlQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgaXNJbkZhbGxiYWNrOiB0cnVlLFxyXG4gICAgICAgIGlzSHlkcmF0aW5nLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBlZmZlY3RzOiBbXSxcclxuICAgICAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIHBlbmRpbmdJZCwgZWZmZWN0cywgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGluaXRpYWwgYW5jaG9yIG9uIG1vdW50XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSB0cmVlXHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBwYXJ0IG9mIGEgcGFyZW50IHN1c3BlbnNlLiBnZXQgdGhlIGxhdGVzdCBhbmNob3IgZm9yIGluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBidWZmZXJlZCBlZmZlY3RzXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2VcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcclxuICAgICAgICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBtZXJnZSBidWZmZXJlZCBwb3N0IGpvYnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoYXQgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcclxuICAgICAgICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHJlc29sdmUgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25SZXNvbHZlJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XHJcbiAgICAgICAgICAgIHRydWUgLy8gc2hvdWxkUmVtb3ZlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgbW91bnRGYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAuYXN5bmNEZXAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmNTZXR1cFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSB3aGVuIHRoZSBzZXR1cCgpIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2bm9kZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWQgaWYgYW4gdXBkYXRlIGhhcHBlbmVkIGJlZm9yZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBkZXAgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBoeWRyYXRlZEVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIHZub2RlLCBcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cclxuICAgICAgICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSwgc3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUuZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRlY3JlYXNlIGRlcHMgY291bnQgaWYgc3VzcGVuc2UgaXMgbm90IGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBzdXNwZW5zZTtcclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcclxuICAgIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zIGZvciBzZXJ2ZXItcmVuZGVyZWQgc3VzcGVuc2U6XHJcbiAgICAvLyAtIHN1Y2Nlc3M6IHNzciBjb250ZW50IHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxyXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cclxuICAgIC8vIGhvd2V2ZXIsIG9uIHRoZSBjbGllbnQgd2UgZG9uJ3QgcmVhbGx5IGtub3cgaWYgaXQgaGFzIGZhaWxlZCBvciBub3RcclxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgRE9NIGFzc3VtaW5nIGl0IGhhcyBzdWNjZWVkZWQsIGJ1dCB3ZSBzdGlsbFxyXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUobm9kZSwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgdm5vZGUuc3NDb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuKTtcclxuICAgIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlblxyXG4gICAgICAgID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcclxuICAgIGxldCBibG9jaztcclxuICAgIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xyXG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGVUcmFja2luZzogZmFsc2VcclxuICAgICAgICAgICAgLy8gYWxsb3cgYmxvY2sgdHJhY2tpbmcgZm9yIGNvbXBpbGVkIHNsb3RzXHJcbiAgICAgICAgICAgIC8vIChzZWUgLi9jb21wb25lbnRSZW5kZXJDb250ZXh0LnRzKVxyXG4gICAgICAgICAgICBzLl9kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9wZW5CbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gcygpO1xyXG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIHMuX2QgPSB0cnVlO1xyXG4gICAgICAgICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gICAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcclxuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XHJcbiAgICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xyXG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xyXG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxyXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRoZSBIT0MgZWxcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXHJcbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnN0YW5jZSBpcyBhdCByb290XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xyXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlLnByb3h5KVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKG9wdGlvbnMgfHwge30sIHsgZmx1c2g6ICdwb3N0JyB9KVxyXG4gICAgICAgIDogeyBmbHVzaDogJ3Bvc3QnIH0pKTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IE9iamVjdC5hc3NpZ24ob3B0aW9ucyB8fCB7fSwgeyBmbHVzaDogJ3N5bmMnIH0pXHJcbiAgICAgICAgOiB7IGZsdXNoOiAnc3luYycgfSkpO1xyXG59XHJcbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXHJcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGNiKSkge1xyXG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xyXG4gICAgICAgICAgICBgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXHJcbiAgICAgICAgICAgIGBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcclxuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShpc1JlYWN0aXZlKTtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbb25DbGVhbnVwXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNsZWFudXA7XHJcbiAgICBsZXQgb25DbGVhbnVwID0gKGZuKSA9PiB7XHJcbiAgICAgICAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQgLyogV0FUQ0hfQ0xFQU5VUCAqLyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcclxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyXHJcbiAgICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XHJcbiAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5vdCBjYWxsIHRoZSBpbnZhbGlkYXRlIGNhbGxiYWNrICgrIHJ1bm5lciBpcyBub3Qgc2V0IHVwKVxyXG4gICAgICAgIG9uQ2xlYW51cCA9IE5PT1A7XHJcbiAgICAgICAgaWYgKCFjYikge1xyXG4gICAgICAgICAgICBnZXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgZ2V0dGVyKCksXHJcbiAgICAgICAgICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOT09QO1xyXG4gICAgfVxyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcclxuICAgICAgICAgICAgaWYgKGRlZXAgfHxcclxuICAgICAgICAgICAgICAgIGZvcmNlVHJpZ2dlciB8fFxyXG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGltcG9ydGFudDogbWFyayB0aGUgam9iIGFzIGEgd2F0Y2hlciBjYWxsYmFjayBzbyB0aGF0IHNjaGVkdWxlciBrbm93c1xyXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxyXG4gICAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XHJcbiAgICBsZXQgc2NoZWR1bGVyO1xyXG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSBqb2I7IC8vIHRoZSBzY2hlZHVsZXIgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZGlyZWN0bHlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCBpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUHJlRmx1c2hDYihqb2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCAncHJlJyBvcHRpb24sIHRoZSBmaXJzdCBjYWxsIG11c3QgaGFwcGVuIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHNvIGl0IGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XHJcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBlZmZlY3Quc3RvcCgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zY29wZSkge1xyXG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHRoaXMuJHdhdGNoXHJcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXHJcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKVxyXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBsZXQgY2I7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICBjYiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xyXG4gICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcclxuICAgIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xyXG4gICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGluZzogZmFsc2UsXHJcbiAgICAgICAgbGVhdmluZ1ZOb2RlczogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XHJcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxyXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcclxuICAgICAgICAvLyBlbnRlclxyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gbGVhdmVcclxuICAgICAgICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGFwcGVhclxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgd2FybignPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2sgcmVhY3Rpdml0eSBmb3IgdGhlc2UgcHJvcHMgc28gdXNlIHRoZSByYXdcclxuICAgICAgICAgICAgLy8gcHJvcHMgZm9yIGEgYml0IGJldHRlciBwZXJmXHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBtb2RlXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nICYmIG1vZGUgIT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgY2hpbGRyZW4gaGFzIGEgZ3VhcmFudGVlZCBsZW5ndGggb2YgMS5cclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIDx0cmFuc2l0aW9uPjxrZWVwLWFsaXZlLz48L3RyYW5zaXRpb24+LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIHR5cGUgb2YgdGhlIGtlcHQtYWxpdmUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICghaW5uZXJDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcclxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xyXG4gICAgICAgICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0VHJhbnNpdGlvbktleSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaGFuZGxlIG1vZGVcclxuICAgICAgICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiZcclxuICAgICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0JyAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGhvb2tzID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcGVyc2lzdGVkLFxyXG4gICAgICAgIGJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3Igc2FtZSBlbGVtZW50ICh2LXNob3cpXHJcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcclxuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBlYXJseSByZW1vdmFsIChub3QgY2FuY2VsbGVkKVxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2VudGVyQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAgICAgaG9vayhlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVhdmUoZWwsIHJlbW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9IHZub2RlO1xyXG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgb25MZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25MZWF2ZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaG9va3M7XHJcbn1cclxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXHJcbi8vIGluIHRoZSBjYXNlIG9mIGEgS2VlcEFsaXZlIGluIGEgbGVhdmUgcGhhc2Ugd2UgbmVlZCB0byByZXR1cm4gYSBLZWVwQWxpdmVcclxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xyXG4vLyB1bm1vdW50ZWQuXHJcbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcclxuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcclxuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcclxuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcclxuICAgICAgICA/IHZub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICA6IHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcclxuICAgICAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tbWVudCBwbGFjZWhvbGRlcnMgc2hvdWxkIGJlIHNraXBwZWQsIGUuZy4gdi1pZlxyXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uLCBjbG9zZSB0byBuby1vcFxyXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XHJcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XHJcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgbGV0IHJlc29sdmVkQ29tcDtcclxuICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cclxuICAgICAgICAgICAgICAgIGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXHJcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBrZWVwLWFsaXZlLCBmb3JjZSB1cGRhdGUgc28gdGhlIGxvYWRlZCBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgdGFrZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgeyB2bm9kZTogeyByZWYsIHByb3BzLCBjaGlsZHJlbiB9IH0pIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcclxuICAgIHZub2RlLnJlZiA9IHJlZjtcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXHJcbiAgICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxyXG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cclxuICAgIF9faXNLZWVwQWxpdmU6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcclxuICAgICAgICAvLyBjdHggd2hlcmUgdGhlIHJlbmRlcmVyIHBhc3NlcyBpbiBpdHMgaW50ZXJuYWxzLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGV4cG9zZXMgYWN0aXZhdGUvZGVhY3RpdmF0ZSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcclxuICAgICAgICAvLyByZW5kZXJlciB0byBmYWNpbGl0YXRlIHRyZWUtc2hha2luZy5cclxuICAgICAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xyXG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXHJcbiAgICAgICAgLy8gZm9yIEtlZXBBbGl2ZSwgd2UganVzdCBuZWVkIHRvIHJlbmRlciBpdHMgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xyXG4gICAgICAgIGNvbnN0IHsgcmVuZGVyZXI6IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiBfdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSB9ID0gc2hhcmVkQ29udGV4dDtcclxuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2UgcHJvcHMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIHBhdGNoKGluc3RhbmNlLnZub2RlLCB2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHZub2RlLnNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSAvKiBMRUFWRSAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuZGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXHJcbiAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XHJcbiAgICAgICAgICAgICAgICA6IGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5jbHVkZXMobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXR0ZXJuLnRlc3QpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcclxuICAgIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiAvKiBBQ1RJVkFURUQgKi8sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcclxuICAgIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIgLyogREVBQ1RJVkFURUQgKi8sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgLy8gY2FjaGUgdGhlIGRlYWN0aXZhdGUgYnJhbmNoIGNoZWNrIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lXHJcbiAgICAvLyBob29rIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZGNcIiBzdGFuZHMgZm9yIFwid2l0aFxyXG4gICAgLy8gZGVhY3RpdmF0aW9uIGNoZWNrXCIuXHJcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHxcclxuICAgICAgICAoaG9vay5fX3dkYyA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gb25seSBmaXJlIHRoZSBob29rIGlmIHRoZSB0YXJnZXQgaW5zdGFuY2UgaXMgTk9UIGluIGEgZGVhY3RpdmF0ZWQgYnJhbmNoLlxyXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XHJcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcclxuICAgICAgICAvLyBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2VoXCIgc3RhbmRzIGZvciBcIndpdGggZXJyb3JcclxuICAgICAgICAvLyBoYW5kbGluZ1wiLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxyXG4gICAgICAgICAgICAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRJbnN0YW5jZSBkdXJpbmcgaG9vayBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIGZhbHNlIHdoZW4gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgcmVhbGx5IGZ1bmt5LlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcclxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKSAmJlxyXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsIGhvb2ssIHRhcmdldCk7XHJcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi8pO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiIC8qIE1PVU5URUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi8pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIFVQREFURUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi8pO1xyXG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIFVOTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XHJcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcclxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXHJcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSwgaW5oZXJpdEF0dHJzLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIGluaXRpYWxpemF0aW9uIG9yZGVyICh0byBiZSBjb25zaXN0ZW50IHdpdGggVnVlIDIpOlxyXG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcclxuICAgIC8vIC0gaW5qZWN0XHJcbiAgICAvLyAtIG1ldGhvZHNcclxuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICAvLyAtIGNvbXB1dGVkXHJcbiAgICAvLyAtIHdhdGNoIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnVud3JhcEluamVjdGVkUmVmKTtcclxuICAgIH1cclxuICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZVxyXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LCBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXRcclxuICAgICAgICAgICAgICAgIC8vIHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNQcm9taXNlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2UgZGF0YSBvbiBjdHggZHVyaW5nIGRldlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICckJyAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0ZSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSBhdCB0aGlzIHBvaW50IC0gc3RhcnQgY2FjaGluZyBhY2Nlc3NcclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcclxuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xyXG4gICAgICAgICAgICAgICAgZ2V0LFxyXG4gICAgICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucylcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XHJcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIENSRUFURUQgKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICAgICAgaG9vay5mb3JFYWNoKF9ob29rID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XHJcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XHJcbiAgICAgICAgICAgIGV4cG9zZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWwgPT4gKHB1YmxpY1RoaXNba2V5XSA9IHZhbClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXHJcbiAgICAvLyBhcHBsaWVkIGZyb20gbWl4aW5zXHJcbiAgICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xyXG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcclxuICAgIH1cclxuICAgIC8vIGFzc2V0IG9wdGlvbnMuXHJcbiAgICBpZiAoY29tcG9uZW50cylcclxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICAgIGlmIChkaXJlY3RpdmVzKVxyXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCwgdW53cmFwUmVmID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgbGV0IGluamVjdGVkO1xyXG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XHJcbiAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSBjaGVjayBpbiAzLjNcclxuICAgICAgICAgICAgaWYgKHVud3JhcFJlZikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGluamVjdGVkLnZhbHVlID0gdilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGluamVjdGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYSByZWYgYW5kIHdpbGwgYmUgYXV0by11bndyYXBwZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhbmQgbm8gbG9uZ2VyIG5lZWRzIFxcYC52YWx1ZVxcYCBpbiB0aGUgbmV4dCBtaW5vciByZWxlYXNlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFRvIG9wdC1pbiB0byB0aGUgbmV3IGJlaGF2aW9yIG5vdywgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXQgXFxgYXBwLmNvbmZpZy51bndyYXBJbmplY3RlZFJlZiA9IHRydWVcXGAgKHRoaXMgY29uZmlnIGlzIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGVtcG9yYXJ5IGFuZCB3aWxsIG5vdCBiZSBuZWVkZWQgaW4gdGhlIGZ1dHVyZS4pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGlzQXJyYXkoaG9vaylcclxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcclxuICAgICAgICA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcclxuICAgIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSlcclxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcclxuICAgIGlmIChpc1N0cmluZyhyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XHJcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGN0eFtyYXcuaGFuZGxlcl07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVzb2x2ZSBtZXJnZWQgb3B0aW9ucyBhbmQgY2FjaGUgaXQgb24gdGhlIGNvbXBvbmVudC5cclxuICogVGhpcyBpcyBkb25lIG9ubHkgb25jZSBwZXItY29tcG9uZW50IHNpbmNlIHRoZSBtZXJnaW5nIGRvZXMgbm90IGludm9sdmVcclxuICogaW5zdGFuY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xyXG4gICAgY29uc3QgeyBtaXhpbnM6IGdsb2JhbE1peGlucywgb3B0aW9uc0NhY2hlOiBjYWNoZSwgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9IH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xyXG4gICAgbGV0IHJlc29sdmVkO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJlc29sdmVkID0gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc29sdmVkID0gYmFzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXNvbHZlZCA9IHt9O1xyXG4gICAgICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKG0gPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xyXG4gICAgfVxyXG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcclxuICAgIHJldHVybiByZXNvbHZlZDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XHJcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSkpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIGlmIChhc01peGluICYmIGtleSA9PT0gJ2V4cG9zZScpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgKHN0cmF0cyAmJiBzdHJhdHNba2V5XSk7XHJcbiAgICAgICAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvO1xyXG59XHJcbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XHJcbiAgICBkYXRhOiBtZXJnZURhdGFGbixcclxuICAgIHByb3BzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBlbWl0czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gb2JqZWN0c1xyXG4gICAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIGxpZmVjeWNsZVxyXG4gICAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXHJcbiAgICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxyXG4gICAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXHJcbiAgICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXHJcbiAgICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gd2F0Y2hcclxuICAgIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcclxuICAgIC8vIHByb3ZpZGUgLyBpbmplY3RcclxuICAgIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxyXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxyXG59O1xyXG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xyXG4gICAgaWYgKCFmcm9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bykge1xyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcclxuICAgICAgICByZXR1cm4gKGV4dGVuZCkoaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcclxuICAgIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIGlmICghdG8pXHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICBpZiAoIWZyb20pXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cclxuaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSB7fTtcclxuICAgIGNvbnN0IGF0dHJzID0ge307XHJcbiAgICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxuICAgIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgIC8vIGVuc3VyZSBhbGwgZGVjbGFyZWQgcHJvcCBrZXlzIGFyZSBwcmVzZW50XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgICAgIC8vIHN0YXRlZnVsXHJcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxyXG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcclxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XHJcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIChpbnN0YW5jZS50eXBlLl9faG1ySWQgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2htcklkKSkpICYmXHJcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxyXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykpIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gUFJPUFMgZmxhZyBndWFyYW50ZWVzIHJhd1Byb3BzIHRvIGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHIgLyBwcm9wcyBzZXBhcmF0aW9uIHdhcyBkb25lIG9uIGluaXQgYW5kIHdpbGwgYmUgY29uc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY29kZSBwYXRoLCBzbyBqdXN0IGNoZWNrIGlmIGF0dHJzIGhhdmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywgY2FtZWxpemVkS2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGZhbHNlIC8qIGlzQWJzZW50ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGZ1bGwgcHJvcHMgdXBkYXRlLlxyXG4gICAgICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XHJcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgZHluYW1pYyBwcm9wcywgY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUga2V5cyBmcm9tXHJcbiAgICAgICAgLy8gdGhlIHByb3BzIG9iamVjdFxyXG4gICAgICAgIGxldCBrZWJhYktleTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcclxuICAgICAgICAgICAgICAgICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Iga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgdW5kZWZpbmVkLCBpbnN0YW5jZSwgdHJ1ZSAvKiBpc0Fic2VudCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnVuY3Rpb25hbCBjb21wb25lbnQgdy9vIHByb3BzIGRlY2xhcmF0aW9uLCBwcm9wcyBhbmRcclxuICAgICAgICAvLyBhdHRycyBwb2ludCB0byB0aGUgc2FtZSBvYmplY3Qgc28gaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgaWYgKGF0dHJzICE9PSByYXdDdXJyZW50UHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWZhbHNlICkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xyXG4gICAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xyXG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogU0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcclxuICAgIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XHJcbiAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAvLyBwcm9wIG9wdGlvbiBuYW1lcyBhcmUgY2FtZWxpemVkIGR1cmluZyBub3JtYWxpemF0aW9uLCBzbyB0byBzdXBwb3J0XHJcbiAgICAgICAgICAgIC8vIGtlYmFiIC0+IGNhbWVsIGNvbnZlcnNpb24gaGVyZSB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBrZXkuXHJcbiAgICAgICAgICAgIGxldCBjYW1lbEtleTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIChjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XHJcbiAgICAgICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCBjYXN0VmFsdWVzW2tleV0sIGluc3RhbmNlLCAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XHJcbiAgICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICBpZiAob3B0ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgJ2RlZmF1bHQnKTtcclxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwobnVsbCwgcHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib29sZWFuIGNhc3RpbmdcclxuICAgICAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcclxuICAgICAgICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJlxyXG4gICAgICAgICAgICAgICAgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XHJcbiAgICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAoa2V5cylcclxuICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcclxuICAgICAgICByZXR1cm4gRU1QVFlfQVJSO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhdykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gKG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogb3B0KTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BbMCAvKiBzaG91bGRDYXN0ICovXSA9IGJvb2xlYW5JbmRleCA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByb3AgbmVlZHMgYm9vbGVhbiBjYXN0aW5nIG9yIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEgfHwgaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wTmFtZShrZXkpIHtcclxuICAgIGlmIChrZXlbMF0gIT09ICckJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyB1c2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgdHlwZSBjb25zdHJ1Y3RvcnNcclxuLy8gc28gdGhhdCBpdCB3b3JrcyBhY3Jvc3Mgdm1zIC8gaWZyYW1lcy5cclxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IGN0b3IgJiYgY3Rvci50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBjdG9yID09PSBudWxsID8gJ251bGwnIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRUeXBlcy5maW5kSW5kZXgodCA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKG9wdCA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YWxpZGF0ZVByb3Aoa2V5LCByZXNvbHZlZFZhbHVlc1trZXldLCBvcHQsICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcclxuICAgIC8vIHJlcXVpcmVkIVxyXG4gICAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XHJcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdHlwZSBjaGVja1xyXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjdXN0b20gdmFsaWRhdG9yXHJcbiAgICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnQnKTtcclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBsZXQgdmFsaWQ7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcclxuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnbnVsbCcpIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbGlkLFxyXG4gICAgICAgIGV4cGVjdGVkVHlwZVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcclxuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignIHwgJyl9YDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxyXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcclxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xyXG4gICAgfVxyXG4gICAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcclxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XHJcbiAgICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcclxuICAgIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZWxlbSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJyk7XHJcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xyXG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpXHJcbiAgICA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSlcclxuICAgIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgd2FybihgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiBgICtcclxuICAgICAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcclxuICAgICAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcclxuICAgIH0sIGN0eCk7XHJcbiAgICBub3JtYWxpemVkLl9jID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiZcclxuICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gYCArXHJcbiAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xyXG4gICAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XHJcbn07XHJcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXJzIGNhbiBnZXQgdGhlIHNoYWxsb3cgcmVhZG9ubHkgdmVyc2lvbiBvZiB0aGUgc2xvdHMgb2JqZWN0IHRocm91Z2ggYHRoaXMuJHNsb3RzYCxcclxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGF2b2lkIHRoZSBwcm94eSBvYmplY3QgcG9sbHV0aW5nIHRoZSBzbG90cyBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2VcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgY29tcGlsZXIgbWFya2VyIG5vbi1lbnVtZXJhYmxlXHJcbiAgICAgICAgICAgIGRlZihjaGlsZHJlbiwgJ18nLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCAoaW5zdGFuY2Uuc2xvdHMgPSB7fSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge307XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxufTtcclxuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XHJcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cclxuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlLCBhbmQgc2tpcCBzdGFsZSBzbG90cyByZW1vdmFsLlxyXG4gICAgICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIGJ1dCBkeW5hbWljICh2LWlmL3YtZm9yIG9uIHNsb3RzKSAtIHVwZGF0ZSBzbG90cywgYnV0IHNraXBcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIC8vICMyODkzXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyB0aGUgb3B0aW1pemVkIHNsb3RzIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIGBzbG90cy5fYCBmbGFnIGlmIG5lY2Vzc2FyeSB0byBtYWtlIHN1YnNlcXVlbnQgdXBkYXRlcyByZWxpYWJsZSxcclxuICAgICAgICAgICAgICAgIC8vIGkuZS4gbGV0IHRoZSBgcmVuZGVyU2xvdGAgY3JlYXRlIHRoZSBiYWlsZWQgRnJhZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzLl87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBub24gc2xvdCBvYmplY3QgY2hpbGRyZW4gKGRpcmVjdCB2YWx1ZSkgcGFzc2VkIHRvIGEgY29tcG9uZW50XHJcbiAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xyXG4gICAgfVxyXG4gICAgLy8gZGVsZXRlIHN0YWxlIHNsb3RzXHJcbiAgICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xyXG4gICAgICAgICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiAhKGtleSBpbiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxuLyoqXHJcblJ1bnRpbWUgaGVscGVyIGZvciBhcHBseWluZyBkaXJlY3RpdmVzIHRvIGEgdm5vZGUuIEV4YW1wbGUgdXNhZ2U6XHJcblxuY29uc3QgY29tcCA9IHJlc29sdmVDb21wb25lbnQoJ2NvbXAnKVxyXG5jb25zdCBmb28gPSByZXNvbHZlRGlyZWN0aXZlKCdmb28nKVxyXG5jb25zdCBiYXIgPSByZXNvbHZlRGlyZWN0aXZlKCdiYXInKVxyXG5cbnJldHVybiB3aXRoRGlyZWN0aXZlcyhoKGNvbXApLCBbXHJcbiAgW2ZvbywgdGhpcy54XSxcclxuICBbYmFyLCB0aGlzLnldXHJcbl0pXHJcbiovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXIuZGVlcCkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcclxuICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBESVJFQ1RJVkVfSE9PSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwOiBudWxsLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXHJcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIG9wdGlvbnNDYWNoZTogbmV3IFdlYWtNYXAoKSxcclxuICAgICAgICBwcm9wc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIGVtaXRzQ2FjaGU6IG5ldyBXZWFrTWFwKClcclxuICAgIH07XHJcbn1cclxubGV0IHVpZCA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgICAgIHJvb3RQcm9wcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgYXBwID0gKGNvbnRleHQuYXBwID0ge1xyXG4gICAgICAgICAgICBfdWlkOiB1aWQrKyxcclxuICAgICAgICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcclxuICAgICAgICAgICAgX3Byb3BzOiByb290UHJvcHMsXHJcbiAgICAgICAgICAgIF9jb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICBfaW5zdGFuY2U6IG51bGwsXHJcbiAgICAgICAgICAgIHZlcnNpb24sXHJcbiAgICAgICAgICAgIGdldCBjb25maWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCBjb25maWcodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogJycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI0NTg3XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogRnVuY3Rpb24gZm9yIGhhbmRsaW5nIGEgdGVtcGxhdGUgcmVmXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcclxuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcclxuICAgICAgICAvLyB3aGVuIG1vdW50aW5nIGFzeW5jIGNvbXBvbmVudHMsIG5vdGhpbmcgbmVlZHMgdG8gYmUgZG9uZSxcclxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB0ZW1wbGF0ZSByZWYgaXMgZm9yd2FyZGVkIHRvIGlubmVyIGNvbXBvbmVudFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi9cclxuICAgICAgICA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5XHJcbiAgICAgICAgOiB2bm9kZS5lbDtcclxuICAgIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xyXG4gICAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFvd25lcikge1xyXG4gICAgICAgIHdhcm4oYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gYCArXHJcbiAgICAgICAgICAgIGBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XHJcbiAgICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gKG93bmVyLnJlZnMgPSB7fSkgOiBvd25lci5yZWZzO1xyXG4gICAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XHJcbiAgICAvLyBkeW5hbWljIHJlZiBjaGFuZ2VkLiB1bnNldCBvbGQgcmVmXHJcbiAgICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xyXG4gICAgICAgICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcclxuICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xyXG4gICAgICAgICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XHJcbiAgICAgICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcclxuICAgICAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xyXG4gICAgICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZihyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb1NldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5sZXQgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENPTU1FTlQgKi87XHJcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcclxuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXHJcbi8vIGl0IG91dCBjcmVhdGVzIGEgdG9uIG9mIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxyXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgY29uc3QgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBub2RlO1xyXG4gICAgICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAzIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaDpgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBhbmNob3IsIGFkb3B0IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRpYyB2bm9kZSBoYXMgaXRzIGNvbnRlbnQgc3RyaXBwZWQgZHVyaW5nIGJ1aWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkb3B0IGl0IGZyb20gdGhlIHNlcnZlci1yZW5kZXJlZCBIVE1MLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5vdXRlckhUTUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGl0cyBzdWItdHJlZS5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudCh2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgYmUgYXN5bmMsIHNvIGluIHRoZSBjYXNlIG9mIGZyYWdtZW50cyB3ZSBjYW5ub3QgcmVseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGNvbXBvbmVudCdzIHJlbmRlcmVkIG91dHB1dCB0byBkZXRlcm1pbmUgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCB3ZSBkbyBhIGxvb2thaGVhZCB0byBmaW5kIHRoZSBlbmQgYW5jaG9yIG5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjMzc4N1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBhc3luYywgaXQgbWF5IGdldCBtb3ZlZCAvIHVubW91bnRlZCBiZWZvcmUgaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlzIGxvYWRlZCwgc28gd2UgbmVlZCB0byBnaXZlIGl0IGEgcGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSB0aGF0IG1hdGNoZXMgaXRzIGFkb3B0ZWQgRE9NLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKCcnKSA6IGNyZWF0ZVZOb2RlKCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyAjNDAwNiBmb3IgZm9ybSBlbGVtZW50cyB3aXRoIG5vbi1zdHJpbmcgdi1tb2RlbCB2YWx1ZSBiaW5kaW5nc1xyXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiA6dmFsdWU9XCJvYmpcIj4sIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiA6dHJ1ZS12YWx1ZT1cIjFcIj5cclxuICAgICAgICBjb25zdCBmb3JjZVBhdGNoVmFsdWUgPSAodHlwZSA9PT0gJ2lucHV0JyAmJiBkaXJzKSB8fCB0eXBlID09PSAnb3B0aW9uJztcclxuICAgICAgICAvLyBza2lwIHByb3BzICYgY2hpbGRyZW4gaWYgdGhpcyBpcyBob2lzdGVkIHN0YXRpYyBub2Rlc1xyXG4gICAgICAgIC8vICM1NDA1IGluIGRldiwgYWx3YXlzIGh5ZHJhdGUgY2hpbGRyZW4gZm9yIEhNUlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgZm9yY2VQYXRjaFZhbHVlIHx8IHBhdGNoRmxhZyAhPT0gLTEgLyogSE9JU1RFRCAqLykge1xyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFvcHRpbWl6ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAoMTYgLyogRlVMTF9QUk9QUyAqLyB8IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZm9yY2VQYXRjaFZhbHVlICYmIGtleS5lbmRzV2l0aCgndmFsdWUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgZmFsc2UsIHVuZGVmaW5lZCwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpbmcgdGhyb3VnaCBwcm9wcy5cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljaywgZmFsc2UsIHVuZGVmaW5lZCwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2bm9kZSAvIGRpcmVjdGl2ZSBob29rc1xyXG4gICAgICAgICAgICBsZXQgdm5vZGVIb29rcztcclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hpbGRyZW5cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovICYmXHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XHJcbiAgICAgICAgICAgICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oZWwuZmlyc3RDaGlsZCwgdm5vZGUsIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgU1NSZWQgRE9NIGNvbnRhaW5zIG1vcmUgbm9kZXMgdGhhbiBpdCBzaG91bGQuIFJlbW92ZSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjpcXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIFNlcnZlcjogJHt2bm9kZS5jaGlsZHJlbn1gKTtcclxuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxyXG4gICAgICAgICAgICAgICAgOiAoY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xyXG4gICAgICAgICAgICAgICAgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKVxyXG4gICAgICAgICAgICAgICAgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZygodm5vZGUuYW5jaG9yID0gbmV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnJhZ21lbnQgZGlkbid0IGh5ZHJhdGUgc3VjY2Vzc2Z1bGx5LCBzaW5jZSB3ZSBkaWRuJ3QgZ2V0IGEgZW5kIGFuY2hvclxyXG4gICAgICAgICAgICAvLyBiYWNrLiBUaGlzIHNob3VsZCBoYXZlIGxlZCB0byBub2RlL2NoaWxkcmVuIG1pc21hdGNoIHdhcm5pbmdzLlxyXG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBhbmNob3IgaXMgbWlzc2luZywgd2UgbmVlZCB0byBjcmVhdGUgb25lIGFuZCBpbnNlcnQgaXRcclxuICAgICAgICAgICAgaW5zZXJ0KCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCkpLCBjb250YWluZXIsIG5leHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xyXG4gICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi9cclxuICAgICAgICAgICAgICAgID8gYCh0ZXh0KWBcclxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWBcclxuICAgICAgICAgICAgICAgICAgICA6IGBgKTtcclxuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4Y2Vzc2l2ZSBmcmFnbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICByZW1vdmUobm9kZSk7XHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbmV4dCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xyXG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcclxufVxuXG4vKipcclxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXHJcbiAqIEl0IGlzIGNhbGxlZCB3aGVuIGEgcmVuZGVyZXIgaXMgY3JlYXRlZCwgaW4gYGJhc2VDcmVhdGVSZW5kZXJlcmAgc28gdGhhdFxyXG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxyXG4gKlxyXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcclxuICAgIGNvbnN0IG5lZWRXYXJuID0gW107XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKCcsICcpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIGAgK1xyXG4gICAgICAgICAgICBgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uIGJ1bmRsZS5cXG5cXG5gICtcclxuICAgICAgICAgICAgYEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuLyoqXHJcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcclxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXHJcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cclxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XHJcbiAqICAgcGF0Y2hQcm9wLFxyXG4gKiAgIC4uLm5vZGVPcHNcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xyXG59XHJcbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXHJcbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxyXG4vLyB0cmVlLXNoYWthYmxlLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcclxuICAgIHtcclxuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XHJcbiAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgaW5zZXJ0OiBob3N0SW5zZXJ0LCByZW1vdmU6IGhvc3RSZW1vdmUsIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCwgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCwgc2V0VGV4dDogaG9zdFNldFRleHQsIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLCBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLCBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsIGNsb25lTm9kZTogaG9zdENsb25lTm9kZSwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XHJcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcclxuICAgIC8vIHN0eWxlIGluIG9yZGVyIHRvIHByZXZlbnQgYmVpbmcgaW5saW5lZCBieSBtaW5pZmllcnMuXHJcbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcclxuICAgICAgICBpZiAobjEgPT09IG4yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGF0Y2hpbmcgJiBub3Qgc2FtZSB0eXBlLCB1bm1vdW50IG9sZCB0cmVlXHJcbiAgICAgICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xyXG4gICAgICAgICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgbjEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMiAvKiBCQUlMICovKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbikpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgbjIuZWwsIG4yLmFuY2hvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXYgLyBITVIgb25seVxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgLy8gc3RhdGljIG5vZGVzIGFyZSBvbmx5IHBhdGNoZWQgZHVyaW5nIGRldiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xyXG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKHZub2RlLmNoaWxkcmVuLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcgJiYgdHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBmb3Igc2V0dGluZyB2YWx1ZSBvbiBET00gZWxlbWVudHM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIGl0IGNhbiBiZSBvcmRlci1zZW5zaXRpdmUgKGUuZy4gc2hvdWxkIGJlIHNldCAqYWZ0ZXIqIG1pbi9tYXgsICMyMzI1LCAjNDAyNClcclxuICAgICAgICAgICAgICAgICAqIC0gaXQgbmVlZHMgdG8gYmUgZm9yY2VkICgjMTQ3MSlcclxuICAgICAgICAgICAgICAgICAqICMyMzUzIHByb3Bvc2VzIGFkZGluZyBhbm90aGVyIHJlbmRlcmVyIG9wdGlvbiB0byBjb25maWd1cmUgdGhpcywgYnV0XHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgcHJvcGVydGllcyBhZmZlY3RzIGFyZSBzbyBmaW5pdGUgaXQgaXMgd29ydGggc3BlY2lhbCBjYXNpbmcgaXRcclxuICAgICAgICAgICAgICAgICAqIGhlcmUgdG8gcmVkdWNlIHRoZSBjb21wbGV4aXR5LiAoU3BlY2lhbCBjYXNpbmcgaXQgYWxzbyBzaG91bGQgbm90XHJcbiAgICAgICAgICAgICAgICAgKiBhZmZlY3Qgbm9uLURPTSByZW5kZXJlcnMpXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgbnVsbCwgcHJvcHMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvcGVJZFxyXG4gICAgICAgICAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Zub2RlJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZub2RlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdnVlUGFyZW50Q29tcG9uZW50Jywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAjMTU4MyBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2Ugbm90IHJlc29sdmVkIGNhc2UsIGVudGVyIGhvb2sgc2hvdWxkIGNhbGwgd2hlbiBzdXNwZW5zZSByZXNvbHZlZFxyXG4gICAgICAgIC8vICMxNjg5IEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSByZXNvbHZlZCBjYXNlLCBqdXN0IGNhbGwgaXRcclxuICAgICAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9ICghcGFyZW50U3VzcGVuc2UgfHwgKHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSkgJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XHJcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHxcclxuICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHxcclxuICAgICAgICAgICAgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcclxuICAgICAgICBpZiAoc2NvcGVJZCkge1xyXG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xyXG4gICAgICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgcGFyZW50Vk5vZGUsIHBhcmVudFZOb2RlLnNjb3BlSWQsIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xyXG4gICAgICAgIC8vICMxNDI2IHRha2UgdGhlIG9sZCB2bm9kZSdzIHBhdGNoIGZsYWcgaW50byBhY2NvdW50IHNpbmNlIHVzZXIgbWF5IGNsb25lIGFcclxuICAgICAgICAvLyBjb21waWxlci1nZW5lcmF0ZWQgdm5vZGUsIHdoaWNoIGRlLW9wdHMgdG8gRlVMTF9QUk9QU1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovO1xyXG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgLy8gZGlzYWJsZSByZWN1cnNlIGluIGJlZm9yZVVwZGF0ZSBob29rc1xyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlIHByZXNlbmNlIG9mIGEgcGF0Y2hGbGFnIG1lYW5zIHRoaXMgZWxlbWVudCdzIHJlbmRlciBjb2RlIHdhc1xyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIGFuZCBjYW4gdGFrZSB0aGUgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAvLyBpbiB0aGlzIHBhdGggb2xkIG5vZGUgYW5kIG5ldyBub2RlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcclxuICAgICAgICAgICAgLy8gKGkuZS4gYXQgdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSB0ZW1wbGF0ZSlcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcHMgY29udGFpbiBkeW5hbWljIGtleXMsIGZ1bGwgZGlmZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIGNsYXNzIGJpbmRpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIgLyogQ0xBU1MgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdjbGFzcycsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3R5bGVcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgc3R5bGUgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA0IC8qIFNUWUxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3N0eWxlJywgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBwcm9wL2F0dHIgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHRoYW4gY2xhc3MgYW5kIHN0eWxlLiBUaGUga2V5cyBvZiBkeW5hbWljIHByb3AvYXR0cnMgYXJlIHNhdmVkIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gZmFzdGVyIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgZHluYW1pYyBrZXlzIGxpa2UgOltmb29dPVwiYmFyXCIgd2lsbCBjYXVzZSB0aGlzIG9wdGltaXphdGlvbiB0b1xyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBvdXQgYW5kIGdvIHRocm91Z2ggYSBmdWxsIGRpZmYgYmVjYXVzZSB3ZSBuZWVkIHRvIHVuc2V0IHRoZSBvbGQga2V5XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmbGFnIGlzIHByZXNlbnQgdGhlbiBkeW5hbWljUHJvcHMgbXVzdCBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NzEgZm9yY2UgcGF0Y2ggdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXHJcbiAgICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb250YWluZXIgKHBhcmVudCBlbGVtZW50KSBmb3IgdGhlIHBhdGNoLlxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBcclxuICAgICAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcclxuICAgICAgICAgICAgb2xkVk5vZGUuZWwgJiZcclxuICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBDT01QT05FTlQgKi8gfCA2NCAvKiBURUxFUE9SVCAqLykpXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmVyIHBhdGNoaW5nIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgb2xkUHJvcHNba2V5XSwgbnVsbCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IChuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBzbG90IGZyYWdtZW50IHdpdGggOnNsb3R0ZWQgc2NvcGUgaWRzXHJcbiAgICAgICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xyXG4gICAgICAgICAgICAgICAgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKVxyXG4gICAgICAgICAgICAgICAgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gYSBmcmFnbWVudCBjYW4gb25seSBoYXZlIGFycmF5IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyLCBvciBpbXBsaWNpdGx5IGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4objIuY2hpbGRyZW4sIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcmVuZGVyZXIgaW50ZXJuYWxzIGZvciBrZWVwQWxpdmVcclxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwKCkgaXMgYXN5bmMuIFRoaXMgY29tcG9uZW50IHJlbGllcyBvbiBhc3luYyBsb2dpYyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIC8vIGJlZm9yZSBwcm9jZWVkaW5nXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBwbGFjZWhvbGRlciBpZiB0aGlzIGlzIG5vdCBoeWRyYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKG4yLmNvbXBvbmVudCA9IG4xLmNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmXHJcbiAgICAgICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgJiBzdGlsbCBwZW5kaW5nIC0ganVzdCB1cGRhdGUgcHJvcHMgYW5kIHNsb3RzXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY29tcG9uZW50J3MgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXIgaXNuJ3Qgc2V0LXVwIHlldFxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG4yLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XHJcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBjaGlsZCBjb21wb25lbnQgaXMgYWxzbyBxdWV1ZWQsIHJlbW92ZSBpdCB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHVwZGF0aW5nIHRoZSBzYW1lIGNoaWxkIGNvbXBvbmVudCBpbiB0aGUgc2FtZSBmbHVzaC5cclxuICAgICAgICAgICAgICAgIGludmFsaWRhdGVKb2IoaW5zdGFuY2UudXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlLnVwZGF0ZSBpcyB0aGUgcmVhY3RpdmUgZWZmZWN0LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgaGFzIGFkb3B0ZWQgaG9zdCBub2RlIC0gcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOb2RlKGVsLCBpbnN0YW5jZS5zdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUudHlwZS5fX2FzeW5jTG9hZGVyKCkudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHNlcnZlci1yZW5kZXJlZCBhc3luYyB3cmFwcGVyIGlzIGFscmVhZHkgaW4gcmVzb2x2ZWQgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IChpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlTW91bnRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWxsb3cgY29tcG9uZW50IGVmZmVjdCByZWN1cnNpb24gZHVyaW5nIHByZS1saWZlY3ljbGUgaG9va3MuXHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVVcGRhdGUgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gocHJldlRyZWUsIG5leHRUcmVlLCBcclxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxyXG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYtdHJpZ2dlcmVkIHVwZGF0ZS4gSW4gY2FzZSBvZiBIT0MsIHVwZGF0ZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgZWwuIEhPQyBpcyBpbmRpY2F0ZWQgYnkgcGFyZW50IGluc3RhbmNlJ3Mgc3ViVHJlZSBwb2ludGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoaWxkIGNvbXBvbmVudCdzIHZub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmICh1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVVcGRhdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBjb25zdCBlZmZlY3QgPSAoaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGNvbXBvbmVudFVwZGF0ZUZuLCAoKSA9PiBxdWV1ZUpvYihpbnN0YW5jZS51cGRhdGUpLCBpbnN0YW5jZS5zY29wZSAvLyB0cmFjayBpdCBpbiBjb21wb25lbnQncyBlZmZlY3Qgc2NvcGVcclxuICAgICAgICApKTtcclxuICAgICAgICBjb25zdCB1cGRhdGUgPSAoaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCkpO1xyXG4gICAgICAgIHVwZGF0ZS5pZCA9IGluc3RhbmNlLnVpZDtcclxuICAgICAgICAvLyBhbGxvd1JlY3Vyc2VcclxuICAgICAgICAvLyAjMTgwMSwgIzIwNDMgY29tcG9uZW50IHJlbmRlciBlZmZlY3RzIHNob3VsZCBhbGxvdyByZWN1cnNpdmUgdXBkYXRlc1xyXG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGNcclxuICAgICAgICAgICAgICAgID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpXHJcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcclxuICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0Z1xyXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSlcclxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIChmb3Igc2NoZWR1bGVyKVxyXG4gICAgICAgICAgICB1cGRhdGUub3duZXJJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xyXG4gICAgICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xyXG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xyXG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcclxuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAvLyBwcm9wcyB1cGRhdGUgbWF5IGhhdmUgdHJpZ2dlcmVkIHByZS1mbHVzaCB3YXRjaGVycy5cclxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHVuZGVmaW5lZCwgaW5zdGFuY2UudXBkYXRlKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcclxuICAgICAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aFxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxyXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgcGF0Y2hGbGFnIG1lYW5zIGNoaWxkcmVuIGFyZSBndWFyYW50ZWVkIHRvIGJlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVua2V5ZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGNoaWxkcmVuIGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gYzEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBhcnJheXMsIGNhbm5vdCBhc3N1bWUgYW55dGhpbmcsIGRvIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIHRleHQgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChjMVtpXSwgbmV4dENoaWxkLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZFxyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBhbGwta2V5ZWQgb3IgbWl4ZWRcclxuICAgIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTsgLy8gcHJldiBlbmRpbmcgaW5kZXhcclxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpIGQgZVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIHN5bmMgZnJvbSBlbmRcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gZCBlIChiIGMpXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbZTJdID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlMS0tO1xyXG4gICAgICAgICAgICBlMi0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBjb21tb24gc2VxdWVuY2UgKyBtb3VudFxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDEsIGUyID0gMlxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gYyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IC0xLCBlMiA9IDBcclxuICAgICAgICBpZiAoaSA+IGUxKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA0LiBjb21tb24gc2VxdWVuY2UgKyB1bm1vdW50XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMiwgZTIgPSAxXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIChiIGMpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gMCwgZTIgPSAtMVxyXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBlMSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxyXG4gICAgICAgIC8vIFtpIC4uLiBlMSArIDFdOiBhIGIgW2MgZCBlXSBmIGdcclxuICAgICAgICAvLyBbaSAuLi4gZTIgKyAxXTogYSBiIFtlIGQgYyBoXSBmIGdcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgczEgPSBpOyAvLyBwcmV2IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICAvLyA1LjEgYnVpbGQga2V5OmluZGV4IG1hcCBmb3IgbmV3Q2hpbGRyZW5cclxuICAgICAgICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLCBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS4yIGxvb3AgdGhyb3VnaCBvbGQgY2hpbGRyZW4gbGVmdCB0byBiZSBwYXRjaGVkIGFuZCB0cnkgdG8gcGF0Y2hcclxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgbm9kZXMgJiByZW1vdmUgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnRcclxuICAgICAgICAgICAgbGV0IGo7XHJcbiAgICAgICAgICAgIGxldCBwYXRjaGVkID0gMDtcclxuICAgICAgICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcclxuICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnkgbm9kZSBoYXMgbW92ZWRcclxuICAgICAgICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xyXG4gICAgICAgICAgICAvLyB3b3JrcyBhcyBNYXA8bmV3SW5kZXgsIG9sZEluZGV4PlxyXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb2xkSW5kZXggaXMgb2Zmc2V0IGJ5ICsxXHJcbiAgICAgICAgICAgIC8vIGFuZCBvbGRJbmRleCA9IDAgaXMgYSBzcGVjaWFsIHZhbHVlIGluZGljYXRpbmcgdGhlIG5ldyBub2RlIGhhc1xyXG4gICAgICAgICAgICAvLyBubyBjb3JyZXNwb25kaW5nIG9sZCBub2RlLlxyXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBkZXRlcm1pbmluZyBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZVxyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKylcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbmV3IGNoaWxkcmVuIGhhdmUgYmVlbiBwYXRjaGVkIHNvIHRoaXMgY2FuIG9ubHkgYmUgYSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBrZXktbGVzcyBub2RlLCB0cnkgdG8gbG9jYXRlIGEga2V5LWxlc3Mgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gocHJldkNoaWxkLCBjMltuZXdJbmRleF0sIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlIG9ubHkgd2hlbiBub2RlcyBoYXZlIG1vdmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWRcclxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxyXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9BUlI7XHJcbiAgICAgICAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGlmOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHN0YWJsZSBzdWJzZXF1ZW5jZSAoZS5nLiBhIHJldmVyc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgY3VycmVudCBub2RlIGlzIG5vdCBhbW9uZyB0aGUgc3RhYmxlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMiAvKiBSRU9SREVSICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcclxuICAgICAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNpbmdsZSBub2Rlc1xyXG4gICAgICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uID0gbW92ZVR5cGUgIT09IDIgLyogUkVPUkRFUiAqLyAmJlxyXG4gICAgICAgICAgICBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjtcclxuICAgICAgICBpZiAobmVlZFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIEVOVEVSICovKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHJlZiwgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vIHVuc2V0IHJlZlxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgZGlycztcclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxyXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVubW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIGludGVybmFscywgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXHJcbiAgICAgICAgICAgICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihkeW5hbWljQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmXHJcbiAgICAgICAgICAgICAgICAgICAgKDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLyB8IDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcclxuICAgICAgICAgICAgICAgICghb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiZcclxuICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpKSB8fFxyXG4gICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAndW5tb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVtb3ZlID0gdm5vZGUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xyXG4gICAgICAgIC8vIEZvciBmcmFnbWVudHMsIGRpcmVjdGx5IHJlbW92ZSBhbGwgY29udGFpbmVkIERPTSBub2Rlcy5cclxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoZW5kKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBiZWZvcmVVbm1vdW50IGhvb2tcclxuICAgICAgICBpZiAoYnVtKSB7XHJcbiAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0b3AgZWZmZWN0cyBpbiBjb21wb25lbnQgc2NvcGVcclxuICAgICAgICBzY29wZS5zdG9wKCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBzY2hlZHVsZXIgd2lsbCBubyBsb25nZXIgaW52b2tlIGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcclxuICAgICAgICBpZiAodW0pIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgLy8gQSBjb21wb25lbnQgd2l0aCBhc3luYyBkZXAgaW5zaWRlIGEgcGVuZGluZyBzdXNwZW5zZSBpcyB1bm1vdW50ZWQgYmVmb3JlXHJcbiAgICAgICAgLy8gaXRzIGFzeW5jIGRlcCByZXNvbHZlcy4gVGhpcyBzaG91bGQgcmVtb3ZlIHRoZSBkZXAgZnJvbSB0aGUgc3VzcGVuc2UsIGFuZFxyXG4gICAgICAgIC8vIGNhdXNlIHRoZSBzdXNwZW5zZSB0byByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoYXQgd2FzIHRoZSBsYXN0IGRlcC5cclxuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiZcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJlxyXG4gICAgICAgICAgICAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gdm5vZGUgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG9zdE5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAodm5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2goY29udGFpbmVyLl92bm9kZSB8fCBudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBudWxsLCBudWxsLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGludGVybmFscyA9IHtcclxuICAgICAgICBwOiBwYXRjaCxcclxuICAgICAgICB1bTogdW5tb3VudCxcclxuICAgICAgICBtOiBtb3ZlLFxyXG4gICAgICAgIHI6IHJlbW92ZSxcclxuICAgICAgICBtdDogbW91bnRDb21wb25lbnQsXHJcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXHJcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXHJcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxyXG4gICAgICAgIG86IG9wdGlvbnNcclxuICAgIH07XHJcbiAgICBsZXQgaHlkcmF0ZTtcclxuICAgIGxldCBoeWRyYXRlTm9kZTtcclxuICAgIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICBoeWRyYXRlLFxyXG4gICAgICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgdXBkYXRlIH0sIGFsbG93ZWQpIHtcclxuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcclxufVxyXG4vKipcclxuICogIzExNTZcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXHJcbiAqIGluc2lkZSBhIGJsb2NrIGFsc28gaW5oZXJpdCB0aGUgRE9NIGVsZW1lbnQgZnJvbSB0aGUgcHJldmlvdXMgdHJlZSBzbyB0aGF0XHJcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxyXG4gKlxyXG4gKiAjMjA4MFxyXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXHJcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBiZSBtb3ZlZC4gVGhlcmVmb3JlLCBpbiBvcmRlciB0byBlbnN1cmUgY29ycmVjdCBtb3ZlXHJcbiAqIHBvc2l0aW9uLCBlbCBzaG91bGQgYmUgaW5oZXJpdGVkIGZyb20gcHJldmlvdXMgbm9kZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSB2bm9kZXNcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBjaDFbaV07XHJcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcclxuICAgICAgICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSByZWNlaXZlZCAuZWwgZHVyaW5nIGJsb2NrIHBhdGNoKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKHUgKyB2KSA+PiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBjICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh1ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3VdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgdiA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICB3aGlsZSAodS0tID4gMCkge1xyXG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XHJcbiAgICAgICAgdiA9IHBbdl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XG5cbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XHJcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSAnJyk7XHJcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XHJcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xyXG4gICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcclxuICAgIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcclxuICAgICAgICBpZiAoIXNlbGVjdCkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcclxuICAgIH1cclxufTtcclxuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xyXG4gICAgX19pc1RlbGVwb3J0OiB0cnVlLFxyXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xyXG4gICAgICAgIGNvbnN0IHsgbWM6IG1vdW50Q2hpbGRyZW4sIHBjOiBwYXRjaENoaWxkcmVuLCBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbiwgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcclxuICAgICAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xyXG4gICAgICAgIC8vICMzMzAyXHJcbiAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChuMi5lbCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBzdGFydCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgZW5kJylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIC8vICMyNjUyIHdlIGNvdWxkIGJlIHRlbGVwb3J0aW5nIGZyb20gYSBub24tU1ZHIHRyZWUgaW50byBhbiBTVkcgdHJlZVxyXG4gICAgICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCAqYWx3YXlzKiBoYXMgQXJyYXkgY2hpbGRyZW4uIFRoaXMgaXMgZW5mb3JjZWQgaW4gYm90aCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSBuMS5hbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gbjEudGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xyXG4gICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCB3aGVuIHRoZSB0ZWxlcG9ydCBoYXBwZW5zIHRvIGJlIGEgYmxvY2sgcm9vdFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjdXJyZW50Q29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdGVsZXBvcnQgaW5oZXJpdCBwcmV2aW91cyBET00gcmVmZXJlbmNlcyBzbyB0aGF0IHRoZXkgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBtb3ZlZCBpbiBmdXR1cmUgcGF0Y2hlcy5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZWQgLT4gZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gbWFpbiBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIG5leHRUYXJnZXQsIG51bGwsIGludGVybmFscywgMCAvKiBUQVJHRVRfQ0hBTkdFICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gdGVsZXBvcnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCB0YXJnZXQsIHRhcmdldEFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gdW5tb3VudGVkIHRlbGVwb3J0IHNob3VsZCBhbHdheXMgcmVtb3ZlIGl0cyBjaGlsZHJlbiBpZiBub3QgZGlzYWJsZWRcclxuICAgICAgICBpZiAoZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcclxufTtcclxuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMiAvKiBSRU9SREVSICovKSB7XHJcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXHJcbiAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogVEFSR0VUX0NIQU5HRSAqLykge1xyXG4gICAgICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDIgLyogUkVPUkRFUiAqLztcclxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXHJcbiAgICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICAgICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGlzIGlzIGEgcmUtb3JkZXIgYW5kIHRlbGVwb3J0IGlzIGVuYWJsZWQgKGNvbnRlbnQgaXMgaW4gdGFyZ2V0KVxyXG4gICAgLy8gZG8gbm90IG1vdmUgY2hpbGRyZW4uIFNvIHRoZSBvcHBvc2l0ZSBpczogb25seSBtb3ZlIGNoaWxkcmVuIGlmIHRoaXNcclxuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgIC8vIFRlbGVwb3J0IGhhcyBlaXRoZXIgQXJyYXkgY2hpbGRyZW4gb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAodm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh2bm9kZS5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIHBpY2sgdXAgZnJvbSB3aGVyZSB0aGUgbGFzdCB0ZWxlcG9ydCBmaW5pc2hlZCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBub2RlXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgcGFyZW50Tm9kZShub2RlKSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKHRhcmdldE5vZGUsIHZub2RlLCB0YXJnZXQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YXJnZXQuX2xwYSA9XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XHJcbn1cclxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcclxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5cbmNvbnN0IENPTVBPTkVOVFMgPSAnY29tcG9uZW50cyc7XHJcbmNvbnN0IERJUkVDVElWRVMgPSAnZGlyZWN0aXZlcyc7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xyXG59XHJcbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBpbnZhbGlkIHR5cGVzIHdpbGwgZmFsbHRocm91Z2ggdG8gY3JlYXRlVk5vZGUgYW5kIHJhaXNlIHdhcm5pbmdcclxuICAgICAgICByZXR1cm4gKGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICAvLyBleHBsaWNpdCBzZWxmIG5hbWUgaGFzIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKHNlbGZOYW1lICYmXHJcbiAgICAgICAgICAgICAgICAoc2VsZk5hbWUgPT09IG5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFxyXG4gICAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxyXG4gICAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxyXG4gICAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fFxyXG4gICAgICAgICAgICAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSk7XHJcbiAgICAgICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGltcGxpY2l0IHNlbGYtcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xyXG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFNcclxuICAgICAgICAgICAgICAgID8gYFxcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmBcclxuICAgICAgICAgICAgICAgIDogYGA7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcclxuICAgICAgICAgICAgYGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKHJlZ2lzdHJ5ICYmXHJcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pKTtcclxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBDb21tZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IGJsb2NrIGNoaWxkcmVuIG9uIHRoZSBibG9jayB2bm9kZVxyXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cclxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZykge1xyXG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgdHJ1ZSAvKiBpc0Jsb2NrICovKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxyXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxyXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcclxuICAgIHJldHVybiBzZXR1cEJsb2NrKGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHRydWUgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgbjIuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiZcclxuICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gSE1SIG9ubHk6IGlmIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaG90LXVwZGF0ZWQsIGZvcmNlIGEgcmVsb2FkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuLyoqXHJcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcclxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcclxuICogSXQgaXMgKmludGVybmFsKiBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZCBmb3IgdGVzdC11dGlscyB0byBwaWNrIHVwIHByb3BlclxyXG4gKiB0eXBpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcclxuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxyXG4gICAgICAgIDogYXJncykpO1xyXG59O1xyXG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiwgcmVmX2tleSwgcmVmX2ZvciB9KSA9PiB7XHJcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXHJcbiAgICAgICAgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH1cclxuICAgICAgICAgICAgOiByZWZcclxuICAgICAgICA6IG51bGwpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEgLyogRUxFTUVOVCAqLywgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgX192X3NraXA6IHRydWUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXHJcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxyXG4gICAgICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBjb21wb25lbnQ6IG51bGwsXHJcbiAgICAgICAgc3VzcGVuc2U6IG51bGwsXHJcbiAgICAgICAgc3NDb250ZW50OiBudWxsLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IG51bGwsXHJcbiAgICAgICAgZGlyczogbnVsbCxcclxuICAgICAgICB0cmFuc2l0aW9uOiBudWxsLFxyXG4gICAgICAgIGVsOiBudWxsLFxyXG4gICAgICAgIGFuY2hvcjogbnVsbCxcclxuICAgICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiAwLFxyXG4gICAgICAgIHNoYXBlRmxhZyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcclxuICAgICAgICBhcHBDb250ZXh0OiBudWxsXHJcbiAgICB9O1xyXG4gICAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XHJcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIGNvbXBpbGVkIGVsZW1lbnQgdm5vZGUgLSBpZiBjaGlsZHJlbiBpcyBwYXNzZWQsIG9ubHkgcG9zc2libGUgdHlwZXMgYXJlXHJcbiAgICAgICAgLy8gc3RyaW5nIG9yIEFycmF5LlxyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbilcclxuICAgICAgICAgICAgPyA4IC8qIFRFWFRfQ0hJTERSRU4gKi9cclxuICAgICAgICAgICAgOiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIC8vIHZhbGlkYXRlIGtleVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xyXG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcclxuICAgIH1cclxuICAgIC8vIHRyYWNrIHZub2RlIGZvciBibG9jayB0cmVlXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJlxyXG4gICAgICAgIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxyXG4gICAgICAgICFpc0Jsb2NrTm9kZSAmJlxyXG4gICAgICAgIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xyXG4gICAgICAgIGN1cnJlbnRCbG9jayAmJlxyXG4gICAgICAgIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXHJcbiAgICAgICAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXHJcbiAgICAgICAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxyXG4gICAgICAgICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSAmJlxyXG4gICAgICAgIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxyXG4gICAgICAgIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXHJcbiAgICAgICAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5jb25zdCBjcmVhdGVWTm9kZSA9ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgJiBzdHlsZSBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxyXG4gICAgICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcclxuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyByZWFjdGl2ZSBzdGF0ZSBvYmplY3RzIG5lZWQgdG8gYmUgY2xvbmVkIHNpbmNlIHRoZXkgYXJlIGxpa2VseSB0byBiZVxyXG4gICAgICAgICAgICAvLyBtdXRhdGVkXHJcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcclxuICAgIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpXHJcbiAgICAgICAgPyAxIC8qIEVMRU1FTlQgKi9cclxuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcclxuICAgICAgICAgICAgPyAxMjggLyogU1VTUEVOU0UgKi9cclxuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xyXG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXHJcbiAgICAgICAgICAgIGBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgYCArXHJcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcsIGlzQmxvY2tOb2RlLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgSW50ZXJuYWxPYmplY3RLZXkgaW4gcHJvcHNcclxuICAgICAgICA/IGV4dGVuZCh7fSwgcHJvcHMpXHJcbiAgICAgICAgOiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgTk9UIHVzaW5nIHNwcmVhZCBvciBleHRlbmQgdG8gYXZvaWQgdGhlIHJ1bnRpbWVcclxuICAgIC8vIGtleSBlbnVtZXJhdGlvbiBjb3N0LlxyXG4gICAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XHJcbiAgICBjb25zdCBjbG9uZWQgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgX192X3NraXA6IHRydWUsXHJcbiAgICAgICAgdHlwZTogdm5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogbWVyZ2VkUHJvcHMsXHJcbiAgICAgICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxyXG4gICAgICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZlxyXG4gICAgICAgICAgICA/IC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VSZWYgJiYgcmVmXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpc0FycmF5KHJlZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcclxuICAgICAgICAgICAgOiByZWYsXHJcbiAgICAgICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcclxuICAgICAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcclxuICAgICAgICBjaGlsZHJlbjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhdGNoRmxhZyA9PT0gLTEgLyogSE9JU1RFRCAqLyAmJiBpc0FycmF5KGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSlcclxuICAgICAgICAgICAgOiBjaGlsZHJlbixcclxuICAgICAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcclxuICAgICAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXHJcbiAgICAgICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXHJcbiAgICAgICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcclxuICAgICAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxyXG4gICAgICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cclxuICAgICAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXHJcbiAgICAgICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50XHJcbiAgICAgICAgICAgID8gcGF0Y2hGbGFnID09PSAtMSAvLyBob2lzdGVkIG5vZGVcclxuICAgICAgICAgICAgICAgID8gMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICAgICAgOiBwYXRjaEZsYWcgfCAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgIDogcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXHJcbiAgICAgICAgZGlyczogdm5vZGUuZGlycyxcclxuICAgICAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxyXG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxyXG4gICAgICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxyXG4gICAgICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcclxuICAgICAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxyXG4gICAgICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcclxuICAgICAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXHJcbiAgICAgICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxyXG4gICAgICAgIGVsOiB2bm9kZS5lbCxcclxuICAgICAgICBhbmNob3I6IHZub2RlLmFuY2hvclxyXG4gICAgfTtcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzIwMjJcclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XHJcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcclxuICAgIC8vIG9mIGVsZW1lbnRzIGlzIG5lY2Vzc2FyeSBmb3IgaHlkcmF0aW9uLlxyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xyXG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXHJcbi8vIHdoZW4gdXNlZCBhcyB0aGUgdi1lbHNlIGJyYW5jaCwgdGhlIGNvbW1lbnQgbm9kZSBtdXN0IGJlIGNyZWF0ZWQgYXMgYVxyXG4vLyBibG9jayB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzLlxyXG5hc0Jsb2NrID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBhc0Jsb2NrXHJcbiAgICAgICAgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xyXG4gICAgICAgIC8vIGZyYWdtZW50XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKEZyYWdtZW50LCBudWxsLCBcclxuICAgICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcclxuICAgICAgICBjaGlsZC5zbGljZSgpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBhbHJlYWR5IHZub2RlLCB0aGlzIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gc2luY2UgY29tcGlsZWQgdGVtcGxhdGVzXHJcbiAgICAgICAgLy8gYWx3YXlzIHByb2R1Y2UgYWxsLXZub2RlIGNoaWxkcmVuIGFycmF5c1xyXG4gICAgICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xyXG4gICAgfVxyXG59XHJcbi8vIG9wdGltaXplZCBub3JtYWxpemF0aW9uIGZvciB0ZW1wbGF0ZS1jb21waWxlZCByZW5kZXIgZm5zXHJcbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XHJcbiAgICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgdHlwZSA9IDA7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSAvKiBFTEVNRU5UICovIHwgNjQgLyogVEVMRVBPUlQgKi8pKSB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBzbG90IHRvIHBsYWluIGNoaWxkcmVuIGZvciBwbGFpbiBlbGVtZW50IGFuZCBUZWxlcG9ydFxyXG4gICAgICAgICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIF9jIG1hcmtlciBpcyBhZGRlZCBieSB3aXRoQ3R4KCkgaW5kaWNhdGluZyB0aGlzIGlzIGEgY29tcGlsZWQgc2xvdFxyXG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RGbGFnID09PSAzIC8qIEZPUldBUkRFRCAqLyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgY29tcG9uZW50IHJlY2VpdmVzIGZvcndhcmRlZCBzbG90cyBmcm9tIHRoZSBwYXJlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBpdHMgc2xvdCB0eXBlIGlzIGRldGVybWluZWQgYnkgaXRzIHBhcmVudCdzIHNsb3QgdHlwZS5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMSAvKiBTVEFCTEUgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMiAvKiBEWU5BTUlDICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XHJcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFRFWFRfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5jb21pbmcgJiZcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZyAhPT0gaW5jb21pbmcgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNvbWluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcgLyogVk5PREVfSE9PSyAqLywgW1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHByZXZWTm9kZVxyXG4gICAgXSk7XHJcbn1cblxuLyoqXHJcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGNvbnN0IGNhY2hlZCA9IChjYWNoZSAmJiBjYWNoZVtpbmRleF0pO1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICBjYWNoZVtpbmRleF0gPSByZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXHJcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XHJcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxyXG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XHJcbiAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmlzQ0UpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoJ3Nsb3QnLCBuYW1lID09PSAnZGVmYXVsdCcgPyBudWxsIDogeyBuYW1lIH0sIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB3YXJuKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXHJcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcclxuICAgICAgICBzbG90ID0gKCkgPT4gW107XHJcbiAgICB9XHJcbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcclxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXHJcbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxyXG4gICAgLy8gZW5hYmxlIGl0LlxyXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIG9wZW5CbG9jaygpO1xyXG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XHJcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IHx8IGBfJHtuYW1lfWAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovXHJcbiAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICA6IC0yIC8qIEJBSUwgKi8pO1xyXG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xyXG4gICAgICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgJy1zJ107XHJcbiAgICB9XHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyZWQ7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcclxuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XHJcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KVxyXG4gICAgICAgID8gdm5vZGVzXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiAjMjQzNyBJbiBWdWUgMywgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGEgcHVibGljIGluc3RhbmNlIHByb3h5IGJ1dFxyXG4gKiB0aGV5IGV4aXN0IGluIHRoZSBpbnRlcm5hbCBwYXJlbnQgY2hhaW4uIEZvciBjb2RlIHRoYXQgcmVsaWVzIG9uIHRyYXZlcnNpbmdcclxuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxyXG4gKi9cclxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xyXG4gICAgaWYgKCFpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXHJcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XHJcbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xyXG59O1xyXG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHtcclxuICAgICQ6IGkgPT4gaSxcclxuICAgICRlbDogaSA9PiBpLnZub2RlLmVsLFxyXG4gICAgJGRhdGE6IGkgPT4gaS5kYXRhLFxyXG4gICAgJHByb3BzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzKSxcclxuICAgICRhdHRyczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyksXHJcbiAgICAkc2xvdHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMpLFxyXG4gICAgJHJlZnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzKSxcclxuICAgICRwYXJlbnQ6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxyXG4gICAgJHJvb3Q6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcclxuICAgICRlbWl0OiBpID0+IGkuZW1pdCxcclxuICAgICRvcHRpb25zOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUpLFxyXG4gICAgJGZvcmNlVXBkYXRlOiBpID0+ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSxcclxuICAgICRuZXh0VGljazogaSA9PiBuZXh0VGljay5iaW5kKGkucHJveHkpLFxyXG4gICAgJHdhdGNoOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUClcclxufSk7XHJcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcclxuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5ncyBkdXJpbmcgZGV2LlxyXG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIGV2ZW4gcHJvcGVydGllcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkIHRvIGJlIHVzZWQgLSBzbyB0aGF0XHJcbiAgICAgICAgLy8gaXQgYWxpZ25zIHdpdGggdGhlIHByb2R1Y3Rpb24gYmVoYXZpb3Igd2hlcmUgdGhlIHJlbmRlciBmbiBpcyBpbmxpbmVkIGFuZFxyXG4gICAgICAgIC8vIGluZGVlZCBoYXMgYWNjZXNzIHRvIGFsbCBkZWNsYXJlZCB2YXJpYWJsZXMuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiZcclxuICAgICAgICAgICAgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAoIWlzU3RyaW5nKGtleSkgfHxcclxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJlxyXG4gICAgICAgICAgICAgICAgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgaGFzKHsgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfSB9LCBrZXkpIHtcclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NDYWNoZVtrZXldIHx8XHJcbiAgICAgICAgICAgIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHx8XHJcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oY3R4LCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcclxuICAgIH0sXHJcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLmdldCgpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG59O1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xyXG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgd2FybihgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XHJcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgaGFzKF8sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXM7XHJcbiAgICB9XHJcbn0pO1xyXG4vLyBkZXYgb25seVxyXG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2BcclxuLy8gZm9yIGVhc2llciBjb25zb2xlIGluc3BlY3Rpb24uIEluIHByb2QgbW9kZSBpdCB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdCBzb1xyXG4vLyB0aGVzZSBwcm9wZXJ0aWVzIGRlZmluaXRpb25zIGNhbiBiZSBza2lwcGVkLlxyXG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCBpbnN0YW5jZSBmb3IgcHJveHkgaGFuZGxlcnNcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXHJcbiAgICB9KTtcclxuICAgIC8vIGV4cG9zZSBwdWJsaWMgcHJvcGVydGllc1xyXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXHJcbiAgICAgICAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcclxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICAgIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xyXG4gICAgICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG5sZXQgdWlkJDEgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xyXG4gICAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XHJcbiAgICAvLyBpbmhlcml0IHBhcmVudCBhcHAgY29udGV4dCAtIG9yIC0gaWYgcm9vdCwgYWRvcHQgZnJvbSByb290IHZub2RlXHJcbiAgICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XHJcbiAgICAgICAgdWlkOiB1aWQkMSsrLFxyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIGFwcENvbnRleHQsXHJcbiAgICAgICAgcm9vdDogbnVsbCxcclxuICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgIHN1YlRyZWU6IG51bGwsXHJcbiAgICAgICAgZWZmZWN0OiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcclxuICAgICAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pLFxyXG4gICAgICAgIHJlbmRlcjogbnVsbCxcclxuICAgICAgICBwcm94eTogbnVsbCxcclxuICAgICAgICBleHBvc2VkOiBudWxsLFxyXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxyXG4gICAgICAgIHdpdGhQcm94eTogbnVsbCxcclxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcclxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcclxuICAgICAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAgICAgLy8gbG9jYWwgcmVzb3ZsZWQgYXNzZXRzXHJcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcclxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXHJcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgLy8gZW1pdFxyXG4gICAgICAgIGVtaXQ6IG51bGwsXHJcbiAgICAgICAgZW1pdHRlZDogbnVsbCxcclxuICAgICAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxyXG4gICAgICAgIC8vIGluaGVyaXRBdHRyc1xyXG4gICAgICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICBjdHg6IEVNUFRZX09CSixcclxuICAgICAgICBkYXRhOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcclxuICAgICAgICBhdHRyczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNsb3RzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cENvbnRleHQ6IG51bGwsXHJcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcclxuICAgICAgICBhc3luY0RlcDogbnVsbCxcclxuICAgICAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcclxuICAgICAgICAvLyBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJjOiBudWxsLFxyXG4gICAgICAgIGM6IG51bGwsXHJcbiAgICAgICAgYm06IG51bGwsXHJcbiAgICAgICAgbTogbnVsbCxcclxuICAgICAgICBidTogbnVsbCxcclxuICAgICAgICB1OiBudWxsLFxyXG4gICAgICAgIHVtOiBudWxsLFxyXG4gICAgICAgIGJ1bTogbnVsbCxcclxuICAgICAgICBkYTogbnVsbCxcclxuICAgICAgICBhOiBudWxsLFxyXG4gICAgICAgIHJ0ZzogbnVsbCxcclxuICAgICAgICBydGM6IG51bGwsXHJcbiAgICAgICAgZWM6IG51bGwsXHJcbiAgICAgICAgc3A6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLmVtaXQgPSBlbWl0JDEuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgICAvLyBhcHBseSBjdXN0b20gZWxlbWVudCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICBpZiAodm5vZGUuY2UpIHtcclxuICAgICAgICB2bm9kZS5jZShpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xyXG59O1xyXG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG59O1xyXG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcclxuICAgIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xyXG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi87XHJcbn1cclxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XHJcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XHJcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxyXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBgICtcclxuICAgICAgICAgICAgICAgIGBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDAuIGNyZWF0ZSByZW5kZXIgcHJveHkgcHJvcGVydHkgYWNjZXNzIGNhY2hlXHJcbiAgICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAvLyAxLiBjcmVhdGUgcHVibGljIGluc3RhbmNlIC8gcmVuZGVyIHByb3h5XHJcbiAgICAvLyBhbHNvIG1hcmsgaXQgcmF3IHNvIGl0J3MgbmV2ZXIgb2JzZXJ2ZWRcclxuICAgIGluc3RhbmNlLnByb3h5ID0gbWFya1JhdyhuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBjYWxsIHNldHVwKClcclxuICAgIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcclxuICAgIGlmIChzZXR1cCkge1xyXG4gICAgICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IChpbnN0YW5jZS5zZXR1cENvbnRleHQgPVxyXG4gICAgICAgICAgICBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGwpO1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLywgWyhwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGZ1bmN0aW9uJ3MgbmFtZSBpcyBgc3NyUmVuZGVyYCAoY29tcGlsZWQgYnkgU0ZDIGlubGluZSBtb2RlKSxcclxuICAgICAgICAgICAgLy8gc2V0IGl0IGFzIHNzclJlbmRlciBpbnN0ZWFkLlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBgICtcclxuICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYmluZGluZ3MuXHJcbiAgICAgICAgLy8gYXNzdW1pbmcgYSByZW5kZXIgZnVuY3Rpb24gY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXR1cFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XHJcbiAgICB9XHJcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xyXG59XHJcbmxldCBjb21waWxlO1xyXG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcclxuLyoqXHJcbiAqIEZvciBydW50aW1lLWRvbSB0byByZWdpc3RlciB0aGUgY29tcGlsZXIuXHJcbiAqIE5vdGUgdGhlIGV4cG9ydGVkIG1ldGhvZCB1c2VzIGFueSB0byBhdm9pZCBkLnRzIHJlbHlpbmcgb24gdGhlIGNvbXBpbGVyIHR5cGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcclxuICAgIGNvbXBpbGUgPSBfY29tcGlsZTtcclxuICAgIGluc3RhbGxXaXRoUHJveHkgPSBpID0+IHtcclxuICAgICAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XHJcbiAgICAgICAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xyXG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgLy8gdGVtcGxhdGUgLyByZW5kZXIgZnVuY3Rpb24gbm9ybWFsaXphdGlvblxyXG4gICAgLy8gY291bGQgYmUgYWxyZWFkeSBzZXQgd2hlbiByZXR1cm5lZCBmcm9tIHNldHVwKClcclxuICAgIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XHJcbiAgICAgICAgLy8gb25seSBkbyBvbi10aGUtZmx5IGNvbXBpbGUgaWYgbm90IGluIFNTUiAtIFNTUiBvbi10aGUtZmx5IGNvbXBpbGF0aW9uXHJcbiAgICAgICAgLy8gaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyZXJcclxuICAgICAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGU7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyc1xyXG4gICAgICAgICAgICAgICAgfSwgY29tcGlsZXJPcHRpb25zKSwgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSAoQ29tcG9uZW50LnJlbmRlciB8fCBOT09QKTtcclxuICAgICAgICAvLyBmb3IgcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9ja3MsIHRoZSByZW5kZXJcclxuICAgICAgICAvLyBwcm94eSB1c2VkIG5lZWRzIGEgZGlmZmVyZW50IGBoYXNgIGhhbmRsZXIgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50IGFuZFxyXG4gICAgICAgIC8vIGFsc28gb25seSBhbGxvd3MgYSB3aGl0ZWxpc3Qgb2YgZ2xvYmFscyB0byBmYWxsdGhyb3VnaC5cclxuICAgICAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xyXG4gICAgICAgICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdXBwb3J0IGZvciAyLnggb3B0aW9uc1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIShmYWxzZSApKSB7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIH1cclxuICAgIC8vIHdhcm4gbWlzc2luZyB0ZW1wbGF0ZS9yZW5kZXJcclxuICAgIC8vIHRoZSBydW50aW1lIGNvbXBpbGF0aW9uIG9mIHRlbXBsYXRlIGluIFNTUiBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgYCArXHJcbiAgICAgICAgICAgICAgICBgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xyXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxyXG4gICAgICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XHJcbiAgICB9O1xyXG4gICAgbGV0IGF0dHJzO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIC8vIFdlIHVzZSBnZXR0ZXJzIGluIGRldiBpbiBjYXNlIGxpYnMgbGlrZSB0ZXN0LXV0aWxzIG92ZXJ3cml0ZSBpbnN0YW5jZVxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgKG92ZXJ3cml0ZXMgc2hvdWxkIG5vdCBiZSBkb25lIGluIHByb2QpXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnMgfHwgKGF0dHJzID0gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnNsb3RzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnMgfHwgKGF0dHJzID0gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXHJcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIChpbnN0YW5jZS5leHBvc2VQcm94eSB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xyXG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csICcnKTtcclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudClcclxuICAgICAgICA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZVxyXG4gICAgICAgIDogQ29tcG9uZW50Lm5hbWU7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xyXG4gICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgbmFtZSBiYXNlZCBvbiByZXZlcnNlIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG5hbWUgPVxyXG4gICAgICAgICAgICBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XHJcbn1cclxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmICdfX3ZjY09wdHMnIGluIHZhbHVlO1xyXG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XHJcbn0pO1xuXG4vLyBkZXYgb25seVxyXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICBgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYCk7XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXHJcbiAqIGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBpdCBpcyBhY2Nlc3NlZCBieSBhIHBhcmVudCBjb21wb25lbnQgdmlhIHRlbXBsYXRlXHJcbiAqIHJlZnMuXHJcbiAqXHJcbiAqIGA8c2NyaXB0IHNldHVwPmAgY29tcG9uZW50cyBhcmUgY2xvc2VkIGJ5IGRlZmF1bHQgLSBpLmUuIHZhcmlhYmxlcyBpbnNpZGVcclxuICogdGhlIGA8c2NyaXB0IHNldHVwPmAgc2NvcGUgaXMgbm90IGV4cG9zZWQgdG8gcGFyZW50IHVubGVzcyBleHBsaWNpdGx5IGV4cG9zZWRcclxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgPHNjcmlwdCBzZXR1cD5gLCBpcyBjb21waWxlZCBhd2F5IGluIHRoZVxyXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIHByb3ZpZGluZyBwcm9wcyBkZWZhdWx0IHZhbHVlcyB3aGVuXHJcbiAqIHVzaW5nIHR5cGUtYmFzZWQgYGRlZmluZVByb3BzYCBkZWNsYXJhdGlvbi5cclxuICpcclxuICogRXhhbXBsZSB1c2FnZTpcclxuICogYGBgdHNcclxuICogd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPHtcclxuICogICBzaXplPzogbnVtYmVyXHJcbiAqICAgbGFiZWxzPzogc3RyaW5nW11cclxuICogfT4oKSwge1xyXG4gKiAgIHNpemU6IDMsXHJcbiAqICAgbGFiZWxzOiAoKSA9PiBbJ2RlZmF1bHQgbGFiZWwnXVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGUgb3V0cHV0XHJcbiAqIGFuZCBzaG91bGQgKipub3QqKiBiZSBhY3R1YWxseSBjYWxsZWQgYXQgcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcclxufVxyXG5mdW5jdGlvbiB1c2VBdHRycygpIHtcclxuICAgIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcclxuICAgICAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXHJcbiAqIG9ubHkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGlzQXJyYXkocmF3KVxyXG4gICAgICAgID8gcmF3LnJlZHVjZSgobm9ybWFsaXplZCwgcCkgPT4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKSwge30pXHJcbiAgICAgICAgOiByYXc7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xyXG4gICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XHJcbiAgICAgICAgaWYgKG9wdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIHByb3h5IGZvciB0aGUgcmVzdCBlbGVtZW50IHdoZW4gZGVzdHJ1Y3R1cmluZyBwcm9wcyB3aXRoXHJcbiAqIGRlZmluZVByb3BzKCkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuLyoqXHJcbiAqIGA8c2NyaXB0IHNldHVwPmAgaGVscGVyIGZvciBwZXJzaXN0aW5nIHRoZSBjdXJyZW50IGluc3RhbmNlIGNvbnRleHQgb3ZlclxyXG4gKiBhc3luYy9hd2FpdCBmbG93cy5cclxuICpcclxuICogYEB2dWUvY29tcGlsZXItc2ZjYCBjb252ZXJ0cyB0aGUgZm9sbG93aW5nOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCB4ID0gYXdhaXQgZm9vKClcclxuICogYGBgXHJcbiAqXHJcbiAqIGludG86XHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGxldCBfX3RlbXAsIF9fcmVzdG9yZVxyXG4gKiBjb25zdCB4ID0gKChbX190ZW1wLCBfX3Jlc3RvcmVdID0gd2l0aEFzeW5jQ29udGV4dCgoKSA9PiBmb28oKSkpLF9fdGVtcD1hd2FpdCBfX3RlbXAsX19yZXN0b3JlKCksX190ZW1wKVxyXG4gKiBgYGBcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoQXN5bmNDb250ZXh0KGdldEF3YWl0YWJsZSkge1xyXG4gICAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjdHgpIHtcclxuICAgICAgICB3YXJuKGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBgICtcclxuICAgICAgICAgICAgYFRoaXMgaXMgbGlrZWx5IGEgYnVnLmApO1xyXG4gICAgfVxyXG4gICAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xyXG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xyXG4gICAgICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xyXG59XG5cbi8vIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgaWYgKGwgPT09IDIpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2bm9kZSB3aXRob3V0IHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHMgd2l0aG91dCBjaGlsZHJlblxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGwgPiAzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzc3JDb250ZXh0YCA6IGBgKTtcclxuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcclxuICAgIHtcclxuICAgICAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgd2FybihgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBgICtcclxuICAgICAgICAgICAgICAgIGB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3R4O1xyXG4gICAgfVxyXG59O1xuXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIiAvKiBJU19TSEFMTE9XICovXSk7XHJcbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojM2JhNzc2JyB9O1xyXG4gICAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzBiMWJjOScgfTtcclxuICAgIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogJ2NvbG9yOiNiNjJlMjQnIH07XHJcbiAgICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzlkMjg4YycgfTtcclxuICAgIC8vIGN1c3RvbSBmb3JtYXR0ZXIgZm9yIENocm9tZVxyXG4gICAgLy8gaHR0cHM6Ly93d3cubWF0dHpldW5lcnQuY29tLzIwMTYvMDIvMTkvY3VzdG9tLWNocm9tZS1kZXZ0b29scy1vYmplY3QtZm9ybWF0dGVycy5odG1sXHJcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB7XHJcbiAgICAgICAgaGVhZGVyKG9iaikge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGFsc28gZm9ybWF0IENvbXBvbmVudFB1YmxpY0luc3RhbmNlICYgY3R4LnNsb3RzL2F0dHJzIGluIHNldHVwXHJcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICBgPmBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/ICdTaGFsbG93UmVhY3RpdmUnIDogJ1JlYWN0aXZlJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWRvbmx5JyA6ICdSZWFkb25seSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgICc+J1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0JvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5KG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdjb21wdXRlZCcpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdjb21wdXRlZCcsIGNvbXB1dGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcclxuICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnaW5qZWN0ZWQnLCBpbmplY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibG9ja3MucHVzaChbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyAnO29wYWNpdHk6MC42NidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsnb2JqZWN0JywgeyBvYmplY3Q6IGluc3RhbmNlIH1dXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjb2xvcjojNDc2NTgyJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcclxuICAgICAgICBpZiAoKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpKSB8fFxyXG4gICAgICAgICAgICAoaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUobSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcclxuICAgICAgICBpZiAoaXNTaGFsbG93KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2LmVmZmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBSZWZgO1xyXG4gICAgfVxyXG4gICAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xyXG4gICAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XHJcbiAgICAvLyBzaGFsbG93IGNsb25lXHJcbiAgICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcclxuICAgIHJldHVybiAoY2FjaGVbaW5kZXhdID0gcmV0KTtcclxufVxyXG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xyXG4gICAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xyXG4gICAgaWYgKHByZXYubGVuZ3RoICE9IG1lbW8ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHByZXZbaV0gIT09IG1lbW9baV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1ha2Ugc3VyZSB0byBsZXQgcGFyZW50IGJsb2NrIHRyYWNrIGl0IHdoZW4gcmV0dXJuaW5nIGNhY2hlZFxyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjIuMzFcIjtcclxuY29uc3QgX3NzclV0aWxzID0ge1xyXG4gICAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXHJcbiAgICBzZXR1cENvbXBvbmVudCxcclxuICAgIHJlbmRlckNvbXBvbmVudFJvb3QsXHJcbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXHJcbiAgICBpc1ZOb2RlLFxyXG4gICAgbm9ybWFsaXplVk5vZGVcclxufTtcclxuLyoqXHJcbiAqIFNTUiB1dGlscyBmb3IgXFxAdnVlL3NlcnZlci1yZW5kZXJlci4gT25seSBleHBvc2VkIGluIGNqcyBidWlsZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgc3NyVXRpbHMgPSAoX3NzclV0aWxzICk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHNcclxuICovXHJcbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xyXG4vKipcclxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzLlxyXG4gKi9cclxuY29uc3QgY29tcGF0VXRpbHMgPSAobnVsbCk7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lUHJvcHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCJpbXBvcnQgeyBjYW1lbGl6ZSwgd2FybiwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIGNyZWF0ZVZOb2RlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHdhdGNoUG9zdEVmZmVjdCwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgaCwgQmFzZVRyYW5zaXRpb24sIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIGNyZWF0ZVJlbmRlcmVyLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNGdW5jdGlvbiwgdG9OdW1iZXIsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIGV4dGVuZCwgRU1QVFlfT0JKLCBpc09iamVjdCwgaW52b2tlQXJyYXlGbnMsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGlzSFRNTFRhZywgaXNTVkdUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuY29uc3QgZG9jID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xyXG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcclxuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXHJcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAvLyAjMzA3MlxyXG4gICAgICAgIC8vIC0gaW4gYHBhdGNoRE9NUHJvcGAsIHdlIHN0b3JlIHRoZSBhY3R1YWwgdmFsdWUgaW4gdGhlIGBlbC5fdmFsdWVgIHByb3BlcnR5LlxyXG4gICAgICAgIC8vIC0gbm9ybWFsbHksIGVsZW1lbnRzIHVzaW5nIGA6dmFsdWVgIGJpbmRpbmdzIHdpbGwgbm90IGJlIGhvaXN0ZWQsIGJ1dCBpZlxyXG4gICAgICAgIC8vICAgdGhlIGJvdW5kIHZhbHVlIGlzIGEgY29uc3RhbnQsIGUuZy4gYDp2YWx1ZT1cInRydWVcImAgLSB0aGV5IGRvIGdldFxyXG4gICAgICAgIC8vICAgaG9pc3RlZC5cclxuICAgICAgICAvLyAtIGluIHByb2R1Y3Rpb24sIGhvaXN0ZWQgbm9kZXMgYXJlIGNsb25lZCB3aGVuIHN1YnNlcXVlbnQgaW5zZXJ0cywgYnV0XHJcbiAgICAgICAgLy8gICBjbG9uZU5vZGUoKSBkb2VzIG5vdCBjb3B5IHRoZSBjdXN0b20gcHJvcGVydHkgd2UgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gLSBUaGlzIG1heSBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIGN1c3RvbSBET00gcHJvcGVydGllcyB3ZSBhdHRhY2ggdG9cclxuICAgICAgICAvLyAgIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIGBfdmFsdWVgIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgaWYgKGBfdmFsdWVgIGluIGVsKSB7XHJcbiAgICAgICAgICAgIGNsb25lZC5fdmFsdWUgPSBlbC5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyA8cGFyZW50PiBiZWZvcmUgfCBmaXJzdCAuLi4gbGFzdCB8IGFuY2hvciA8L3BhcmVudD5cclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcclxuICAgICAgICAvLyAjNTMwOCBjYW4gb25seSB0YWtlIGNhY2hlZCBwYXRoIGlmOlxyXG4gICAgICAgIC8vIC0gaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxyXG4gICAgICAgIC8vIC0gbmV4dFNpYmxpbmcgaW5mbyBpcyBzdGlsbCBhdmFpbGFibGVcclxuICAgICAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIGNhY2hlZFxyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmVzaCBpbnNlcnRcclxuICAgICAgICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gaXNTVkcgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcclxuICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3V0ZXIgc3ZnIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBmaXJzdFxyXG4gICAgICAgICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcclxuICAgICAgICAgICAgLy8gbGFzdFxyXG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXHJcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xyXG4gICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXHJcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcclxuICAgIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAoaXNDc3NTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXYpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWBcclxuICAgICAgICAvLyB2YWx1ZSwgdGh1cyBoYW5kaW5nIG92ZXIgY29udHJvbCB0byBgdi1zaG93YC5cclxuICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIHZhbC5mb3JFYWNoKHYgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJy0tJykpIHtcclxuICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnR5IGRlZmluaXRpb25cclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIC8vICFpbXBvcnRhbnRcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShwcmVmaXhlZCksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xyXG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcclxuICAgIGlmIChuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWUpO1xyXG4gICAgfVxyXG4gICAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XHJcbiAgICAgICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhd05hbWU7XHJcbn1cblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcclxuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcclxuICAgIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aCgneGxpbms6JykpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm90ZSB3ZSBhcmUgb25seSBjaGVja2luZyBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCBkb24ndCBoYXZlIGFcclxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRvbSBwcm9wIG9mIHRoZSBzYW1lIG5hbWUgaGVyZS5cclxuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIF9fVU5TQUZFX19cclxuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxyXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIFxyXG4vLyB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCBvbmx5IGR1ZSB0byBwb3RlbnRpYWwgaW5uZXJIVE1ML3RleHRDb250ZW50XHJcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XHJcbi8vIHVubW91bnRlZC5cclxucHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcclxuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmXHJcbiAgICAgICAgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJyAmJlxyXG4gICAgICAgIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XHJcbiAgICAgICAgIWVsLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUgfHxcclxuICAgICAgICAgICAgLy8gIzQ5NTY6IGFsd2F5cyBzZXQgZm9yIE9QVElPTiBlbGVtZW50cyBiZWNhdXNlIGl0cyB2YWx1ZSBmYWxscyBiYWNrIHRvXHJcbiAgICAgICAgICAgIC8vIHRleHRDb250ZW50IGlmIG5vIHZhbHVlIGF0dHJpYnV0ZSBpcyBwcmVzZW50LiBBbmQgc2V0dGluZyAudmFsdWUgZm9yXHJcbiAgICAgICAgICAgIC8vIE9QVElPTiBoYXMgbm8gc2lkZSBlZmZlY3RcclxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ09QVElPTicpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxyXG4gICAgICAgICAgICBlbFtrZXldID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGRpdiA6aWQ9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAnJztcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8aW1nIDp3aWR0aD1cIm51bGxcIj5cclxuICAgICAgICAgICAgLy8gdGhlIHZhbHVlIG9mIHNvbWUgSURMIGF0dHIgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCwgZS5nLiBpbnB1dC5zaXplID0gMCAtPiBlcnJvclxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZWxba2V5XSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgcGVyZm9ybSB2YWx1ZSB2YWxpZGF0aW9uIGFuZCB0aHJvd1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBlbFtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxyXG5sZXQgX2dldE5vdyA9IERhdGUubm93O1xyXG5sZXQgc2tpcFRpbWVzdGFtcENoZWNrID0gZmFsc2U7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuICAgIC8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXHJcbiAgICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcclxuICAgIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuICAgIGlmIChfZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcclxuICAgICAgICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxyXG4gICAgICAgIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXHJcbiAgICAgICAgX2dldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG4gICAgLy8gIzM0ODU6IEZpcmVmb3ggPD0gNTMgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25cclxuICAgIC8vIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc28gc2FmZSB0byBleGNsdWRlLlxyXG4gICAgY29uc3QgZmZNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XHJcbiAgICBza2lwVGltZXN0YW1wQ2hlY2sgPSAhIShmZk1hdGNoICYmIE51bWJlcihmZk1hdGNoWzFdKSA8PSA1Myk7XHJcbn1cclxuLy8gVG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mIHJlcGVhdGVkbHkgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSwgd2UgY2FjaGVcclxuLy8gYW5kIHVzZSB0aGUgc2FtZSB0aW1lc3RhbXAgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgaW4gdGhlIHNhbWUgdGljay5cclxubGV0IGNhY2hlZE5vdyA9IDA7XHJcbmNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICBjYWNoZWROb3cgPSAwO1xyXG59O1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbihyZXNldCksIChjYWNoZWROb3cgPSBfZ2V0Tm93KCkpKTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcclxuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xyXG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAvLyBwYXRjaFxyXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcclxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIGxldCBvcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpLCBvcHRpb25zXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcclxuICAgICAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IF9nZXROb3coKTtcclxuICAgICAgICBpZiAoc2tpcFRpbWVzdGFtcENoZWNrIHx8IHRpbWVTdGFtcCA+PSBpbnZva2VyLmF0dGFjaGVkIC0gMSkge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi8sIFtlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XHJcbiAgICByZXR1cm4gaW52b2tlcjtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xyXG4gICAgICAgICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZm4gPT4gKGUpID0+ICFlLl9zdG9wcGVkICYmIGZuICYmIGZuKGUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleVswXSA9PT0gJy4nXHJcbiAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIHRydWUpXHJcbiAgICAgICAgOiBrZXlbMF0gPT09ICdeJ1xyXG4gICAgICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgZmFsc2UpXHJcbiAgICAgICAgICAgIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxyXG4gICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgIC8vIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xyXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUwgJiB0ZXh0Q29udGVudFxyXG4gICAgICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcclxuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBzcGVsbGNoZWNrIGFuZCBkcmFnZ2FibGUgYXJlIG51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpclxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllcyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvXHJcbiAgICAvLyBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0b1xyXG4gICAgLy8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdCB0aGVtIGFzIGF0dHJpYnV0ZXMuXHJcbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXHJcbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXHJcbiAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgaW4gZWw7XHJcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRhdGUpIHtcclxuICAgIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucyk7XHJcbiAgICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgaHlkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XHJcbiAgICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcclxufVxyXG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKChvcHRpb25zKSA9PiB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKTtcclxufSk7XHJcbmNvbnN0IEJhc2VDbGFzcyA9ICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XHJcbn0pO1xyXG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBoeWRyYXRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kZWYgPSBfZGVmO1xyXG4gICAgICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgaHlkcmF0ZSh0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcclxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXHJcbiAgICAgKi9cclxuICAgIF9yZXNvbHZlRGVmKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBhdHRyc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YXRjaCBmdXR1cmUgYXR0ciBjaGFuZ2VzXHJcbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChkZWYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc09wdGlvbnMgPSAhaXNBcnJheShwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd0tleXMgPSBwcm9wcyA/IChoYXNPcHRpb25zID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHMpIDogW107XHJcbiAgICAgICAgICAgIC8vIGNhc3QgTnVtYmVyLXR5cGUgcHJvcHMgc2V0IGJlZm9yZSByZXNvbHZlXHJcbiAgICAgICAgICAgIGxldCBudW1iZXJQcm9wcztcclxuICAgICAgICAgICAgaWYgKGhhc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX3Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgKG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBwcm9wcyBzZXQgcHJlLXVwZ3JhZGUgb3IgY29ubmVjdFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGRlZmluaW5nIGdldHRlci9zZXR0ZXJzIG9uIHByb3RvdHlwZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByYXdLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldCh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXBwbHkgQ1NTXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcclxuICAgICAgICBpZiAoYXN5bmNEZWYpIHtcclxuICAgICAgICAgICAgYXN5bmNEZWYoKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRBdHRyKGtleSkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2tleV0pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldFByb3AoY2FtZWxpemUkMShrZXkpLCB2YWx1ZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2dldFByb3Aoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlZmxlY3RcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGUoKSB7XHJcbiAgICAgICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVk5vZGUoKSB7XHJcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZCh7fSwgdGhpcy5fcHJvcHMpKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmNlID0gaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gSE1SXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSBuZXdTdHlsZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgcmVzZXQgc3R5bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKHMgPT4gdGhpcy5zaGFkb3dSb290LnJlbW92ZUNoaWxkKHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gYXN5bmMgY29tcG9uZW50LCBjZVJlbG9hZCBpcyBjYWxsZWQgZnJvbSB0aGUgaW5uZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHNvIG5vIG5lZWQgdG8gcmVsb2FkIHRoZSBhc3luYyB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJjZXB0IGVtaXRcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGUgbmVhcmVzdCBWdWUgY3VzdG9tIGVsZW1lbnQgcGFyZW50IGZvciBwcm92aWRlL2luamVjdFxyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhcmVudCA9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBfYXBwbHlTdHlsZXMoc3R5bGVzKSB7XHJcbiAgICAgICAgaWYgKHN0eWxlcykge1xyXG4gICAgICAgICAgICBzdHlsZXMuZm9yRWFjaChjc3MgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICBzLnRleHRDb250ZW50ID0gY3NzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVjb3JkIGZvciBITVJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9ICckc3R5bGUnKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcclxuICAgICAgICBpZiAoIW1vZHVsZXMpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcclxuICAgICAgICBpZiAoIW1vZCkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgU0ZDJ3MgQ1NTIHZhcmlhYmxlIGluamVjdGlvbiBmZWF0dXJlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXRWYXJzID0gKCkgPT4gc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgZ2V0dGVyKGluc3RhbmNlLnByb3h5KSk7XHJcbiAgICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XHJcbiAgICAgICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xyXG4gICAgICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XHJcbiAgICAgICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XHJcbiAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBkcmlsbCBkb3duIEhPQ3MgdW50aWwgaXQncyBhIG5vbi1jb21wb25lbnQgdm5vZGVcclxuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiB2bm9kZS5lbCkge1xyXG4gICAgICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGVsKSB7XHJcbiAgICAgICAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xyXG4gICAgICAgICAgICBpZiAoZWwgPT09IGFuY2hvcilcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XHJcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XHJcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcclxuLy8gYmFzZSBUcmFuc2l0aW9uIGNvbXBvbmVudCwgd2l0aCBET00tc3BlY2lmaWMgbG9naWMuXHJcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcclxuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcclxuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGNzczoge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXHJcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcclxufTtcclxuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IChUcmFuc2l0aW9uLnByb3BzID1cclxuICAgIC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG4vKipcclxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cclxuICogd2l0aCBjdXN0b20gSE9Dcy5cclxuICovXHJcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICBob29rLmZvckVhY2goaCA9PiBoKC4uLmFyZ3MpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICBob29rKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBob29rIGV4cGVjdHMgYSBjYWxsYmFjayAoMm5kIGFyZyksIHdoaWNoIG1lYW5zIHRoZSB1c2VyXHJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcclxuICAgIHJldHVybiBob29rXHJcbiAgICAgICAgPyBpc0FycmF5KGhvb2spXHJcbiAgICAgICAgICAgID8gaG9vay5zb21lKGggPT4gaC5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICA6IGhvb2subGVuZ3RoID4gMVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xyXG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xyXG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcclxuICAgICAgICBlbC5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcclxuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgaWYgKGVsLl92dGMpIHtcclxuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGUpO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XHJcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcclxufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCBmbiA9IHZub2RlLnByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ107XHJcbiAgICByZXR1cm4gaXNBcnJheShmbikgPyB2YWx1ZSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XHJcbn07XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xyXG4gICAgICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgJ2lucHV0Jyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcihlbCwgdHlwZSkge1xyXG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcclxuICAgIGVsLmRpc3BhdGNoRXZlbnQoZSk7XHJcbn1cclxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXHJcbi8vIGJlIHRyZWUtc2hha2VuIGluIGNhc2Ugdi1tb2RlbCBpcyBuZXZlciB1c2VkLlxyXG5jb25zdCB2TW9kZWxUZXh0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8ICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSAnbnVtYmVyJyk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FzdFRvTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IHRvTnVtYmVyKGRvbVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxhenkpIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICAvLyBhdm9pZCBjbGVhcmluZyB1bnJlc29sdmVkIHRleHQuICMyMzAyXHJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAobGF6eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICAgIGRlZXA6IHRydWUsXHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxyXG4gICAgZGVlcDogdHJ1ZSxcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBsZXQgbW9kZWxUb1VzZTtcclxuICAgIHN3aXRjaCAoZWwudGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cclxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxyXG4vLyBmdW5jdGlvbiBpbiBTU1JcclxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcclxuICAgIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcclxuICAgIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcclxuICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddO1xyXG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcclxuICAgIHN0b3A6IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcclxuICAgIHByZXZlbnQ6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4gICAgc2VsZjogZSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxyXG4gICAgY3RybDogZSA9PiAhZS5jdHJsS2V5LFxyXG4gICAgc2hpZnQ6IGUgPT4gIWUuc2hpZnRLZXksXHJcbiAgICBhbHQ6IGUgPT4gIWUuYWx0S2V5LFxyXG4gICAgbWV0YTogZSA9PiAhZS5tZXRhS2V5LFxyXG4gICAgbGVmdDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxyXG4gICAgbWlkZGxlOiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDEsXHJcbiAgICByaWdodDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxyXG4gICAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKG0gPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xyXG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBLZXB0IGZvciAyLnggY29tcGF0LlxyXG4vLyBOb3RlOiBJRTExIGNvbXBhdCBmb3IgYHNwYWNlYmFyYCBhbmQgYGRlbGAgaXMgcmVtb3ZlZCBmb3Igbm93LlxyXG5jb25zdCBrZXlOYW1lcyA9IHtcclxuICAgIGVzYzogJ2VzY2FwZScsXHJcbiAgICBzcGFjZTogJyAnLFxyXG4gICAgdXA6ICdhcnJvdy11cCcsXHJcbiAgICBsZWZ0OiAnYXJyb3ctbGVmdCcsXHJcbiAgICByaWdodDogJ2Fycm93LXJpZ2h0JyxcclxuICAgIGRvd246ICdhcnJvdy1kb3duJyxcclxuICAgIGRlbGV0ZTogJ2JhY2tzcGFjZSdcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCEoJ2tleScgaW4gZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcclxuICAgICAgICBpZiAobW9kaWZpZXJzLnNvbWUoayA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdlNob3cgPSB7XHJcbiAgICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XHJcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogJ25vbmUnO1xyXG59XHJcbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcclxuLy8gZnVuY3Rpb24gaW4gU1NSXHJcbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcclxuICAgIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcclxuLy8gbGF6eSBjcmVhdGUgdGhlIHJlbmRlcmVyIC0gdGhpcyBtYWtlcyBjb3JlIHJlbmRlcmVyIGxvZ2ljIHRyZWUtc2hha2FibGVcclxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXHJcbmxldCByZW5kZXJlcjtcclxubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gKHJlbmRlcmVyIHx8XHJcbiAgICAgICAgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xyXG4gICAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uXHJcbiAgICAgICAgPyByZW5kZXJlclxyXG4gICAgICAgIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcclxuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xyXG59XHJcbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcclxuY29uc3QgcmVuZGVyID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIF9fVU5TQUZFX19cclxuICAgICAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzXHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cclxuICAgICAgICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2xlYXIgY29udGVudCBiZWZvcmUgbW91bnRpbmdcclxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1hcHAnLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm94eTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gYXBwO1xyXG59KTtcclxuY29uc3QgY3JlYXRlU1NSQXBwID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gYXBwO1xyXG59KTtcclxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XHJcbiAgICAvLyBJbmplY3QgYGlzTmF0aXZlVGFnYFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciBjb21wb25lbnQgbmFtZSB2YWxpZGF0aW9uIChkZXYgb25seSlcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNOYXRpdmVUYWcnLCB7XHJcbiAgICAgICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcclxuICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzQ3VzdG9tRWxlbWVudCcsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGAgK1xyXG4gICAgICAgICAgICBgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gYCArXHJcbiAgICAgICAgICAgIGBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBgICtcclxuICAgICAgICAgICAgYG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1kb21gO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnY29tcGlsZXJPcHRpb25zJywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyZXMpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICB3aW5kb3cuU2hhZG93Um9vdCAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxyXG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcclxuICAgICAgICAgICAgaW5pdFZTaG93Rm9yU1NSKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsIi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXHJcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXHJcbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXHJcbiAqL1xyXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcclxuICAgIFsxIC8qIFRFWFQgKi9dOiBgVEVYVGAsXHJcbiAgICBbMiAvKiBDTEFTUyAqL106IGBDTEFTU2AsXHJcbiAgICBbNCAvKiBTVFlMRSAqL106IGBTVFlMRWAsXHJcbiAgICBbOCAvKiBQUk9QUyAqL106IGBQUk9QU2AsXHJcbiAgICBbMTYgLyogRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcclxuICAgIFszMiAvKiBIWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXHJcbiAgICBbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXHJcbiAgICBbMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFsyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFs1MTIgLyogTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcclxuICAgIFsxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXHJcbiAgICBbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXHJcbiAgICBbLTEgLyogSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcclxuICAgIFstMiAvKiBCQUlMICovXTogYEJBSUxgXHJcbn07XG5cbi8qKlxyXG4gKiBEZXYgb25seVxyXG4gKi9cclxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcclxuICAgIFsxIC8qIFNUQUJMRSAqL106ICdTVEFCTEUnLFxyXG4gICAgWzIgLyogRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcclxuICAgIFszIC8qIEZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXHJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXHJcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcclxuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XHJcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxyXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcclxuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XHJcbiAgICAvLyBjb21wYXJpc29uXHJcbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xyXG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXHJcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xyXG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY291bnQgKz1cclxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG59XG5cbi8qKlxyXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxyXG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XHJcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxyXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cclxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxyXG4gKiAtIGlzbWFwIC0+IGlzTWFwXHJcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcclxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcclxuICogLSByZWFkb25seSAtPiByZWFkT25seVxyXG4gKi9cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcclxuLyoqXHJcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cclxuICovXHJcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXHJcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcclxuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xyXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcclxuLyoqXHJcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cclxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxyXG4gKi9cclxuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XHJcbn1cclxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xyXG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XHJcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcclxuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcclxuICAgIGlmIChpc1Vuc2FmZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcclxufVxyXG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcclxuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXHJcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXHJcbiAgICBodG1sRm9yOiAnZm9yJyxcclxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXHJcbn07XHJcbi8qKlxyXG4gKiBDU1MgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBwbGFpbiBudW1iZXJzXHJcbiAqL1xyXG5jb25zdCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsYm9yZGVyLWltYWdlLW91dHNldCxib3JkZXItaW1hZ2Utc2xpY2UsYCArXHJcbiAgICBgYm9yZGVyLWltYWdlLXdpZHRoLGJveC1mbGV4LGJveC1mbGV4LWdyb3VwLGJveC1vcmRpbmFsLWdyb3VwLGNvbHVtbi1jb3VudCxgICtcclxuICAgIGBjb2x1bW5zLGZsZXgsZmxleC1ncm93LGZsZXgtcG9zaXRpdmUsZmxleC1zaHJpbmssZmxleC1uZWdhdGl2ZSxmbGV4LW9yZGVyLGAgK1xyXG4gICAgYGdyaWQtcm93LGdyaWQtcm93LWVuZCxncmlkLXJvdy1zcGFuLGdyaWQtcm93LXN0YXJ0LGdyaWQtY29sdW1uLGAgK1xyXG4gICAgYGdyaWQtY29sdW1uLWVuZCxncmlkLWNvbHVtbi1zcGFuLGdyaWQtY29sdW1uLXN0YXJ0LGZvbnQtd2VpZ2h0LGxpbmUtY2xhbXAsYCArXHJcbiAgICBgbGluZS1oZWlnaHQsb3BhY2l0eSxvcmRlcixvcnBoYW5zLHRhYi1zaXplLHdpZG93cyx6LWluZGV4LHpvb20sYCArXHJcbiAgICAvLyBTVkdcclxuICAgIGBmaWxsLW9wYWNpdHksZmxvb2Qtb3BhY2l0eSxzdG9wLW9wYWNpdHksc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGhgKTtcclxuLyoqXHJcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXHJcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXHJcbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcclxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXHJcbiAqL1xyXG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlXHJcbiAqL1xyXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxgICtcclxuICAgIGBhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxgICtcclxuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcclxuICAgIGBjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGAgK1xyXG4gICAgYGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxgICtcclxuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXHJcbiAgICBgZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsYCArXHJcbiAgICBgZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxgICtcclxuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xyXG4gICAgYGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGAgK1xyXG4gICAgYGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGAgK1xyXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXHJcbiAgICBgZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGAgK1xyXG4gICAgYGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsYCArXHJcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcclxuICAgIGBsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxgICtcclxuICAgIGBtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxgICtcclxuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xyXG4gICAgYG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLGAgK1xyXG4gICAgYG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLGAgK1xyXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xyXG4gICAgYHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLGAgK1xyXG4gICAgYHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxgICtcclxuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcclxuICAgIGByZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxgICtcclxuICAgIGBzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LGAgK1xyXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcclxuICAgIGBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2UsYCArXHJcbiAgICBgc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcclxuICAgIGBzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLGAgK1xyXG4gICAgYHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLGAgK1xyXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXHJcbiAgICBgdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLGAgK1xyXG4gICAgYHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LGAgK1xyXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcclxuICAgIGB3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSxgICtcclxuICAgIGB4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLGAgK1xyXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcclxuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XHJcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XHJcbiAgICBsZXQgcmV0ID0gJyc7XHJcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcclxuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXHJcbiAgICAnZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsJyArXHJcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcclxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XHJcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcclxufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcclxuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xyXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcclxufVxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcclxuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcclxufVxuXG4vKipcclxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxyXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xyXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcclxuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xyXG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XHJcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XHJcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcclxuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgRGF0ZTtcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXHJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcclxuICAgIGtleSAhPT0gJ05hTicgJiZcclxuICAgIGtleVswXSAhPT0gJy0nICYmXHJcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXHJcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xyXG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxyXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsJyk7XG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xudmFyIHBhcnNlUHJvdG9jb2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIHZhciBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSAmJiB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0LCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCAoY2FuY2VsICYmIGNhbmNlbC50eXBlKSA/IG5ldyBDYW5jZWxlZEVycm9yKCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woZnVsbFBhdGgpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIFsgJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScgXS5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxlZEVycm9yJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5heGlvcy5WRVJTSU9OID0gcmVxdWlyZSgnLi9lbnYvZGF0YScpLnZlcnNpb247XG5heGlvcy50b0Zvcm1EYXRhID0gcmVxdWlyZSgnLi9oZWxwZXJzL3RvRm9ybURhdGEnKTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9saWIvY29yZS9BeGlvc0Vycm9yJyk7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsZWRFcnJvciA9IHJlcXVpcmUoJy4vQ2FuY2VsZWRFcnJvcicpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG5cbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbCA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgIH1cbiAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4gPSBmdW5jdGlvbihvbmZ1bGZpbGxlZCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4vYnVpbGRGdWxsUGF0aCcpO1xudmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdmFsaWRhdG9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQXhpb3NFcnJvcihtZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG5cbnZhciBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbnZhciBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbl0uZm9yRWFjaChmdW5jdGlvbihjb2RlKSB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSBmdW5jdGlvbihlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpIHtcbiAgdmFyIGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3NFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lcmdlTWFwID0ge1xuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdtZXRob2QnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdkYXRhJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlcXVlc3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXNwb25zZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dE1lc3NhZ2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdhZGFwdGVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VUeXBlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmSGVhZGVyTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uVXBsb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdkZWNvbXByZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Q29udGVudExlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdiZWZvcmVSZWRpcmVjdCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zcG9ydCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBzQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdjYW5jZWxUb2tlbic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3NvY2tldFBhdGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZUVuY29kaW5nJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndmFsaWRhdGVTdGF0dXMnOiBtZXJnZURpcmVjdEtleXNcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgdmFyIG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICB2YXIgY29uZmlnVmFsdWUgPSBtZXJnZShwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vQXhpb3NFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uYWwnKTtcbnZhciB0b0Zvcm1EYXRhID0gcmVxdWlyZSgnLi4vaGVscGVycy90b0Zvcm1EYXRhJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDogdHJhbnNpdGlvbmFsRGVmYXVsdHMsXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuICAgIHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICB2YXIgaXNGaWxlTGlzdDtcblxuICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzLmlzRmlsZUxpc3QoZGF0YSkpIHx8IChpc09iamVjdFBheWxvYWQgJiYgY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykpIHtcbiAgICAgIHZhciBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcbiAgICAgIHJldHVybiB0b0Zvcm1EYXRhKGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCkpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcmVxdWlyZSgnLi9lbnYvRm9ybURhdGEnKVxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcInZlcnNpb25cIjogXCIwLjI3LjJcIlxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxubW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICB2YXIgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IEZvcm1EYXRhKCk7XG5cbiAgdmFyIHN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkKGRhdGEsIHBhcmVudEtleSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGRhdGEpIHx8IHV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKGRhdGEpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXJlbnRLZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKGRhdGEpO1xuXG4gICAgICB1dGlscy5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uIGVhY2godmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHZhciBmdWxsS2V5ID0gcGFyZW50S2V5ID8gcGFyZW50S2V5ICsgJy4nICsga2V5IDoga2V5O1xuICAgICAgICB2YXIgYXJyO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhcGFyZW50S2V5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICF1dGlscy5pc1VuZGVmaW5lZChlbCkgJiYgZm9ybURhdGEuYXBwZW5kKGZ1bGxLZXksIGNvbnZlcnRWYWx1ZShlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGQodmFsdWUsIGZ1bGxLZXkpO1xuICAgICAgfSk7XG5cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQocGFyZW50S2V5LCBjb252ZXJ0VmFsdWUoZGF0YSkpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vZW52L2RhdGEnKS52ZXJzaW9uO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yIC0gc2V0IHRvIGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uYWwgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgdmFyIG9wdCA9IGtleXNbaV07XG4gICAgdmFyIHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbnZhciBraW5kT2YgPSAoZnVuY3Rpb24oY2FjaGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5mdW5jdGlvbiBraW5kT2ZUZXN0KHR5cGUpIHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzS2luZE9mKHRoaW5nKSB7XG4gICAgcmV0dXJuIGtpbmRPZih0aGluZykgPT09IHR5cGU7XG4gIH07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRmlsZSA9IGtpbmRPZlRlc3QoJ0ZpbGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh0aGluZykge1xuICB2YXIgcGF0dGVybiA9ICdbb2JqZWN0IEZvcm1EYXRhXSc7XG4gIHJldHVybiB0aGluZyAmJiAoXG4gICAgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGluZyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB8fFxuICAgIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSBwYXR0ZXJuIHx8XG4gICAgKGlzRnVuY3Rpb24odGhpbmcudG9TdHJpbmcpICYmIHRoaW5nLnRvU3RyaW5nKCkgPT09IHBhdHRlcm4pXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICovXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZGVzY3JpcHRvcnMpO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gdG9GbGF0T2JqZWN0KHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyKSB7XG4gIHZhciBwcm9wcztcbiAgdmFyIGk7XG4gIHZhciBwcm9wO1xuICB2YXIgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufVxuXG4vKlxuICogZGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdFxuICogQHBhcmFtIHsqfSBbdGhpbmddXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkodGhpbmcpIHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIHZhciBpID0gdGhpbmcubGVuZ3RoO1xuICBpZiAoaXNVbmRlZmluZWQoaSkpIHJldHVybiBudWxsO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGFycltpXSA9IHRoaW5nW2ldO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG52YXIgaXNUeXBlZEFycmF5ID0gKGZ1bmN0aW9uKFR5cGVkQXJyYXkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT00sXG4gIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgdG9GbGF0T2JqZWN0OiB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZjoga2luZE9mLFxuICBraW5kT2ZUZXN0OiBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aDogZW5kc1dpdGgsXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0OiBpc0ZpbGVMaXN0XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xuXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kKDcpXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG52YXIgQXJyYXkgPSBnbG9iYWwuQXJyYXk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9IEFycmF5KG1heChmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBBcnJheSA9IGdsb2JhbC5BcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsInZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyhpdCksIDgsIC0xKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1uYW1lJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoIUlTX1BVUkUgJiYgZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgICAgICAgICByZWRlZmluZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IsIHsgbmFtZTogREVGQVVMVCB9KTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTtcbiAgaWYgKCFoYXNPd24oU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkoU3ltYm9sLCBOQU1FLCB7XG4gICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZihOQU1FKVxuICB9KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG4iLCIvLyBpbiBvbGQgV2ViS2l0IHZlcnNpb25zLCBgZWxlbWVudC5jbGFzc0xpc3RgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBnbG9iYWwgYERPTVRva2VuTGlzdGBcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxudmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlO1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5ID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXJlZmxlY3QgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCA/IGNhbGwuYmluZChhcHBseSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGFwcGx5LCBhcmd1bWVudHMpO1xufSk7XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgYmluZCA9IHVuY3VycnlUaGlzKHVuY3VycnlUaGlzLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZChmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvbiA9IGdsb2JhbC5GdW5jdGlvbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghaGFzT3duKGZhY3RvcmllcywgYXJnc0xlbmd0aCkpIHtcbiAgICBmb3IgKHZhciBsaXN0ID0gW10sIGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSBsaXN0W2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gRnVuY3Rpb24oJ0MsYScsICdyZXR1cm4gbmV3IEMoJyArIGpvaW4obGlzdCwgJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1thcmdzTGVuZ3RoXShDLCBhcmdzKTtcbn07XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gRnVuY3Rpb24uYmluZCA6IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIEYgPSBhQ2FsbGFibGUodGhpcyk7XG4gIHZhciBQcm90b3R5cGUgPSBGLnByb3RvdHlwZTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uIGJvdW5kKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IGNvbmNhdChwYXJ0QXJncywgYXJyYXlTbGljZShhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QoRiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogRi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KFByb3RvdHlwZSkpIGJvdW5kRnVuY3Rpb24ucHJvdG90eXBlID0gUHJvdG90eXBlO1xuICByZXR1cm4gYm91bmRGdW5jdGlvbjtcbn07XG4iLCJ2YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093bihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgKERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuIiwidmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kID0gRnVuY3Rpb25Qcm90b3R5cGUuYmluZDtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EICYmIGJpbmQuYmluZChjYWxsLCBjYWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKSA6IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwidmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcbiIsInZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyIE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcbiIsInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIGlzQ2FsbGFibGUoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiIsInZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzKHN0b3JlLnNldCk7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PSAnQXJyYXknO1xufTtcbiIsIi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgT2JqZWN0ID0gZ2xvYmFsLk9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCBPYmplY3QoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuZWxzZSBpZiAoSVNfUFVSRSkgSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUoSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkge1xuICByZWRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG4iLCJ2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmUgKi9cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJiAhIVN5bWJvbFsnZm9yJ10gJiYgISFTeW1ib2wua2V5Rm9yO1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuIiwiLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmUgKi9cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlJyk7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBhcnJheVNsaWNlKHdpbmRvd05hbWVzKTtcbiAgfVxufTtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIGNsYXNzb2YoaXQpID09ICdXaW5kb3cnXG4gICAgPyBnZXRXaW5kb3dOYW1lcyhpdClcbiAgICA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0ID0gZ2xvYmFsLk9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChPKTtcbiAgaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24oaGlkZGVuS2V5cywga2V5KSAmJiBoYXNPd24oTywga2V5KSAmJiBwdXNoKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093bihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCBwdXNoKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkNPTkZJR1VSQUJMRTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIHZhciBzdGF0ZTtcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSB7XG4gICAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gICAgfVxuICAgIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIG5hbWUpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gICAgfVxuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMi4yJyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMi4yL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5KHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgICAgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdChTLCBwb3NpdGlvbilcbiAgICAgICAgICA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IHN0cmluZ1NsaWNlKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcblxudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZShzdHJpbmcsIHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QoMylcbn07XG4iLCJ2YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICB2YXIgU3ltYm9sUHJvdG90eXBlID0gU3ltYm9sICYmIFN5bWJvbC5wcm90b3R5cGU7XG4gIHZhciB2YWx1ZU9mID0gU3ltYm9sUHJvdG90eXBlICYmIFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mO1xuICB2YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4gIGlmIChTeW1ib2xQcm90b3R5cGUgJiYgIVN5bWJvbFByb3RvdHlwZVtUT19QUklNSVRJVkVdKSB7XG4gICAgLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciAubGVuZ3RoXG4gICAgcmVkZWZpbmUoU3ltYm9sUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICByZXR1cm4gY2FsbCh2YWx1ZU9mLCB0aGlzKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxuLy8gYHRoaXNOdW1iZXJWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRoaXNudW1iZXJ2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcygxLjAudmFsdWVPZik7XG4iLCJ2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gc2FmZVxuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IChudW1iZXIgPiAwID8gZmxvb3IgOiBjZWlsKShudW1iZXIpO1xufTtcbiIsInZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgT2JqZWN0ID0gZ2xvYmFsLk9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuIiwidmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmcoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wgJiYgU3ltYm9sWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoIUlTX1BVUkUgJiYgREVTQ1JJUFRPUlMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2UnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcblxudmFyICRzdHJpbmdpZnkgPSBnZXRCdWlsdEluKCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckNvZGVBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcblxudmFyIHRlc3RlciA9IC9bXFx1RDgwMC1cXHVERkZGXS9nO1xudmFyIGxvdyA9IC9eW1xcdUQ4MDAtXFx1REJGRl0kLztcbnZhciBoaSA9IC9eW1xcdURDMDAtXFx1REZGRl0kLztcblxudmFyIFdST05HX1NZTUJPTFNfQ09OVkVSU0lPTiA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIHJldHVybiAkc3RyaW5naWZ5KFtzeW1ib2xdKSAhPSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC13ZWxsLWZvcm1lZC1zdHJpbmdpZnlcbnZhciBJTExfRk9STUVEX1VOSUNPREUgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkc3RyaW5naWZ5KCdcXHVERjA2XFx1RDgzNCcpICE9PSAnXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIidcbiAgICB8fCAkc3RyaW5naWZ5KCdcXHVERUFEJykgIT09ICdcIlxcXFx1ZGVhZFwiJztcbn0pO1xuXG52YXIgc3RyaW5naWZ5V2l0aFN5bWJvbHNGaXggPSBmdW5jdGlvbiAoaXQsIHJlcGxhY2VyKSB7XG4gIHZhciBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICB2YXIgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0NhbGxhYmxlKCRyZXBsYWNlcikpIHZhbHVlID0gY2FsbCgkcmVwbGFjZXIsIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgcmV0dXJuIGFwcGx5KCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcbiAgaWYgKChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSkgfHwgKGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gfHwgSUxMX0ZPUk1FRF9VTklDT0RFIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5KFdST05HX1NZTUJPTFNfQ09OVkVSU0lPTiA/IHN0cmluZ2lmeVdpdGhTeW1ib2xzRml4IDogJHN0cmluZ2lmeSwgbnVsbCwgYXJncyk7XG4gICAgICByZXR1cm4gSUxMX0ZPUk1FRF9VTklDT0RFICYmIHR5cGVvZiByZXN1bHQgPT0gJ3N0cmluZycgPyByZXBsYWNlKHJlc3VsdCwgdGVzdGVyLCBmaXhJbGxGb3JtZWQpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciB0aGlzTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGhpcy1udW1iZXItdmFsdWUnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyIE5hdGl2ZU51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE5hdGl2ZU51bWJlci5wcm90b3R5cGU7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBhcnJheVNsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcblxuLy8gYFRvTnVtZXJpY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbnVtZXJpY1xudmFyIHRvTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJpbVZhbHVlID0gdG9QcmltaXRpdmUodmFsdWUsICdudW1iZXInKTtcbiAgcmV0dXJuIHR5cGVvZiBwcmltVmFsdWUgPT0gJ2JpZ2ludCcgPyBwcmltVmFsdWUgOiB0b051bWJlcihwcmltVmFsdWUpO1xufTtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAoaXNTeW1ib2woaXQpKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gdHJpbShpdCk7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KGl0LCAwKTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBjaGFyQ29kZUF0KGl0LCAyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGNoYXJDb2RlQXQoaXQsIDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBhcnJheVNsaWNlKGl0LCAyKTtcbiAgICAgIGxlbmd0aCA9IGRpZ2l0cy5sZW5ndGg7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29kZSA9IGNoYXJDb2RlQXQoZGlnaXRzLCBpbmRleCk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXItY29uc3RydWN0b3JcbmlmIChpc0ZvcmNlZChOVU1CRVIsICFOYXRpdmVOdW1iZXIoJyAwbzEnKSB8fCAhTmF0aXZlTnVtYmVyKCcwYjEnKSB8fCBOYXRpdmVOdW1iZXIoJysweDEnKSkpIHtcbiAgdmFyIE51bWJlcldyYXBwZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IE5hdGl2ZU51bWJlcih0b051bWVyaWModmFsdWUpKTtcbiAgICB2YXIgZHVtbXkgPSB0aGlzO1xuICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgIHJldHVybiBpc1Byb3RvdHlwZU9mKE51bWJlclByb3RvdHlwZSwgZHVtbXkpICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgdGhpc051bWJlclZhbHVlKGR1bW15KTsgfSlcbiAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQoT2JqZWN0KG4pLCBkdW1teSwgTnVtYmVyV3JhcHBlcikgOiBuO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gREVTQ1JJUFRPUlMgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZU51bWJlcikgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzIwMTUgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzIwMTUgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixNQVhfU0FGRV9JTlRFR0VSLE1JTl9TQUZFX0lOVEVHRVIsaXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIscGFyc2VGbG9hdCxwYXJzZUludCwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXNPd24oTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzT3duKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG4iLCIvLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBjcmVhdGU6IGNyZWF0ZVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSBkZWZpbmVQcm9wZXJ0eSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxuLy8gVjggfiBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRk9SQ0VEID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICB2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gJGdldE93blByb3BlcnR5U3ltYm9scyh0b09iamVjdChpdCkpIDogW107XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldFByb3RvdHlwZU9mKDEpOyB9KTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiB9LCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVLZXlzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIHNldFByb3RvdHlwZU9mOiBzZXRQcm90b3R5cGVPZlxufSk7XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZycpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIHJlZGVmaW5lKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBhQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jb25zdHJ1Y3RvcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBwdXNoID0gW10ucHVzaDtcblxuLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5jb25zdHJ1Y3Rcbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG5cbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciBGT1JDRUQgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcblxuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogRk9SQ0VEIH0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUNvbnN0cnVjdG9yKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUNvbnN0cnVjdG9yKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICBhcHBseShwdXNoLCAkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChhcHBseShiaW5kLCBUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3RQcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBhcHBseShUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2wgJiYgJFN5bWJvbFtQUk9UT1RZUEVdO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcblxuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGVbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZShTeW1ib2xQcm90b3R5cGUpO1xuICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzT3duKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXNPd24oTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc093bihPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbCgkcHJvcGVydHlJc0VudW1lcmFibGUsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gIHZhciBlbnVtZXJhYmxlID0gY2FsbChuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzT3duKEFsbFN5bWJvbHMsIFApICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093bih0aGlzLCBQKSB8fCAhaGFzT3duKEFsbFN5bWJvbHMsIFApIHx8IGhhc093bih0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXVxuICAgID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24oaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duKGhpZGRlbktleXMsIGtleSkpIHB1c2gocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXNPd24oT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcHVzaChyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICR0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pO1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUpIGNhbGwoc2V0dGVyLCBPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzT3duKHRoaXMsIEhJRERFTikgJiYgaGFzT3duKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgU3ltYm9sUHJvdG90eXBlID0gJFN5bWJvbFtQUk9UT1RZUEVdO1xuXG4gIHJlZGVmaW5lKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZChkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZGVmaW5lUHJvcGVydGllc01vZHVsZS5mID0gJGRlZmluZVByb3BlcnRpZXM7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2VsbEtub3duU3ltYm9sKG5hbWUpLCBuYW1lKTtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG5cbiQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSBmYWxzZTsgfVxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzXG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG4iLCIvLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgaXNDYWxsYWJsZShOYXRpdmVTeW1ib2wpICYmICghKCdkZXNjcmlwdGlvbicgaW4gU3ltYm9sUHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gaXNQcm90b3R5cGVPZihTeW1ib2xQcm90b3R5cGUsIHRoaXMpXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IFN5bWJvbFByb3RvdHlwZTtcbiAgU3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgTkFUSVZFX1NZTUJPTCA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHVuY3VycnlUaGlzKFN5bWJvbFByb3RvdHlwZS50b1N0cmluZyk7XG4gIHZhciBzeW1ib2xWYWx1ZU9mID0gdW5jdXJyeVRoaXMoU3ltYm9sUHJvdG90eXBlLnZhbHVlT2YpO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG4gIGRlZmluZVByb3BlcnR5KFN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbFZhbHVlT2YodGhpcyk7XG4gICAgICB2YXIgc3RyaW5nID0gc3ltYm9sVG9TdHJpbmcoc3ltYm9sKTtcbiAgICAgIGlmIChoYXNPd24oRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IE5BVElWRV9TWU1CT0wgPyBzdHJpbmdTbGljZShzdHJpbmcsIDcsIC0xKSA6IHJlcGxhY2Uoc3RyaW5nLCByZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MX1JFR0lTVFJZID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wtcmVnaXN0cnknKTtcblxudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG5cbi8vIGBTeW1ib2wuZm9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuJCh7IHRhcmdldDogJ1N5bWJvbCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0xfUkVHSVNUUlkgfSwge1xuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyhrZXkpO1xuICAgIGlmIChoYXNPd24oU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICB2YXIgc3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJykoc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cbn0pO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG4iLCIvLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHNwbGl0IHRvIG1vZHVsZXMgbGlzdGVkIGJlbG93XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wuZm9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5rZXktZm9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MX1JFR0lTVFJZID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wtcmVnaXN0cnknKTtcblxudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKHN5bSkgKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXNPd24oU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfVxufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS10b2tlbi1saXN0LXByb3RvdHlwZScpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBydW50aW1lIGhlbHBlciBmb3Igc2V0dGluZyBwcm9wZXJ0aWVzIG9uIGNvbXBvbmVudHNcbi8vIGluIGEgdHJlZS1zaGFrYWJsZSB3YXlcbmV4cG9ydHMuZGVmYXVsdCA9IChzZmMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2ZjLl9fdmNjT3B0cyB8fCBzZmM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHByb3BzKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIi8qIVxuICAqIHZ1ZS1yb3V0ZXIgdjQuMC4xNVxuICAqIChjKSAyMDIyIEVkdWFyZG8gU2FuIE1hcnRpbiBNb3JvdGVcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbmltcG9ydCB7IGdldEN1cnJlbnRJbnN0YW5jZSwgaW5qZWN0LCBvblVubW91bnRlZCwgb25EZWFjdGl2YXRlZCwgb25BY3RpdmF0ZWQsIGNvbXB1dGVkLCB1bnJlZiwgd2F0Y2hFZmZlY3QsIGRlZmluZUNvbXBvbmVudCwgcmVhY3RpdmUsIGgsIHByb3ZpZGUsIHJlZiwgd2F0Y2gsIHNoYWxsb3dSZWYsIG5leHRUaWNrIH0gZnJvbSAndnVlJztcbmltcG9ydCB7IHNldHVwRGV2dG9vbHNQbHVnaW4gfSBmcm9tICdAdnVlL2RldnRvb2xzLWFwaSc7XG5cbmNvbnN0IGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IFBvbHlTeW1ib2wgPSAobmFtZSkgPT4gXHJcbi8vIHZyID0gdnVlIHJvdXRlclxyXG5oYXNTeW1ib2xcclxuICAgID8gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdbdnVlLXJvdXRlcl06ICcgKyBuYW1lIDogbmFtZSlcclxuICAgIDogKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdbdnVlLXJvdXRlcl06ICcgOiAnX3ZyXycpICsgbmFtZTtcclxuLy8gcnZsbSA9IFJvdXRlciBWaWV3IExvY2F0aW9uIE1hdGNoZWRcclxuLyoqXHJcbiAqIFJvdXRlUmVjb3JkIGJlaW5nIHJlbmRlcmVkIGJ5IHRoZSBjbG9zZXN0IGFuY2VzdG9yIFJvdXRlciBWaWV3LiBVc2VkIGZvclxyXG4gKiBgb25CZWZvcmVSb3V0ZVVwZGF0ZWAgYW5kIGBvbkJlZm9yZVJvdXRlTGVhdmVgLiBydmxtIHN0YW5kcyBmb3IgUm91dGVyIFZpZXdcclxuICogTG9jYXRpb24gTWF0Y2hlZFxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IG1hdGNoZWRSb3V0ZUtleSA9IC8qI19fUFVSRV9fKi8gUG9seVN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAncm91dGVyIHZpZXcgbG9jYXRpb24gbWF0Y2hlZCcgOiAncnZsbScpO1xyXG4vKipcclxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIHJvdXRlciB2aWV3IGRlcHRoIHRvIGNvbnRyb2wgd2hpY2ggY29tcG9uZW50IGluXHJcbiAqIGBtYXRjaGVkYCBpcyByZW5kZXJlZC4gcnZkIHN0YW5kcyBmb3IgUm91dGVyIFZpZXcgRGVwdGhcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2aWV3RGVwdGhLZXkgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGRlcHRoJyA6ICdydmQnKTtcclxuLyoqXHJcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSByb3V0ZXIgaW5zdGFuY2UgcmV0dXJuZWQgYnkgYHVzZVJvdXRlcmAgaW4gdGVzdHMuIHJcclxuICogc3RhbmRzIGZvciByb3V0ZXJcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCByb3V0ZXJLZXkgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlcicgOiAncicpO1xyXG4vKipcclxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGN1cnJlbnQgcm91dGUgcmV0dXJuZWQgYnkgYHVzZVJvdXRlYCBpbiB0ZXN0cy4gcmxcclxuICogc3RhbmRzIGZvciByb3V0ZSBsb2NhdGlvblxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHJvdXRlTG9jYXRpb25LZXkgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlIGxvY2F0aW9uJyA6ICdybCcpO1xyXG4vKipcclxuICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGN1cnJlbnQgcm91dGUgdXNlZCBieSByb3V0ZXItdmlldy4gSW50ZXJuYWxseSB0aGlzIGlzXHJcbiAqIHVzZWQgd2hlbiB0aGUgYHJvdXRlYCBwcm9wIGlzIHBhc3NlZC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCByb3V0ZXJWaWV3TG9jYXRpb25LZXkgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGxvY2F0aW9uJyA6ICdydmwnKTtcblxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzRVNNb2R1bGUob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpO1xyXG59XHJcbmNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbmZ1bmN0aW9uIGFwcGx5VG9QYXJhbXMoZm4sIHBhcmFtcykge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xyXG4gICAgICAgIG5ld1BhcmFtc1trZXldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoZm4pIDogZm4odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xyXG4gICAgLy8gYXZvaWQgdXNpbmcgLi4uYXJncyBhcyBpdCBicmVha3MgaW4gb2xkZXIgRWRnZSBidWlsZHNcclxuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSk7XHJcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgWydbVnVlIFJvdXRlciB3YXJuXTogJyArIG1zZ10uY29uY2F0KGFyZ3MpKTtcclxufVxuXG5jb25zdCBUUkFJTElOR19TTEFTSF9SRSA9IC9cXC8kLztcclxuY29uc3QgcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IChwYXRoKSA9PiBwYXRoLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfUkUsICcnKTtcclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYW4gVVJJIGludG8gYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb25cclxuICpcclxuICogQHBhcmFtIHBhcnNlUXVlcnlcclxuICogQHBhcmFtIGxvY2F0aW9uIC0gVVJJIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcGFyYW0gY3VycmVudExvY2F0aW9uIC0gY3VycmVudCBhYnNvbHV0ZSBsb2NhdGlvbi4gQWxsb3dzIHJlc29sdmluZyByZWxhdGl2ZVxyXG4gKiBwYXRocy4gTXVzdCBzdGFydCB3aXRoIGAvYC4gRGVmYXVsdHMgdG8gYC9gXHJcbiAqIEByZXR1cm5zIGEgbm9ybWFsaXplZCBoaXN0b3J5IGxvY2F0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVVSTChwYXJzZVF1ZXJ5LCBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uID0gJy8nKSB7XHJcbiAgICBsZXQgcGF0aCwgcXVlcnkgPSB7fSwgc2VhcmNoU3RyaW5nID0gJycsIGhhc2ggPSAnJztcclxuICAgIC8vIENvdWxkIHVzZSBVUkwgYW5kIFVSTFNlYXJjaFBhcmFtcyBidXQgSUUgMTEgZG9lc24ndCBzdXBwb3J0IGl0XHJcbiAgICBjb25zdCBzZWFyY2hQb3MgPSBsb2NhdGlvbi5pbmRleE9mKCc/Jyk7XHJcbiAgICBjb25zdCBoYXNoUG9zID0gbG9jYXRpb24uaW5kZXhPZignIycsIHNlYXJjaFBvcyA+IC0xID8gc2VhcmNoUG9zIDogMCk7XHJcbiAgICBpZiAoc2VhcmNoUG9zID4gLTEpIHtcclxuICAgICAgICBwYXRoID0gbG9jYXRpb24uc2xpY2UoMCwgc2VhcmNoUG9zKTtcclxuICAgICAgICBzZWFyY2hTdHJpbmcgPSBsb2NhdGlvbi5zbGljZShzZWFyY2hQb3MgKyAxLCBoYXNoUG9zID4gLTEgPyBoYXNoUG9zIDogbG9jYXRpb24ubGVuZ3RoKTtcclxuICAgICAgICBxdWVyeSA9IHBhcnNlUXVlcnkoc2VhcmNoU3RyaW5nKTtcclxuICAgIH1cclxuICAgIGlmIChoYXNoUG9zID4gLTEpIHtcclxuICAgICAgICBwYXRoID0gcGF0aCB8fCBsb2NhdGlvbi5zbGljZSgwLCBoYXNoUG9zKTtcclxuICAgICAgICAvLyBrZWVwIHRoZSAjIGNoYXJhY3RlclxyXG4gICAgICAgIGhhc2ggPSBsb2NhdGlvbi5zbGljZShoYXNoUG9zLCBsb2NhdGlvbi5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLy8gbm8gc2VhcmNoIGFuZCBubyBxdWVyeVxyXG4gICAgcGF0aCA9IHJlc29sdmVSZWxhdGl2ZVBhdGgocGF0aCAhPSBudWxsID8gcGF0aCA6IGxvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24pO1xyXG4gICAgLy8gZW1wdHkgcGF0aCBtZWFucyBhIHJlbGF0aXZlIHF1ZXJ5IG9yIGhhc2ggYD9mb289ZmAsIGAjdGhpbmdgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZ1bGxQYXRoOiBwYXRoICsgKHNlYXJjaFN0cmluZyAmJiAnPycpICsgc2VhcmNoU3RyaW5nICsgaGFzaCxcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgIGhhc2gsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmdpZmllcyBhIFVSTCBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHN0cmluZ2lmeVF1ZXJ5XHJcbiAqIEBwYXJhbSBsb2NhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5VVJMKHN0cmluZ2lmeVF1ZXJ5LCBsb2NhdGlvbikge1xyXG4gICAgY29uc3QgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSA/IHN0cmluZ2lmeVF1ZXJ5KGxvY2F0aW9uLnF1ZXJ5KSA6ICcnO1xyXG4gICAgcmV0dXJuIGxvY2F0aW9uLnBhdGggKyAocXVlcnkgJiYgJz8nKSArIHF1ZXJ5ICsgKGxvY2F0aW9uLmhhc2ggfHwgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBTdHJpcHMgb2ZmIHRoZSBiYXNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhIGxvY2F0aW9uLnBhdGhuYW1lIGluIGEgbm9uXHJcbiAqIGNhc2Utc2Vuc2l0aXZlIHdheS5cclxuICpcclxuICogQHBhcmFtIHBhdGhuYW1lIC0gbG9jYXRpb24ucGF0aG5hbWVcclxuICogQHBhcmFtIGJhc2UgLSBiYXNlIHRvIHN0cmlwIG9mZlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaXBCYXNlKHBhdGhuYW1lLCBiYXNlKSB7XHJcbiAgICAvLyBubyBiYXNlIG9yIGJhc2UgaXMgbm90IGZvdW5kIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgIGlmICghYmFzZSB8fCAhcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2UudG9Mb3dlckNhc2UoKSkpXHJcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xyXG4gICAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2UubGVuZ3RoKSB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gUm91dGVMb2NhdGlvbiBhcmUgZXF1YWwuIFRoaXMgbWVhbnMgdGhhdCBib3RoIGxvY2F0aW9ucyBhcmVcclxuICogcG9pbnRpbmcgdG93YXJkcyB0aGUgc2FtZSB7QGxpbmsgUm91dGVSZWNvcmR9IGFuZCB0aGF0IGFsbCBgcGFyYW1zYCwgYHF1ZXJ5YFxyXG4gKiBwYXJhbWV0ZXJzIGFuZCBgaGFzaGAgYXJlIHRoZSBzYW1lXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3Qge0BsaW5rIFJvdXRlTG9jYXRpb259XHJcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIHtAbGluayBSb3V0ZUxvY2F0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVMb2NhdGlvbihzdHJpbmdpZnlRdWVyeSwgYSwgYikge1xyXG4gICAgY29uc3QgYUxhc3RJbmRleCA9IGEubWF0Y2hlZC5sZW5ndGggLSAxO1xyXG4gICAgY29uc3QgYkxhc3RJbmRleCA9IGIubWF0Y2hlZC5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIChhTGFzdEluZGV4ID4gLTEgJiZcclxuICAgICAgICBhTGFzdEluZGV4ID09PSBiTGFzdEluZGV4ICYmXHJcbiAgICAgICAgaXNTYW1lUm91dGVSZWNvcmQoYS5tYXRjaGVkW2FMYXN0SW5kZXhdLCBiLm1hdGNoZWRbYkxhc3RJbmRleF0pICYmXHJcbiAgICAgICAgaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtcyhhLnBhcmFtcywgYi5wYXJhbXMpICYmXHJcbiAgICAgICAgc3RyaW5naWZ5UXVlcnkoYS5xdWVyeSkgPT09IHN0cmluZ2lmeVF1ZXJ5KGIucXVlcnkpICYmXHJcbiAgICAgICAgYS5oYXNoID09PSBiLmhhc2gpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gYFJvdXRlUmVjb3Jkc2AgYXJlIGVxdWFsLiBUYWtlcyBpbnRvIGFjY291bnQgYWxpYXNlczogdGhleSBhcmVcclxuICogY29uc2lkZXJlZCBlcXVhbCB0byB0aGUgYFJvdXRlUmVjb3JkYCB0aGV5IGFyZSBhbGlhc2luZy5cclxuICpcclxuICogQHBhcmFtIGEgLSBmaXJzdCB7QGxpbmsgUm91dGVSZWNvcmR9XHJcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIHtAbGluayBSb3V0ZVJlY29yZH1cclxuICovXHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlUmVjb3JkKGEsIGIpIHtcclxuICAgIC8vIHNpbmNlIHRoZSBvcmlnaW5hbCByZWNvcmQgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBmb3IgYWxpYXNPZlxyXG4gICAgLy8gYnV0IGFsbCBhbGlhc2VzIHBvaW50IHRvIHRoZSBvcmlnaW5hbCByZWNvcmQsIHRoaXMgd2lsbCBhbHdheXMgY29tcGFyZVxyXG4gICAgLy8gdGhlIG9yaWdpbmFsIHJlY29yZFxyXG4gICAgcmV0dXJuIChhLmFsaWFzT2YgfHwgYSkgPT09IChiLmFsaWFzT2YgfHwgYik7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtcyhhLCBiKSB7XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgIGlmICghaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtc1ZhbHVlKGFba2V5XSwgYltrZXldKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtc1ZhbHVlKGEsIGIpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGEpXHJcbiAgICAgICAgPyBpc0VxdWl2YWxlbnRBcnJheShhLCBiKVxyXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShiKVxyXG4gICAgICAgICAgICA/IGlzRXF1aXZhbGVudEFycmF5KGIsIGEpXHJcbiAgICAgICAgICAgIDogYSA9PT0gYjtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIGFycmF5cyBhcmUgdGhlIHNhbWUgb3IgaWYgYW4gYXJyYXkgd2l0aCBvbmUgc2luZ2xlIGVudHJ5IGlzIHRoZVxyXG4gKiBzYW1lIGFzIGFub3RoZXIgcHJpbWl0aXZlIHZhbHVlLiBVc2VkIHRvIGNoZWNrIHF1ZXJ5IGFuZCBwYXJhbWV0ZXJzXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gYXJyYXkgb2YgdmFsdWVzXHJcbiAqIEBwYXJhbSBiIC0gYXJyYXkgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRBcnJheShhLCBiKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKVxyXG4gICAgICAgID8gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHZhbHVlLCBpKSA9PiB2YWx1ZSA9PT0gYltpXSlcclxuICAgICAgICA6IGEubGVuZ3RoID09PSAxICYmIGFbMF0gPT09IGI7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmVzIGEgcmVsYXRpdmUgcGF0aCB0aGF0IHN0YXJ0cyB3aXRoIGAuYC5cclxuICpcclxuICogQHBhcmFtIHRvIC0gcGF0aCBsb2NhdGlvbiB3ZSBhcmUgcmVzb2x2aW5nXHJcbiAqIEBwYXJhbSBmcm9tIC0gY3VycmVudExvY2F0aW9uLnBhdGgsIHNob3VsZCBzdGFydCB3aXRoIGAvYFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlUGF0aCh0bywgZnJvbSkge1xyXG4gICAgaWYgKHRvLnN0YXJ0c1dpdGgoJy8nKSlcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmcm9tLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgIHdhcm4oYENhbm5vdCByZXNvbHZlIGEgcmVsYXRpdmUgbG9jYXRpb24gd2l0aG91dCBhbiBhYnNvbHV0ZSBwYXRoLiBUcnlpbmcgdG8gcmVzb2x2ZSBcIiR7dG99XCIgZnJvbSBcIiR7ZnJvbX1cIi4gSXQgc2hvdWxkIGxvb2sgbGlrZSBcIi8ke2Zyb219XCIuYCk7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bylcclxuICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgIGNvbnN0IGZyb21TZWdtZW50cyA9IGZyb20uc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHRvU2VnbWVudHMgPSB0by5zcGxpdCgnLycpO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gZnJvbVNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgdG9Qb3NpdGlvbjtcclxuICAgIGxldCBzZWdtZW50O1xyXG4gICAgZm9yICh0b1Bvc2l0aW9uID0gMDsgdG9Qb3NpdGlvbiA8IHRvU2VnbWVudHMubGVuZ3RoOyB0b1Bvc2l0aW9uKyspIHtcclxuICAgICAgICBzZWdtZW50ID0gdG9TZWdtZW50c1t0b1Bvc2l0aW9uXTtcclxuICAgICAgICAvLyBjYW4ndCBnbyBiZWxvdyB6ZXJvXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAxIHx8IHNlZ21lbnQgPT09ICcuJylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcuLicpXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLS07XHJcbiAgICAgICAgLy8gZm91bmQgc29tZXRoaW5nIHRoYXQgaXMgbm90IHJlbGF0aXZlIHBhdGhcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChmcm9tU2VnbWVudHMuc2xpY2UoMCwgcG9zaXRpb24pLmpvaW4oJy8nKSArXHJcbiAgICAgICAgJy8nICtcclxuICAgICAgICB0b1NlZ21lbnRzXHJcbiAgICAgICAgICAgIC5zbGljZSh0b1Bvc2l0aW9uIC0gKHRvUG9zaXRpb24gPT09IHRvU2VnbWVudHMubGVuZ3RoID8gMSA6IDApKVxyXG4gICAgICAgICAgICAuam9pbignLycpKTtcclxufVxuXG52YXIgTmF2aWdhdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoTmF2aWdhdGlvblR5cGUpIHtcclxuICAgIE5hdmlnYXRpb25UeXBlW1wicG9wXCJdID0gXCJwb3BcIjtcclxuICAgIE5hdmlnYXRpb25UeXBlW1wicHVzaFwiXSA9IFwicHVzaFwiO1xyXG59KShOYXZpZ2F0aW9uVHlwZSB8fCAoTmF2aWdhdGlvblR5cGUgPSB7fSkpO1xyXG52YXIgTmF2aWdhdGlvbkRpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChOYXZpZ2F0aW9uRGlyZWN0aW9uKSB7XHJcbiAgICBOYXZpZ2F0aW9uRGlyZWN0aW9uW1wiYmFja1wiXSA9IFwiYmFja1wiO1xyXG4gICAgTmF2aWdhdGlvbkRpcmVjdGlvbltcImZvcndhcmRcIl0gPSBcImZvcndhcmRcIjtcclxuICAgIE5hdmlnYXRpb25EaXJlY3Rpb25bXCJ1bmtub3duXCJdID0gXCJcIjtcclxufSkoTmF2aWdhdGlvbkRpcmVjdGlvbiB8fCAoTmF2aWdhdGlvbkRpcmVjdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBTdGFydGluZyBsb2NhdGlvbiBmb3IgSGlzdG9yaWVzXHJcbiAqL1xyXG5jb25zdCBTVEFSVCA9ICcnO1xyXG4vLyBHZW5lcmljIHV0aWxzXHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgYmFzZSBieSByZW1vdmluZyBhbnkgdHJhaWxpbmcgc2xhc2ggYW5kIHJlYWRpbmcgdGhlIGJhc2UgdGFnIGlmXHJcbiAqIHByZXNlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYXNlIC0gYmFzZSB0byBub3JtYWxpemVcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UoYmFzZSkge1xyXG4gICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcclxuICAgICAgICAgICAgY29uc3QgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xyXG4gICAgICAgICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcclxuICAgICAgICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXHJcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15cXHcrOlxcL1xcL1teXFwvXSsvLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBiYXNlID0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoIHdoZW4gaXQgd2FzIHJlbW92ZWQgYnkgdGhlIHJlZ2V4IGFib3ZlIGF2b2lkIGxlYWRpbmdcclxuICAgIC8vIHNsYXNoIHdpdGggaGFzaCBiZWNhdXNlIHRoZSBmaWxlIGNvdWxkIGJlIHJlYWQgZnJvbSB0aGUgZGlzayBsaWtlIGZpbGU6Ly9cclxuICAgIC8vIGFuZCB0aGUgbGVhZGluZyBzbGFzaCB3b3VsZCBjYXVzZSBwcm9ibGVtc1xyXG4gICAgaWYgKGJhc2VbMF0gIT09ICcvJyAmJiBiYXNlWzBdICE9PSAnIycpXHJcbiAgICAgICAgYmFzZSA9ICcvJyArIGJhc2U7XHJcbiAgICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoIHNvIGFsbCBvdGhlciBtZXRob2QgY2FuIGp1c3QgZG8gYGJhc2UgKyBmdWxsUGF0aGBcclxuICAgIC8vIHRvIGJ1aWxkIGFuIGhyZWZcclxuICAgIHJldHVybiByZW1vdmVUcmFpbGluZ1NsYXNoKGJhc2UpO1xyXG59XHJcbi8vIHJlbW92ZSBhbnkgY2hhcmFjdGVyIGJlZm9yZSB0aGUgaGFzaFxyXG5jb25zdCBCRUZPUkVfSEFTSF9SRSA9IC9eW14jXSsjLztcclxuZnVuY3Rpb24gY3JlYXRlSHJlZihiYXNlLCBsb2NhdGlvbikge1xyXG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShCRUZPUkVfSEFTSF9SRSwgJyMnKSArIGxvY2F0aW9uO1xyXG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBkb2NSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJlaGF2aW9yOiBvZmZzZXQuYmVoYXZpb3IsXHJcbiAgICAgICAgbGVmdDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSAob2Zmc2V0LmxlZnQgfHwgMCksXHJcbiAgICAgICAgdG9wOiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSAob2Zmc2V0LnRvcCB8fCAwKSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgY29tcHV0ZVNjcm9sbFBvc2l0aW9uID0gKCkgPT4gKHtcclxuICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxyXG59KTtcclxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgbGV0IHNjcm9sbFRvT3B0aW9ucztcclxuICAgIGlmICgnZWwnIGluIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25FbCA9IHBvc2l0aW9uLmVsO1xyXG4gICAgICAgIGNvbnN0IGlzSWRTZWxlY3RvciA9IHR5cGVvZiBwb3NpdGlvbkVsID09PSAnc3RyaW5nJyAmJiBwb3NpdGlvbkVsLnN0YXJ0c1dpdGgoJyMnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgaWRgcyBjYW4gYWNjZXB0IHByZXR0eSBtdWNoIGFueSBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgQ1NTIGNvbWJpbmF0b3JzXHJcbiAgICAgICAgICogbGlrZSBgPmAgb3IgYH5gLiBJdCdzIHN0aWxsIHBvc3NpYmxlIHRvIHJldHJpZXZlIGVsZW1lbnRzIHVzaW5nXHJcbiAgICAgICAgICogYGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd+JylgIGJ1dCBpdCBuZWVkcyB0byBiZSBlc2NhcGVkIHdoZW4gdXNpbmdcclxuICAgICAgICAgKiBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI1xcXFx+JylgIGZvciBpdCB0byBiZSB2YWxpZC4gVGhlIG9ubHlcclxuICAgICAgICAgKiByZXF1aXJlbWVudHMgZm9yIGBpZGBzIGFyZSB0aGVtIHRvIGJlIHVuaXF1ZSBvbiB0aGUgcGFnZSBhbmQgdG8gbm90IGJlXHJcbiAgICAgICAgICogZW1wdHkgKGBpZD1cIlwiYCkuIEJlY2F1c2Ugb2YgdGhhdCwgd2hlbiBwYXNzaW5nIGFuIGlkIHNlbGVjdG9yLCBpdCBzaG91bGRcclxuICAgICAgICAgKiBiZSBwcm9wZXJseSBlc2NhcGVkIGZvciBpdCB0byB3b3JrIHdpdGggYHF1ZXJ5U2VsZWN0b3JgLiBXZSBjb3VsZCBjaGVja1xyXG4gICAgICAgICAqIGZvciB0aGUgaWQgc2VsZWN0b3IgdG8gYmUgc2ltcGxlIChubyBDU1MgY29tYmluYXRvcnMgYCsgPn5gKSBidXQgdGhhdFxyXG4gICAgICAgICAqIHdvdWxkIG1ha2UgdGhpbmdzIGluY29uc2lzdGVudCBzaW5jZSB0aGV5IGFyZSB2YWxpZCBjaGFyYWN0ZXJzIGZvciBhblxyXG4gICAgICAgICAqIGBpZGAgYnV0IHdvdWxkIG5lZWQgdG8gYmUgZXNjYXBlZCB3aGVuIHVzaW5nIGBxdWVyeVNlbGVjdG9yYCwgYnJlYWtpbmdcclxuICAgICAgICAgKiB0aGVpciB1c2FnZSBhbmQgZW5kaW5nIHVwIGluIG5vIHNlbGVjdG9yIHJldHVybmVkLiBTZWxlY3RvcnMgbmVlZCB0byBiZVxyXG4gICAgICAgICAqIGVzY2FwZWQ6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtIGAjMS10aGluZ2AgYmVjb21lcyBgI1xcMzEgLXRoaW5nYFxyXG4gICAgICAgICAqIC0gYCN3aXRofnN5bWJvbHNgIGJlY29tZXMgYCN3aXRoXFxcXH5zeW1ib2xzYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBNb3JlIGluZm9ybWF0aW9uIGFib3V0ICB0aGUgdG9waWMgY2FuIGJlIGZvdW5kIGF0XHJcbiAgICAgICAgICogICBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvaHRtbDUtaWQtY2xhc3MuXHJcbiAgICAgICAgICogLSBQcmFjdGljYWwgZXhhbXBsZTogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vaHRtbDUtaWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHR5cGVvZiBwb3NpdGlvbi5lbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0lkU2VsZWN0b3IgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uLmVsLnNsaWNlKDEpKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihwb3NpdGlvbi5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRTZWxlY3RvciAmJiBmb3VuZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBzZWxlY3RvciBcIiR7cG9zaXRpb24uZWx9XCIgc2hvdWxkIGJlIHBhc3NlZCBhcyBcImVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcke3Bvc2l0aW9uLmVsfScpXCIgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBcIiNcIi5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRvIGF2b2lkIG90aGVyIHdhcm5pbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgVGhlIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiBpcyBpbnZhbGlkLiBJZiB5b3UgYXJlIHVzaW5nIGFuIGlkIHNlbGVjdG9yLCBtYWtlIHN1cmUgdG8gZXNjYXBlIGl0LiBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBlc2NhcGluZyBjaGFyYWN0ZXJzIGluIHNlbGVjdG9ycyBhdCBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMgb3IgdXNlIENTUy5lc2NhcGUgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DU1MvZXNjYXBlKS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdG8gYXZvaWQgb3RoZXIgd2FybmluZ3NcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZWwgPSB0eXBlb2YgcG9zaXRpb25FbCA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBpc0lkU2VsZWN0b3JcclxuICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb25FbC5zbGljZSgxKSlcclxuICAgICAgICAgICAgICAgIDogZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihwb3NpdGlvbkVsKVxyXG4gICAgICAgICAgICA6IHBvc2l0aW9uRWw7XHJcbiAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvdWxkbid0IGZpbmQgZWxlbWVudCB1c2luZyBzZWxlY3RvciBcIiR7cG9zaXRpb24uZWx9XCIgcmV0dXJuZWQgYnkgc2Nyb2xsQmVoYXZpb3IuYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Nyb2xsVG9PcHRpb25zID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsLCBwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY3JvbGxUb09wdGlvbnMgPSBwb3NpdGlvbjtcclxuICAgIH1cclxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlcclxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsVG9PcHRpb25zKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMubGVmdCAhPSBudWxsID8gc2Nyb2xsVG9PcHRpb25zLmxlZnQgOiB3aW5kb3cucGFnZVhPZmZzZXQsIHNjcm9sbFRvT3B0aW9ucy50b3AgIT0gbnVsbCA/IHNjcm9sbFRvT3B0aW9ucy50b3AgOiB3aW5kb3cucGFnZVlPZmZzZXQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFNjcm9sbEtleShwYXRoLCBkZWx0YSkge1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBoaXN0b3J5LnN0YXRlID8gaGlzdG9yeS5zdGF0ZS5wb3NpdGlvbiAtIGRlbHRhIDogLTE7XHJcbiAgICByZXR1cm4gcG9zaXRpb24gKyBwYXRoO1xyXG59XHJcbmNvbnN0IHNjcm9sbFBvc2l0aW9ucyA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGtleSwgc2Nyb2xsUG9zaXRpb24pIHtcclxuICAgIHNjcm9sbFBvc2l0aW9ucy5zZXQoa2V5LCBzY3JvbGxQb3NpdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihrZXkpIHtcclxuICAgIGNvbnN0IHNjcm9sbCA9IHNjcm9sbFBvc2l0aW9ucy5nZXQoa2V5KTtcclxuICAgIC8vIGNvbnN1bWUgaXQgc28gaXQncyBub3QgdXNlZCBhZ2FpblxyXG4gICAgc2Nyb2xsUG9zaXRpb25zLmRlbGV0ZShrZXkpO1xyXG4gICAgcmV0dXJuIHNjcm9sbDtcclxufVxyXG4vLyBUT0RPOiBSRkMgYWJvdXQgaG93IHRvIHNhdmUgc2Nyb2xsIHBvc2l0aW9uXHJcbi8qKlxyXG4gKiBTY3JvbGxCZWhhdmlvciBpbnN0YW5jZSB1c2VkIGJ5IHRoZSByb3V0ZXIgdG8gY29tcHV0ZSBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsXHJcbiAqIHBvc2l0aW9uIHdoZW4gbmF2aWdhdGluZy5cclxuICovXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsSGFuZGxlcjxTY3JvbGxQb3NpdGlvbkVudHJ5IGV4dGVuZHMgSGlzdG9yeVN0YXRlVmFsdWUsIFNjcm9sbFBvc2l0aW9uIGV4dGVuZHMgU2Nyb2xsUG9zaXRpb25FbnRyeT4ge1xyXG4vLyAgIC8vIHJldHVybnMgYSBzY3JvbGwgcG9zaXRpb24gdGhhdCBjYW4gYmUgc2F2ZWQgaW4gaGlzdG9yeVxyXG4vLyAgIGNvbXB1dGUoKTogU2Nyb2xsUG9zaXRpb25FbnRyeVxyXG4vLyAgIC8vIGNhbiB0YWtlIGFuIGV4dGVuZGVkIFNjcm9sbFBvc2l0aW9uRW50cnlcclxuLy8gICBzY3JvbGwocG9zaXRpb246IFNjcm9sbFBvc2l0aW9uKTogdm9pZFxyXG4vLyB9XHJcbi8vIGV4cG9ydCBjb25zdCBzY3JvbGxIYW5kbGVyOiBTY3JvbGxIYW5kbGVyPFNjcm9sbFBvc2l0aW9uPiA9IHtcclxuLy8gICBjb21wdXRlOiBjb21wdXRlU2Nyb2xsLFxyXG4vLyAgIHNjcm9sbDogc2Nyb2xsVG9Qb3NpdGlvbixcclxuLy8gfVxuXG5sZXQgY3JlYXRlQmFzZUxvY2F0aW9uID0gKCkgPT4gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb24gZnJvbSBhIHdpbmRvdy5sb2NhdGlvbiBvYmplY3RcclxuICogQHBhcmFtIGxvY2F0aW9uIC1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbikge1xyXG4gICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSBsb2NhdGlvbjtcclxuICAgIC8vIGFsbG93cyBoYXNoIGJhc2VzIGxpa2UgIywgLyMsICMvLCAjISwgIyEvLCAvIyEvLCBvciBldmVuIC9mb2xkZXIjZW5kXHJcbiAgICBjb25zdCBoYXNoUG9zID0gYmFzZS5pbmRleE9mKCcjJyk7XHJcbiAgICBpZiAoaGFzaFBvcyA+IC0xKSB7XHJcbiAgICAgICAgbGV0IHNsaWNlUG9zID0gaGFzaC5pbmNsdWRlcyhiYXNlLnNsaWNlKGhhc2hQb3MpKVxyXG4gICAgICAgICAgICA/IGJhc2Uuc2xpY2UoaGFzaFBvcykubGVuZ3RoXHJcbiAgICAgICAgICAgIDogMTtcclxuICAgICAgICBsZXQgcGF0aEZyb21IYXNoID0gaGFzaC5zbGljZShzbGljZVBvcyk7XHJcbiAgICAgICAgLy8gcHJlcGVuZCB0aGUgc3RhcnRpbmcgc2xhc2ggdG8gaGFzaCBzbyB0aGUgdXJsIHN0YXJ0cyB3aXRoIC8jXHJcbiAgICAgICAgaWYgKHBhdGhGcm9tSGFzaFswXSAhPT0gJy8nKVxyXG4gICAgICAgICAgICBwYXRoRnJvbUhhc2ggPSAnLycgKyBwYXRoRnJvbUhhc2g7XHJcbiAgICAgICAgcmV0dXJuIHN0cmlwQmFzZShwYXRoRnJvbUhhc2gsICcnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhdGggPSBzdHJpcEJhc2UocGF0aG5hbWUsIGJhc2UpO1xyXG4gICAgcmV0dXJuIHBhdGggKyBzZWFyY2ggKyBoYXNoO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUhpc3RvcnlMaXN0ZW5lcnMoYmFzZSwgaGlzdG9yeVN0YXRlLCBjdXJyZW50TG9jYXRpb24sIHJlcGxhY2UpIHtcclxuICAgIGxldCBsaXN0ZW5lcnMgPSBbXTtcclxuICAgIGxldCB0ZWFyZG93bnMgPSBbXTtcclxuICAgIC8vIFRPRE86IHNob3VsZCBpdCBiZSBhIHN0YWNrPyBhIERpY3QuIENoZWNrIGlmIHRoZSBwb3BzdGF0ZSBsaXN0ZW5lclxyXG4gICAgLy8gY2FuIHRyaWdnZXIgdHdpY2VcclxuICAgIGxldCBwYXVzZVN0YXRlID0gbnVsbDtcclxuICAgIGNvbnN0IHBvcFN0YXRlSGFuZGxlciA9ICh7IHN0YXRlLCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG8gPSBjcmVhdGVDdXJyZW50TG9jYXRpb24oYmFzZSwgbG9jYXRpb24pO1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50TG9jYXRpb24udmFsdWU7XHJcbiAgICAgICAgY29uc3QgZnJvbVN0YXRlID0gaGlzdG9yeVN0YXRlLnZhbHVlO1xyXG4gICAgICAgIGxldCBkZWx0YSA9IDA7XHJcbiAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi52YWx1ZSA9IHRvO1xyXG4gICAgICAgICAgICBoaXN0b3J5U3RhdGUudmFsdWUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBwb3BzdGF0ZSBhbmQgcmVzZXQgdGhlIHBhdXNlU3RhdGVcclxuICAgICAgICAgICAgaWYgKHBhdXNlU3RhdGUgJiYgcGF1c2VTdGF0ZSA9PT0gZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgcGF1c2VTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsdGEgPSBmcm9tU3RhdGUgPyBzdGF0ZS5wb3NpdGlvbiAtIGZyb21TdGF0ZS5wb3NpdGlvbiA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXBsYWNlKHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coeyBkZWx0YUZyb21DdXJyZW50IH0pXHJcbiAgICAgICAgLy8gSGVyZSB3ZSBjb3VsZCBhbHNvIHJldmVydCB0aGUgbmF2aWdhdGlvbiBieSBjYWxsaW5nIGhpc3RvcnkuZ28oLWRlbHRhKVxyXG4gICAgICAgIC8vIHRoaXMgbGlzdGVuZXIgd2lsbCBoYXZlIHRvIGJlIGFkYXB0ZWQgdG8gbm90IHRyaWdnZXIgYWdhaW4gYW5kIHRvIHdhaXQgZm9yIHRoZSB1cmxcclxuICAgICAgICAvLyB0byBiZSB1cGRhdGVkIGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSBsaXN0ZW5lcnMuIFNvbWUga2luZCBvZiB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdvdWxkIGFsc29cclxuICAgICAgICAvLyBuZWVkIHRvIGJlIHBhc3NlZCB0byB0aGUgbGlzdGVuZXJzIHNvIHRoZSBuYXZpZ2F0aW9uIGNhbiBiZSBhY2NlcHRlZFxyXG4gICAgICAgIC8vIGNhbGwgYWxsIGxpc3RlbmVyc1xyXG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcclxuICAgICAgICAgICAgbGlzdGVuZXIoY3VycmVudExvY2F0aW9uLnZhbHVlLCBmcm9tLCB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IE5hdmlnYXRpb25UeXBlLnBvcCxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGVsdGFcclxuICAgICAgICAgICAgICAgICAgICA/IGRlbHRhID4gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE5hdmlnYXRpb25EaXJlY3Rpb24uZm9yd2FyZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE5hdmlnYXRpb25EaXJlY3Rpb24uYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIDogTmF2aWdhdGlvbkRpcmVjdGlvbi51bmtub3duLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBwYXVzZUxpc3RlbmVycygpIHtcclxuICAgICAgICBwYXVzZVN0YXRlID0gY3VycmVudExvY2F0aW9uLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgdGhlIGxpc3RlbmVyIGFuZCBwcmVwYXJlIHRlYXJkb3duIGNhbGxiYWNrc1xyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0ZWFyZG93bnMucHVzaCh0ZWFyZG93bik7XHJcbiAgICAgICAgcmV0dXJuIHRlYXJkb3duO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyBoaXN0b3J5IH0gPSB3aW5kb3c7XHJcbiAgICAgICAgaWYgKCFoaXN0b3J5LnN0YXRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlLCB7IHNjcm9sbDogY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkgfSksICcnKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZWFyZG93biBvZiB0ZWFyZG93bnMpXHJcbiAgICAgICAgICAgIHRlYXJkb3duKCk7XHJcbiAgICAgICAgdGVhcmRvd25zID0gW107XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcG9wU3RhdGVIYW5kbGVyKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0dXAgdGhlIGxpc3RlbmVycyBhbmQgcHJlcGFyZSB0ZWFyZG93biBjYWxsYmFja3NcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHBvcFN0YXRlSGFuZGxlcik7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkTGlzdGVuZXIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXVzZUxpc3RlbmVycyxcclxuICAgICAgICBsaXN0ZW4sXHJcbiAgICAgICAgZGVzdHJveSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdGF0ZSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkU3RhdGUoYmFjaywgY3VycmVudCwgZm9yd2FyZCwgcmVwbGFjZWQgPSBmYWxzZSwgY29tcHV0ZVNjcm9sbCA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJhY2ssXHJcbiAgICAgICAgY3VycmVudCxcclxuICAgICAgICBmb3J3YXJkLFxyXG4gICAgICAgIHJlcGxhY2VkLFxyXG4gICAgICAgIHBvc2l0aW9uOiB3aW5kb3cuaGlzdG9yeS5sZW5ndGgsXHJcbiAgICAgICAgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsID8gY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkgOiBudWxsLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB1c2VIaXN0b3J5U3RhdGVOYXZpZ2F0aW9uKGJhc2UpIHtcclxuICAgIGNvbnN0IHsgaGlzdG9yeSwgbG9jYXRpb24gfSA9IHdpbmRvdztcclxuICAgIC8vIHByaXZhdGUgdmFyaWFibGVzXHJcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSB7XHJcbiAgICAgICAgdmFsdWU6IGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbiksXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0geyB2YWx1ZTogaGlzdG9yeS5zdGF0ZSB9O1xyXG4gICAgLy8gYnVpbGQgY3VycmVudCBoaXN0b3J5IGVudHJ5IGFzIHRoaXMgaXMgYSBmcmVzaCBuYXZpZ2F0aW9uXHJcbiAgICBpZiAoIWhpc3RvcnlTdGF0ZS52YWx1ZSkge1xyXG4gICAgICAgIGNoYW5nZUxvY2F0aW9uKGN1cnJlbnRMb2NhdGlvbi52YWx1ZSwge1xyXG4gICAgICAgICAgICBiYWNrOiBudWxsLFxyXG4gICAgICAgICAgICBjdXJyZW50OiBjdXJyZW50TG9jYXRpb24udmFsdWUsXHJcbiAgICAgICAgICAgIGZvcndhcmQ6IG51bGwsXHJcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggaXMgb2ZmIGJ5IG9uZSwgd2UgbmVlZCB0byBkZWNyZWFzZSBpdFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogaGlzdG9yeS5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICByZXBsYWNlZDogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGEgc2Nyb2xsIGFzIHRoZSB1c2VyIG1heSBoYXZlIGFuIGFuY2hvciBhbmQgd2Ugd2FudFxyXG4gICAgICAgICAgICAvLyBzY3JvbGxCZWhhdmlvciB0byBiZSB0cmlnZ2VyZWQgd2l0aG91dCBhIHNhdmVkIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIHNjcm9sbDogbnVsbCxcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNoYW5nZUxvY2F0aW9uKHRvLCBzdGF0ZSwgcmVwbGFjZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGlmIGEgYmFzZSB0YWcgaXMgcHJvdmlkZWQgYW5kIHdlIGFyZSBvbiBhIG5vcm1hbCBkb21haW4sIHdlIGhhdmUgdG9cclxuICAgICAgICAgKiByZXNwZWN0IHRoZSBwcm92aWRlZCBgYmFzZWAgYXR0cmlidXRlIGJlY2F1c2UgcHVzaFN0YXRlKCkgd2lsbCB1c2UgaXQgYW5kXHJcbiAgICAgICAgICogcG90ZW50aWFsbHkgZXJhc2UgYW55dGhpbmcgYmVmb3JlIHRoZSBgI2AgbGlrZSBhdFxyXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzY4NSB3aGVyZSBhIGJhc2Ugb2ZcclxuICAgICAgICAgKiBgL2ZvbGRlci8jYCBidXQgYSBiYXNlIG9mIGAvYCB3b3VsZCBlcmFzZSB0aGUgYC9mb2xkZXIvYCBzZWN0aW9uLiBJZlxyXG4gICAgICAgICAqIHRoZXJlIGlzIG5vIGhvc3QsIHRoZSBgPGJhc2U+YCB0YWcgbWFrZXMgbm8gc2Vuc2UgYW5kIGlmIHRoZXJlIGlzbid0IGFcclxuICAgICAgICAgKiBiYXNlIHRhZyB3ZSBjYW4ganVzdCB1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgYCNgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGJhc2UuaW5kZXhPZignIycpO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IGhhc2hJbmRleCA+IC0xXHJcbiAgICAgICAgICAgID8gKGxvY2F0aW9uLmhvc3QgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpXHJcbiAgICAgICAgICAgICAgICA/IGJhc2VcclxuICAgICAgICAgICAgICAgIDogYmFzZS5zbGljZShoYXNoSW5kZXgpKSArIHRvXHJcbiAgICAgICAgICAgIDogY3JlYXRlQmFzZUxvY2F0aW9uKCkgKyBiYXNlICsgdG87XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQlJPV1NFUiBRVUlSS1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBTYWZhcmkgdGhyb3dzIGEgU2VjdXJpdHlFcnJvciB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiAxMDAgdGltZXMgaW4gMzAgc2Vjb25kc1xyXG4gICAgICAgICAgICBoaXN0b3J5W3JlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXShzdGF0ZSwgJycsIHVybCk7XHJcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSA9IHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0Vycm9yIHdpdGggcHVzaC9yZXBsYWNlIFN0YXRlJywgZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgbmF2aWdhdGlvbiwgdGhpcyBhbHNvIHJlc2V0cyB0aGUgY2FsbCBjb3VudFxyXG4gICAgICAgICAgICBsb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZSh0bywgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXNzaWduKHt9LCBoaXN0b3J5LnN0YXRlLCBidWlsZFN0YXRlKGhpc3RvcnlTdGF0ZS52YWx1ZS5iYWNrLCBcclxuICAgICAgICAvLyBrZWVwIGJhY2sgYW5kIGZvcndhcmQgZW50cmllcyBidXQgb3ZlcnJpZGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgIHRvLCBoaXN0b3J5U3RhdGUudmFsdWUuZm9yd2FyZCwgdHJ1ZSksIGRhdGEsIHsgcG9zaXRpb246IGhpc3RvcnlTdGF0ZS52YWx1ZS5wb3NpdGlvbiB9KTtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIHRydWUpO1xyXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbi52YWx1ZSA9IHRvO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaCh0bywgZGF0YSkge1xyXG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IGVudHJ5IHRoZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB3ZSBhcmUgZ29pbmdcclxuICAgICAgICAvLyBhcyB3ZWxsIGFzIHNhdmluZyB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFzc2lnbih7fSwgXHJcbiAgICAgICAgLy8gdXNlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZSB0byBncmFjZWZ1bGx5IGhhbmRsZSBhIHdyb25nIGNhbGwgdG9cclxuICAgICAgICAvLyBoaXN0b3J5LnJlcGxhY2VTdGF0ZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzM2NlxyXG4gICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSwgaGlzdG9yeS5zdGF0ZSwge1xyXG4gICAgICAgICAgICBmb3J3YXJkOiB0byxcclxuICAgICAgICAgICAgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsUG9zaXRpb24oKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoaXN0b3J5LnN0YXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGhpc3Rvcnkuc3RhdGUgc2VlbXMgdG8gaGF2ZSBiZWVuIG1hbnVhbGx5IHJlcGxhY2VkIHdpdGhvdXQgcHJlc2VydmluZyB0aGUgbmVjZXNzYXJ5IHZhbHVlcy4gTWFrZSBzdXJlIHRvIHByZXNlcnZlIGV4aXN0aW5nIGhpc3Rvcnkgc3RhdGUgaWYgeW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGhpc3RvcnkucmVwbGFjZVN0YXRlOlxcblxcbmAgK1xyXG4gICAgICAgICAgICAgICAgYGhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3Rvcnkuc3RhdGUsICcnLCB1cmwpXFxuXFxuYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IGNhbiBmaW5kIG1vcmUgaW5mb3JtYXRpb24gYXQgaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uLyN1c2FnZS1vZi1oaXN0b3J5LXN0YXRlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbihjdXJyZW50U3RhdGUuY3VycmVudCwgY3VycmVudFN0YXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGFzc2lnbih7fSwgYnVpbGRTdGF0ZShjdXJyZW50TG9jYXRpb24udmFsdWUsIHRvLCBudWxsKSwgeyBwb3NpdGlvbjogY3VycmVudFN0YXRlLnBvc2l0aW9uICsgMSB9LCBkYXRhKTtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIGZhbHNlKTtcclxuICAgICAgICBjdXJyZW50TG9jYXRpb24udmFsdWUgPSB0bztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbG9jYXRpb246IGN1cnJlbnRMb2NhdGlvbixcclxuICAgICAgICBzdGF0ZTogaGlzdG9yeVN0YXRlLFxyXG4gICAgICAgIHB1c2gsXHJcbiAgICAgICAgcmVwbGFjZSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gSFRNTDUgaGlzdG9yeS4gTW9zdCBjb21tb24gaGlzdG9yeSBmb3Igc2luZ2xlIHBhZ2UgYXBwbGljYXRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFzZSAtXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJIaXN0b3J5KGJhc2UpIHtcclxuICAgIGJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xyXG4gICAgY29uc3QgaGlzdG9yeU5hdmlnYXRpb24gPSB1c2VIaXN0b3J5U3RhdGVOYXZpZ2F0aW9uKGJhc2UpO1xyXG4gICAgY29uc3QgaGlzdG9yeUxpc3RlbmVycyA9IHVzZUhpc3RvcnlMaXN0ZW5lcnMoYmFzZSwgaGlzdG9yeU5hdmlnYXRpb24uc3RhdGUsIGhpc3RvcnlOYXZpZ2F0aW9uLmxvY2F0aW9uLCBoaXN0b3J5TmF2aWdhdGlvbi5yZXBsYWNlKTtcclxuICAgIGZ1bmN0aW9uIGdvKGRlbHRhLCB0cmlnZ2VyTGlzdGVuZXJzID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghdHJpZ2dlckxpc3RlbmVycylcclxuICAgICAgICAgICAgaGlzdG9yeUxpc3RlbmVycy5wYXVzZUxpc3RlbmVycygpO1xyXG4gICAgICAgIGhpc3RvcnkuZ28oZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IGFzc2lnbih7XHJcbiAgICAgICAgLy8gaXQncyBvdmVycmlkZGVuIHJpZ2h0IGFmdGVyXHJcbiAgICAgICAgbG9jYXRpb246ICcnLFxyXG4gICAgICAgIGJhc2UsXHJcbiAgICAgICAgZ28sXHJcbiAgICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZi5iaW5kKG51bGwsIGJhc2UpLFxyXG4gICAgfSwgaGlzdG9yeU5hdmlnYXRpb24sIGhpc3RvcnlMaXN0ZW5lcnMpO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlckhpc3RvcnksICdsb2NhdGlvbicsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaGlzdG9yeU5hdmlnYXRpb24ubG9jYXRpb24udmFsdWUsXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnc3RhdGUnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGhpc3RvcnlOYXZpZ2F0aW9uLnN0YXRlLnZhbHVlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcm91dGVySGlzdG9yeTtcclxufVxuXG4vKipcclxuICogQ3JlYXRlcyBhIGluLW1lbW9yeSBiYXNlZCBoaXN0b3J5LiBUaGUgbWFpbiBwdXJwb3NlIG9mIHRoaXMgaGlzdG9yeSBpcyB0byBoYW5kbGUgU1NSLiBJdCBzdGFydHMgaW4gYSBzcGVjaWFsIGxvY2F0aW9uIHRoYXQgaXMgbm93aGVyZS5cclxuICogSXQncyB1cCB0byB0aGUgdXNlciB0byByZXBsYWNlIHRoYXQgbG9jYXRpb24gd2l0aCB0aGUgc3RhcnRlciBsb2NhdGlvbiBieSBlaXRoZXIgY2FsbGluZyBgcm91dGVyLnB1c2hgIG9yIGByb3V0ZXIucmVwbGFjZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYXNlIC0gQmFzZSBhcHBsaWVkIHRvIGFsbCB1cmxzLCBkZWZhdWx0cyB0byAnLydcclxuICogQHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIHJvdXRlciBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShiYXNlID0gJycpIHtcclxuICAgIGxldCBsaXN0ZW5lcnMgPSBbXTtcclxuICAgIGxldCBxdWV1ZSA9IFtTVEFSVF07XHJcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xyXG4gICAgYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XHJcbiAgICBmdW5jdGlvbiBzZXRMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gICAgICAgIHBvc2l0aW9uKys7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIGF0IHRoZSBlbmQsIHdlIGNhbiBzaW1wbHkgYXBwZW5kIGEgbmV3IGVudHJ5XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIGluIHRoZSBtaWRkbGUsIHdlIHJlbW92ZSBldmVyeXRoaW5nIGZyb20gaGVyZSBpbiB0aGUgcXVldWVcclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgcXVldWUucHVzaChsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdHJpZ2dlckxpc3RlbmVycyh0bywgZnJvbSwgeyBkaXJlY3Rpb24sIGRlbHRhIH0pIHtcclxuICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIGRlbHRhLFxyXG4gICAgICAgICAgICB0eXBlOiBOYXZpZ2F0aW9uVHlwZS5wb3AsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh0bywgZnJvbSwgaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IHtcclxuICAgICAgICAvLyByZXdyaXR0ZW4gYnkgT2JqZWN0LmRlZmluZVByb3BlcnR5XHJcbiAgICAgICAgbG9jYXRpb246IFNUQVJULFxyXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCBiZSBrZXB0IGluIHF1ZXVlXHJcbiAgICAgICAgc3RhdGU6IHt9LFxyXG4gICAgICAgIGJhc2UsXHJcbiAgICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZi5iaW5kKG51bGwsIGJhc2UpLFxyXG4gICAgICAgIHJlcGxhY2UodG8pIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgZW50cnkgYW5kIGRlY3JlbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UocG9zaXRpb24tLSwgMSk7XHJcbiAgICAgICAgICAgIHNldExvY2F0aW9uKHRvKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2godG8sIGRhdGEpIHtcclxuICAgICAgICAgICAgc2V0TG9jYXRpb24odG8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlzdGVuKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgcXVldWUgPSBbU1RBUlRdO1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnbyhkZWx0YSwgc2hvdWxkVHJpZ2dlciA9IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMubG9jYXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IFxyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgY29uc2lkZXJpbmcgZGVsdGEgPT09IDAgZ29pbmcgZm9yd2FyZCwgYnV0IGluIGFic3RyYWN0IG1vZGVcclxuICAgICAgICAgICAgLy8gdXNpbmcgMCBmb3IgdGhlIGRlbHRhIGRvZXNuJ3QgbWFrZSBzZW5zZSBsaWtlIGl0IGRvZXMgaW4gaHRtbDUgd2hlcmVcclxuICAgICAgICAgICAgLy8gaXQgcmVsb2FkcyB0aGUgcGFnZVxyXG4gICAgICAgICAgICBkZWx0YSA8IDAgPyBOYXZpZ2F0aW9uRGlyZWN0aW9uLmJhY2sgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLmZvcndhcmQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocG9zaXRpb24gKyBkZWx0YSwgcXVldWUubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckxpc3RlbmVycyh0aGlzLmxvY2F0aW9uLCBmcm9tLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnbG9jYXRpb24nLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlW3Bvc2l0aW9uXSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvdXRlckhpc3Rvcnk7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBoYXNoIGhpc3RvcnkuIFVzZWZ1bCBmb3Igd2ViIGFwcGxpY2F0aW9ucyB3aXRoIG5vIGhvc3QgKGUuZy5cclxuICogYGZpbGU6Ly9gKSBvciB3aGVuIGNvbmZpZ3VyaW5nIGEgc2VydmVyIHRvIGhhbmRsZSBhbnkgVVJMIGlzIG5vdCBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLSBvcHRpb25hbCBiYXNlIHRvIHByb3ZpZGUuIERlZmF1bHRzIHRvIGBsb2NhdGlvbi5wYXRobmFtZSArXHJcbiAqIGxvY2F0aW9uLnNlYXJjaGAgSWYgdGhlcmUgaXMgYSBgPGJhc2U+YCB0YWcgaW4gdGhlIGBoZWFkYCwgaXRzIHZhbHVlIHdpbGwgYmVcclxuICogaWdub3JlZCBpbiBmYXZvciBvZiB0aGlzIHBhcmFtZXRlciAqKmJ1dCBub3RlIGl0IGFmZmVjdHMgYWxsIHRoZVxyXG4gKiBoaXN0b3J5LnB1c2hTdGF0ZSgpIGNhbGxzKiosIG1lYW5pbmcgdGhhdCBpZiB5b3UgdXNlIGEgYDxiYXNlPmAgdGFnLCBpdCdzXHJcbiAqIGBocmVmYCB2YWx1ZSAqKmhhcyB0byBtYXRjaCB0aGlzIHBhcmFtZXRlcioqIChpZ25vcmluZyBhbnl0aGluZyBhZnRlciB0aGVcclxuICogYCNgKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogLy8gYXQgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXJcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIjYFxyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2ZvbGRlci8nKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIvI2BcclxuICogLy8gaWYgdGhlIGAjYCBpcyBwcm92aWRlZCBpbiB0aGUgYmFzZSwgaXQgd29uJ3QgYmUgYWRkZWQgYnkgYGNyZWF0ZVdlYkhhc2hIaXN0b3J5YFxyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2ZvbGRlci8jL2FwcC8nKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIvIy9hcHAvYFxyXG4gKiAvLyB5b3Ugc2hvdWxkIGF2b2lkIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCBjaGFuZ2VzIHRoZSBvcmlnaW5hbCB1cmwgYW5kIGJyZWFrcyBjb3B5aW5nIHVybHNcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoJy9vdGhlci1mb2xkZXIvJykgLy8gZ2l2ZXMgYSB1cmwgb2YgYGh0dHBzOi8vZXhhbXBsZS5jb20vb3RoZXItZm9sZGVyLyNgXHJcbiAqXHJcbiAqIC8vIGF0IGZpbGU6Ly8vdXNyL2V0Yy9mb2xkZXIvaW5kZXguaHRtbFxyXG4gKiAvLyBmb3IgbG9jYXRpb25zIHdpdGggbm8gYGhvc3RgLCB0aGUgYmFzZSBpcyBpZ25vcmVkXHJcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCcvaUFtSWdub3JlZCcpIC8vIGdpdmVzIGEgdXJsIG9mIGBmaWxlOi8vL3Vzci9ldGMvZm9sZGVyL2luZGV4Lmh0bWwjYFxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KGJhc2UpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGZpbmUgaW4gdGVybXMgb2YgZW5jb2RpbmcsIHNwZWNpYWxseSBmb3IgSUUxMVxyXG4gICAgLy8gZm9yIGBmaWxlOi8vYCwgZGlyZWN0bHkgdXNlIHRoZSBwYXRobmFtZSBhbmQgaWdub3JlIHRoZSBiYXNlXHJcbiAgICAvLyBsb2NhdGlvbi5wYXRobmFtZSBjb250YWlucyBhbiBpbml0aWFsIGAvYCBldmVuIGF0IHRoZSByb290OiBgaHR0cHM6Ly9leGFtcGxlLmNvbWBcclxuICAgIGJhc2UgPSBsb2NhdGlvbi5ob3N0ID8gYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA6ICcnO1xyXG4gICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcHJvdmlkZSBhIGAjYCBpbiB0aGUgbWlkZGxlOiBgL2Jhc2UvIy9hcHBgXHJcbiAgICBpZiAoIWJhc2UuaW5jbHVkZXMoJyMnKSlcclxuICAgICAgICBiYXNlICs9ICcjJztcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWJhc2UuZW5kc1dpdGgoJyMvJykgJiYgIWJhc2UuZW5kc1dpdGgoJyMnKSkge1xyXG4gICAgICAgIHdhcm4oYEEgaGFzaCBiYXNlIG11c3QgZW5kIHdpdGggYSBcIiNcIjpcXG5cIiR7YmFzZX1cIiBzaG91bGQgYmUgXCIke2Jhc2UucmVwbGFjZSgvIy4qJC8sICcjJyl9XCIuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlV2ViSGlzdG9yeShiYXNlKTtcclxufVxuXG5mdW5jdGlvbiBpc1JvdXRlTG9jYXRpb24ocm91dGUpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnIHx8IChyb3V0ZSAmJiB0eXBlb2Ygcm91dGUgPT09ICdvYmplY3QnKTtcclxufVxyXG5mdW5jdGlvbiBpc1JvdXRlTmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJztcclxufVxuXG4vKipcclxuICogSW5pdGlhbCByb3V0ZSBsb2NhdGlvbiB3aGVyZSB0aGUgcm91dGVyIGlzLiBDYW4gYmUgdXNlZCBpbiBuYXZpZ2F0aW9uIGd1YXJkc1xyXG4gKiB0byBkaWZmZXJlbnRpYXRlIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCB7IFNUQVJUX0xPQ0FUSU9OIH0gZnJvbSAndnVlLXJvdXRlcidcclxuICpcclxuICogcm91dGVyLmJlZm9yZUVhY2goKHRvLCBmcm9tKSA9PiB7XHJcbiAqICAgaWYgKGZyb20gPT09IFNUQVJUX0xPQ0FUSU9OKSB7XHJcbiAqICAgICAvLyBpbml0aWFsIG5hdmlnYXRpb25cclxuICogICB9XHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuY29uc3QgU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCA9IHtcclxuICAgIHBhdGg6ICcvJyxcclxuICAgIG5hbWU6IHVuZGVmaW5lZCxcclxuICAgIHBhcmFtczoge30sXHJcbiAgICBxdWVyeToge30sXHJcbiAgICBoYXNoOiAnJyxcclxuICAgIGZ1bGxQYXRoOiAnLycsXHJcbiAgICBtYXRjaGVkOiBbXSxcclxuICAgIG1ldGE6IHt9LFxyXG4gICAgcmVkaXJlY3RlZEZyb206IHVuZGVmaW5lZCxcclxufTtcblxuY29uc3QgTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2wgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ25hdmlnYXRpb24gZmFpbHVyZScgOiAnbmYnKTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIHdpdGggYWxsIHBvc3NpYmxlIHR5cGVzIGZvciBuYXZpZ2F0aW9uIGZhaWx1cmVzLiBDYW4gYmUgcGFzc2VkIHRvXHJcbiAqIHtAbGluayBpc05hdmlnYXRpb25GYWlsdXJlfSB0byBjaGVjayBmb3Igc3BlY2lmaWMgZmFpbHVyZXMuXHJcbiAqL1xyXG52YXIgTmF2aWdhdGlvbkZhaWx1cmVUeXBlO1xyXG4oZnVuY3Rpb24gKE5hdmlnYXRpb25GYWlsdXJlVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhYm9ydGVkIG5hdmlnYXRpb24gaXMgYSBuYXZpZ2F0aW9uIHRoYXQgZmFpbGVkIGJlY2F1c2UgYSBuYXZpZ2F0aW9uXHJcbiAgICAgKiBndWFyZCByZXR1cm5lZCBgZmFsc2VgIG9yIGNhbGxlZCBgbmV4dChmYWxzZSlgXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJhYm9ydGVkXCJdID0gNF0gPSBcImFib3J0ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBjYW5jZWxsZWQgbmF2aWdhdGlvbiBpcyBhIG5hdmlnYXRpb24gdGhhdCBmYWlsZWQgYmVjYXVzZSBhIG1vcmUgcmVjZW50XHJcbiAgICAgKiBuYXZpZ2F0aW9uIGZpbmlzaGVkIHN0YXJ0ZWQgKG5vdCBuZWNlc3NhcmlseSBmaW5pc2hlZCkuXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJjYW5jZWxsZWRcIl0gPSA4XSA9IFwiY2FuY2VsbGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIEEgZHVwbGljYXRlZCBuYXZpZ2F0aW9uIGlzIGEgbmF2aWdhdGlvbiB0aGF0IGZhaWxlZCBiZWNhdXNlIGl0IHdhc1xyXG4gICAgICogaW5pdGlhdGVkIHdoaWxlIGFscmVhZHkgYmVpbmcgYXQgdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJkdXBsaWNhdGVkXCJdID0gMTZdID0gXCJkdXBsaWNhdGVkXCI7XHJcbn0pKE5hdmlnYXRpb25GYWlsdXJlVHlwZSB8fCAoTmF2aWdhdGlvbkZhaWx1cmVUeXBlID0ge30pKTtcclxuLy8gREVWIG9ubHkgZGVidWcgbWVzc2FnZXNcclxuY29uc3QgRXJyb3JUeXBlTWVzc2FnZXMgPSB7XHJcbiAgICBbMSAvKiBNQVRDSEVSX05PVF9GT1VORCAqL10oeyBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uIH0pIHtcclxuICAgICAgICByZXR1cm4gYE5vIG1hdGNoIGZvclxcbiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0ke2N1cnJlbnRMb2NhdGlvblxyXG4gICAgICAgICAgICA/ICdcXG53aGlsZSBiZWluZyBhdFxcbicgKyBKU09OLnN0cmluZ2lmeShjdXJyZW50TG9jYXRpb24pXHJcbiAgICAgICAgICAgIDogJyd9YDtcclxuICAgIH0sXHJcbiAgICBbMiAvKiBOQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovXSh7IGZyb20sIHRvLCB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBSZWRpcmVjdGVkIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3N0cmluZ2lmeVJvdXRlKHRvKX1cIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLmA7XHJcbiAgICB9LFxyXG4gICAgWzQgLyogTkFWSUdBVElPTl9BQk9SVEVEICovXSh7IGZyb20sIHRvIH0pIHtcclxuICAgICAgICByZXR1cm4gYE5hdmlnYXRpb24gYWJvcnRlZCBmcm9tIFwiJHtmcm9tLmZ1bGxQYXRofVwiIHRvIFwiJHt0by5mdWxsUGF0aH1cIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLmA7XHJcbiAgICB9LFxyXG4gICAgWzggLyogTkFWSUdBVElPTl9DQU5DRUxMRUQgKi9dKHsgZnJvbSwgdG8gfSkge1xyXG4gICAgICAgIHJldHVybiBgTmF2aWdhdGlvbiBjYW5jZWxsZWQgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uLmA7XHJcbiAgICB9LFxyXG4gICAgWzE2IC8qIE5BVklHQVRJT05fRFVQTElDQVRFRCAqL10oeyBmcm9tLCB0byB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBBdm9pZGVkIHJlZHVuZGFudCBuYXZpZ2F0aW9uIHRvIGN1cnJlbnQgbG9jYXRpb246IFwiJHtmcm9tLmZ1bGxQYXRofVwiLmA7XHJcbiAgICB9LFxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJFcnJvcih0eXBlLCBwYXJhbXMpIHtcclxuICAgIC8vIGtlZXAgZnVsbCBlcnJvciBtZXNzYWdlcyBpbiBjanMgdmVyc2lvbnNcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcihFcnJvclR5cGVNZXNzYWdlc1t0eXBlXShwYXJhbXMpKSwge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBbTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2xdOiB0cnVlLFxyXG4gICAgICAgIH0sIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcigpLCB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIFtOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbF06IHRydWUsXHJcbiAgICAgICAgfSwgcGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcclxuICAgICAgICBOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbCBpbiBlcnJvciAmJlxyXG4gICAgICAgICh0eXBlID09IG51bGwgfHwgISEoZXJyb3IudHlwZSAmIHR5cGUpKSk7XHJcbn1cclxuY29uc3QgcHJvcGVydGllc1RvTG9nID0gWydwYXJhbXMnLCAncXVlcnknLCAnaGFzaCddO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlSb3V0ZSh0bykge1xyXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgaWYgKCdwYXRoJyBpbiB0bylcclxuICAgICAgICByZXR1cm4gdG8ucGF0aDtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0aWVzVG9Mb2cpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRvKVxyXG4gICAgICAgICAgICBsb2NhdGlvbltrZXldID0gdG9ba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhdGlvbiwgbnVsbCwgMik7XHJcbn1cblxuLy8gZGVmYXVsdCBwYXR0ZXJuIGZvciBhIHBhcmFtOiBub24gZ3JlZWR5IGV2ZXJ5dGhpbmcgYnV0IC9cclxuY29uc3QgQkFTRV9QQVJBTV9QQVRURVJOID0gJ1teL10rPyc7XHJcbmNvbnN0IEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUyA9IHtcclxuICAgIHNlbnNpdGl2ZTogZmFsc2UsXHJcbiAgICBzdHJpY3Q6IGZhbHNlLFxyXG4gICAgc3RhcnQ6IHRydWUsXHJcbiAgICBlbmQ6IHRydWUsXHJcbn07XHJcbi8vIFNwZWNpYWwgUmVnZXggY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZCBpbiBzdGF0aWMgdG9rZW5zXHJcbmNvbnN0IFJFR0VYX0NIQVJTX1JFID0gL1suKyo/XiR7fSgpW1xcXS9cXFxcXS9nO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHBhdGggcGFyc2VyIGZyb20gYW4gYXJyYXkgb2YgU2VnbWVudHMgKGEgc2VnbWVudCBpcyBhbiBhcnJheSBvZiBUb2tlbnMpXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWdtZW50cyAtIGFycmF5IG9mIHNlZ21lbnRzIHJldHVybmVkIGJ5IHRva2VuaXplUGF0aFxyXG4gKiBAcGFyYW0gZXh0cmFPcHRpb25zIC0gb3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlZ2V4cFxyXG4gKiBAcmV0dXJucyBhIFBhdGhQYXJzZXJcclxuICovXHJcbmZ1bmN0aW9uIHRva2Vuc1RvUGFyc2VyKHNlZ21lbnRzLCBleHRyYU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NpZ24oe30sIEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUywgZXh0cmFPcHRpb25zKTtcclxuICAgIC8vIHRoZSBhbW91bnQgb2Ygc2NvcmVzIGlzIHRoZSBzYW1lIGFzIHRoZSBsZW5ndGggb2Ygc2VnbWVudHMgZXhjZXB0IGZvciB0aGUgcm9vdCBzZWdtZW50IFwiL1wiXHJcbiAgICBjb25zdCBzY29yZSA9IFtdO1xyXG4gICAgLy8gdGhlIHJlZ2V4cCBhcyBhIHN0cmluZ1xyXG4gICAgbGV0IHBhdHRlcm4gPSBvcHRpb25zLnN0YXJ0ID8gJ14nIDogJyc7XHJcbiAgICAvLyBleHRyYWN0ZWQga2V5c1xyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XHJcbiAgICAgICAgLy8gdGhlIHJvb3Qgc2VnbWVudCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTY29yZXMgPSBzZWdtZW50Lmxlbmd0aCA/IFtdIDogWzkwIC8qIFJvb3QgKi9dO1xyXG4gICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIHNsYXNoXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0ICYmICFzZWdtZW50Lmxlbmd0aClcclxuICAgICAgICAgICAgcGF0dGVybiArPSAnLyc7XHJcbiAgICAgICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBzZWdtZW50Lmxlbmd0aDsgdG9rZW5JbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gc2VnbWVudFt0b2tlbkluZGV4XTtcclxuICAgICAgICAgICAgLy8gcmVzZXRzIHRoZSBzY29yZSBpZiB3ZSBhcmUgaW5zaWRlIGEgc3ViIHNlZ21lbnQgLzphLW90aGVyLTpiXHJcbiAgICAgICAgICAgIGxldCBzdWJTZWdtZW50U2NvcmUgPSA0MCAvKiBTZWdtZW50ICovICtcclxuICAgICAgICAgICAgICAgIChvcHRpb25zLnNlbnNpdGl2ZSA/IDAuMjUgLyogQm9udXNDYXNlU2Vuc2l0aXZlICovIDogMCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAwIC8qIFN0YXRpYyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgc2xhc2ggaWYgd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5JbmRleClcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9ICcvJztcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gdG9rZW4udmFsdWUucmVwbGFjZShSRUdFWF9DSEFSU19SRSwgJ1xcXFwkJicpO1xyXG4gICAgICAgICAgICAgICAgc3ViU2VnbWVudFNjb3JlICs9IDQwIC8qIFN0YXRpYyAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAxIC8qIFBhcmFtICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCByZXBlYXRhYmxlLCBvcHRpb25hbCwgcmVnZXhwIH0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0YWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmUgPSByZWdleHAgPyByZWdleHAgOiBCQVNFX1BBUkFNX1BBVFRFUk47XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBwcm92aWRlZCBhIGN1c3RvbSByZWdleHAgLzppZChcXFxcZCspXHJcbiAgICAgICAgICAgICAgICBpZiAocmUgIT09IEJBU0VfUEFSQU1fUEFUVEVSTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAxMCAvKiBCb251c0N1c3RvbVJlZ0V4cCAqLztcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHJlZ2V4cCBpcyB2YWxpZCBiZWZvcmUgdXNpbmcgaXRcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKGAoJHtyZX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGN1c3RvbSBSZWdFeHAgZm9yIHBhcmFtIFwiJHt2YWx1ZX1cIiAoJHtyZX0pOiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIHJlcGVhdCB3ZSBtdXN0IHRha2UgY2FyZSBvZiB0aGUgcmVwZWF0aW5nIGxlYWRpbmcgc2xhc2hcclxuICAgICAgICAgICAgICAgIGxldCBzdWJQYXR0ZXJuID0gcmVwZWF0YWJsZSA/IGAoKD86JHtyZX0pKD86Lyg/OiR7cmV9KSkqKWAgOiBgKCR7cmV9KWA7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBzbGFzaCBpZiB3ZSBhcmUgc3RhcnRpbmcgYSBuZXcgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdHRlcm4gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCBhbiBvcHRpb25hbCAvIGlmIHRoZXJlIGFyZSBtb3JlIHNlZ21lbnRzIGUuZy4gLzpwPy1zdGF0aWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgLzpwPy06cDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwgJiYgc2VnbWVudC5sZW5ndGggPCAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAoPzovJHtzdWJQYXR0ZXJufSlgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcvJyArIHN1YlBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViUGF0dGVybiArPSAnPyc7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN1YlBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gMjAgLyogRHluYW1pYyAqLztcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcclxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gLTggLyogQm9udXNPcHRpb25hbCAqLztcclxuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtMjAgLyogQm9udXNSZXBlYXRhYmxlICovO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlID09PSAnLionKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSAtNTAgLyogQm9udXNXaWxkY2FyZCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50U2NvcmVzLnB1c2goc3ViU2VnbWVudFNjb3JlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gZW1wdHkgYXJyYXkgbGlrZSAvaG9tZS8gLT4gW1t7aG9tZX1dLCBbXV1cclxuICAgICAgICAvLyBpZiAoIXNlZ21lbnQubGVuZ3RoKSBwYXR0ZXJuICs9ICcvJ1xyXG4gICAgICAgIHNjb3JlLnB1c2goc2VnbWVudFNjb3Jlcyk7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzdHJpY3QgYm9udXMgdG8gdGhlIGxhc3Qgc2NvcmVcclxuICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiBvcHRpb25zLmVuZCkge1xyXG4gICAgICAgIGNvbnN0IGkgPSBzY29yZS5sZW5ndGggLSAxO1xyXG4gICAgICAgIHNjb3JlW2ldW3Njb3JlW2ldLmxlbmd0aCAtIDFdICs9IDAuNzAwMDAwMDAwMDAwMDAwMSAvKiBCb251c1N0cmljdCAqLztcclxuICAgIH1cclxuICAgIC8vIFRPRE86IGRldiBvbmx5IHdhcm4gZG91YmxlIHRyYWlsaW5nIHNsYXNoXHJcbiAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KVxyXG4gICAgICAgIHBhdHRlcm4gKz0gJy8/JztcclxuICAgIGlmIChvcHRpb25zLmVuZClcclxuICAgICAgICBwYXR0ZXJuICs9ICckJztcclxuICAgIC8vIGFsbG93IHBhdGhzIGxpa2UgL2R5bmFtaWMgdG8gb25seSBtYXRjaCBkeW5hbWljIG9yIGR5bmFtaWMvLi4uIGJ1dCBub3QgZHluYW1pY19zb21ldGhpbmdfZWxzZVxyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5zdHJpY3QpXHJcbiAgICAgICAgcGF0dGVybiArPSAnKD86L3wkKSc7XHJcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJyk7XHJcbiAgICBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXRoLm1hdGNoKHJlKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcclxuICAgICAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaV0gfHwgJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaSAtIDFdO1xyXG4gICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsdWUgJiYga2V5LnJlcGVhdGFibGUgPyB2YWx1ZS5zcGxpdCgnLycpIDogdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkocGFyYW1zKSB7XHJcbiAgICAgICAgbGV0IHBhdGggPSAnJztcclxuICAgICAgICAvLyBmb3Igb3B0aW9uYWwgcGFyYW1ldGVycyB0byBhbGxvdyB0byBiZSBlbXB0eVxyXG4gICAgICAgIGxldCBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgICAgICAgICBpZiAoIWF2b2lkRHVwbGljYXRlZFNsYXNoIHx8ICFwYXRoLmVuZHNXaXRoKCcvJykpXHJcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJztcclxuICAgICAgICAgICAgYXZvaWREdXBsaWNhdGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBTdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMSAvKiBQYXJhbSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIHJlcGVhdGFibGUsIG9wdGlvbmFsIH0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbSA9IHZhbHVlIGluIHBhcmFtcyA/IHBhcmFtc1t2YWx1ZV0gOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgIXJlcGVhdGFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgcGFyYW0gXCIke3ZhbHVlfVwiIGlzIGFuIGFycmF5IGJ1dCBpdCBpcyBub3QgcmVwZWF0YWJsZSAoKiBvciArIG1vZGlmaWVycylgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gQXJyYXkuaXNBcnJheShwYXJhbSkgPyBwYXJhbS5qb2luKCcvJykgOiBwYXJhbTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgb3B0aW9uYWwgcGFyYW0gbGlrZSAvOmE/LXN0YXRpYyBhbmQgdGhlcmUgYXJlIG1vcmUgc2VnbWVudHMsIHdlIGRvbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhcmUgYWJvdXQgdGhlIG9wdGlvbmFsIHBhcmFtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPCAyICYmIHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxhc3Qgc2xhc2ggYXMgd2UgY291bGQgYmUgYXQgdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXBwZW5kIGEgc2xhc2ggb24gdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtIFwiJHt2YWx1ZX1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlLFxyXG4gICAgICAgIHNjb3JlLFxyXG4gICAgICAgIGtleXMsXHJcbiAgICAgICAgcGFyc2UsXHJcbiAgICAgICAgc3RyaW5naWZ5LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgYW4gYXJyYXkgb2YgbnVtYmVycyBhcyB1c2VkIGluIFBhdGhQYXJzZXIuc2NvcmUgYW5kIHJldHVybnMgYVxyXG4gKiBudW1iZXIuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYHNvcnRgIGFuIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3QgYXJyYXkgb2YgbnVtYmVyc1xyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCBhcnJheSBvZiBudW1iZXJzXHJcbiAqIEByZXR1cm5zIDAgaWYgYm90aCBhcmUgZXF1YWwsIDwgMCBpZiBhIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QsID4gMCBpZiBiXHJcbiAqIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3RcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVTY29yZUFycmF5KGEsIGIpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGJbaV0gLSBhW2ldO1xyXG4gICAgICAgIC8vIG9ubHkga2VlcCBnb2luZyBpZiBkaWZmID09PSAwXHJcbiAgICAgICAgaWYgKGRpZmYpXHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIC8vIGlmIHRoZSBsYXN0IHN1YnNlZ21lbnQgd2FzIFN0YXRpYywgdGhlIHNob3J0ZXIgc2VnbWVudHMgc2hvdWxkIGJlIHNvcnRlZCBmaXJzdFxyXG4gICAgLy8gb3RoZXJ3aXNlIHNvcnQgdGhlIGxvbmdlc3Qgc2VnbWVudCBmaXJzdFxyXG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA9PT0gNDAgLyogU3RhdGljICovICsgNDAgLyogU2VnbWVudCAqL1xyXG4gICAgICAgICAgICA/IC0xXHJcbiAgICAgICAgICAgIDogMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggPT09IDEgJiYgYlswXSA9PT0gNDAgLyogU3RhdGljICovICsgNDAgLyogU2VnbWVudCAqL1xyXG4gICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgOiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgc29ydGAgdG8gc29ydCBhbiBhcnJheSBvZiBQYXRoUGFyc2VyXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3QgUGF0aFBhcnNlclxyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCBQYXRoUGFyc2VyXHJcbiAqIEByZXR1cm5zIDAgaWYgYm90aCBhcmUgZXF1YWwsIDwgMCBpZiBhIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QsID4gMCBpZiBiXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlUGF0aFBhcnNlclNjb3JlKGEsIGIpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IGFTY29yZSA9IGEuc2NvcmU7XHJcbiAgICBjb25zdCBiU2NvcmUgPSBiLnNjb3JlO1xyXG4gICAgd2hpbGUgKGkgPCBhU2NvcmUubGVuZ3RoICYmIGkgPCBiU2NvcmUubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVTY29yZUFycmF5KGFTY29yZVtpXSwgYlNjb3JlW2ldKTtcclxuICAgICAgICAvLyBkbyBub3QgcmV0dXJuIGlmIGJvdGggYXJlIGVxdWFsXHJcbiAgICAgICAgaWYgKGNvbXApXHJcbiAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIC8vIGlmIGEgYW5kIGIgc2hhcmUgdGhlIHNhbWUgc2NvcmUgZW50cmllcyBidXQgYiBoYXMgbW9yZSwgc29ydCBiIGZpcnN0XHJcbiAgICByZXR1cm4gYlNjb3JlLmxlbmd0aCAtIGFTY29yZS5sZW5ndGg7XHJcbiAgICAvLyB0aGlzIGlzIHRoZSB0ZXJuYXJ5IHZlcnNpb25cclxuICAgIC8vIHJldHVybiBhU2NvcmUubGVuZ3RoIDwgYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IDFcclxuICAgIC8vICAgOiBhU2NvcmUubGVuZ3RoID4gYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IC0xXHJcbiAgICAvLyAgIDogMFxyXG59XG5cbmNvbnN0IFJPT1RfVE9LRU4gPSB7XHJcbiAgICB0eXBlOiAwIC8qIFN0YXRpYyAqLyxcclxuICAgIHZhbHVlOiAnJyxcclxufTtcclxuY29uc3QgVkFMSURfUEFSQU1fUkUgPSAvW2EtekEtWjAtOV9dLztcclxuLy8gQWZ0ZXIgc29tZSBwcm9maWxpbmcsIHRoZSBjYWNoZSBzZWVtcyB0byBiZSB1bm5lY2Vzc2FyeSBiZWNhdXNlIHRva2VuaXplUGF0aFxyXG4vLyAodGhlIHNsb3dlc3QgcGFydCBvZiBhZGRpbmcgYSByb3V0ZSkgaXMgdmVyeSBmYXN0XHJcbi8vIGNvbnN0IHRva2VuQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgVG9rZW5bXVtdPigpXHJcbmZ1bmN0aW9uIHRva2VuaXplUGF0aChwYXRoKSB7XHJcbiAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgcmV0dXJuIFtbXV07XHJcbiAgICBpZiAocGF0aCA9PT0gJy8nKVxyXG4gICAgICAgIHJldHVybiBbW1JPT1RfVE9LRU5dXTtcclxuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gYFJvdXRlIHBhdGhzIHNob3VsZCBzdGFydCB3aXRoIGEgXCIvXCI6IFwiJHtwYXRofVwiIHNob3VsZCBiZSBcIi8ke3BhdGh9XCIuYFxyXG4gICAgICAgICAgICA6IGBJbnZhbGlkIHBhdGggXCIke3BhdGh9XCJgKTtcclxuICAgIH1cclxuICAgIC8vIGlmICh0b2tlbkNhY2hlLmhhcyhwYXRoKSkgcmV0dXJuIHRva2VuQ2FjaGUuZ2V0KHBhdGgpIVxyXG4gICAgZnVuY3Rpb24gY3Jhc2gobWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRVJSICgke3N0YXRlfSkvXCIke2J1ZmZlcn1cIjogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0YXRlID0gMCAvKiBTdGF0aWMgKi87XHJcbiAgICBsZXQgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xyXG4gICAgY29uc3QgdG9rZW5zID0gW107XHJcbiAgICAvLyB0aGUgc2VnbWVudCB3aWxsIGFsd2F5cyBiZSB2YWxpZCBiZWNhdXNlIHdlIGdldCBpbnRvIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICAvLyB3aXRoIHRoZSBsZWFkaW5nIC9cclxuICAgIGxldCBzZWdtZW50O1xyXG4gICAgZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KCkge1xyXG4gICAgICAgIGlmIChzZWdtZW50KVxyXG4gICAgICAgICAgICB0b2tlbnMucHVzaChzZWdtZW50KTtcclxuICAgICAgICBzZWdtZW50ID0gW107XHJcbiAgICB9XHJcbiAgICAvLyBpbmRleCBvbiB0aGUgcGF0aFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgLy8gY2hhciBhdCBpbmRleFxyXG4gICAgbGV0IGNoYXI7XHJcbiAgICAvLyBidWZmZXIgb2YgdGhlIHZhbHVlIHJlYWRcclxuICAgIGxldCBidWZmZXIgPSAnJztcclxuICAgIC8vIGN1c3RvbSByZWdleHAgZm9yIGEgcGFyYW1cclxuICAgIGxldCBjdXN0b21SZSA9ICcnO1xyXG4gICAgZnVuY3Rpb24gY29uc3VtZUJ1ZmZlcigpIHtcclxuICAgICAgICBpZiAoIWJ1ZmZlcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBTdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogU3RhdGljICovLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAxIC8qIFBhcmFtICovIHx8XHJcbiAgICAgICAgICAgIHN0YXRlID09PSAyIC8qIFBhcmFtUmVnRXhwICovIHx8XHJcbiAgICAgICAgICAgIHN0YXRlID09PSAzIC8qIFBhcmFtUmVnRXhwRW5kICovKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEgJiYgKGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycpKVxyXG4gICAgICAgICAgICAgICAgY3Jhc2goYEEgcmVwZWF0YWJsZSBwYXJhbSAoJHtidWZmZXJ9KSBtdXN0IGJlIGFsb25lIGluIGl0cyBzZWdtZW50LiBlZzogJy86aWRzKy5gKTtcclxuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogUGFyYW0gKi8sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjdXN0b21SZSxcclxuICAgICAgICAgICAgICAgIHJlcGVhdGFibGU6IGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICc/JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjcmFzaCgnSW52YWxpZCBzdGF0ZSB0byBjb25zdW1lIGJ1ZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIgPSAnJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZENoYXJUb0J1ZmZlcigpIHtcclxuICAgICAgICBidWZmZXIgKz0gY2hhcjtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICBjaGFyID0gcGF0aFtpKytdO1xyXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcgJiYgc3RhdGUgIT09IDIgLyogUGFyYW1SZWdFeHAgKi8pIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBzdGF0ZSA9IDQgLyogRXNjYXBlTmV4dCAqLztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFN0YXRpYyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFBhcmFtICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhclRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0IC8qIEVzY2FwZU5leHQgKi86XHJcbiAgICAgICAgICAgICAgICBhZGRDaGFyVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUGFyYW0gKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyIC8qIFBhcmFtUmVnRXhwICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoVkFMSURfUEFSQU1fUkUudGVzdChjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXJUb0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMCAvKiBTdGF0aWMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnKicgJiYgY2hhciAhPT0gJz8nICYmIGNoYXIgIT09ICcrJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBQYXJhbVJlZ0V4cCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIGl0IHdvcnRoIGhhbmRsaW5nIG5lc3RlZCByZWdleHA/IGxpa2UgOnAoPzpwcmVmaXhfKFteL10rKV9zdWZmaXgpXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBhbHJlYWR5IHdvcmtzIGJ5IGVzY2FwaW5nIHRoZSBjbG9zaW5nIClcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcGF0aHMuZXNtLmRldi8/cD1BQU1lSmJpQXdRRWNES2JBb0FBa1A2MFBHMlI2UUF2Z05hQTZBRkFDTTJBQnVRQkIjXHJcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHJlYWxseSBzb21ldGhpbmcgcGVvcGxlIG5lZWQgc2luY2UgeW91IGNhbiBhbHNvIHdyaXRlXHJcbiAgICAgICAgICAgICAgICAvLyAvcHJlZml4XzpwKClfc3VmZml4XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBlc2NhcGVkIClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUmVbY3VzdG9tUmUubGVuZ3RoIC0gMV0gPT0gJ1xcXFwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSA9IGN1c3RvbVJlLnNsaWNlKDAsIC0xKSArIGNoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogUGFyYW1SZWdFeHBFbmQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSArPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQYXJhbVJlZ0V4cEVuZCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgZmluYWxpemluZyBhIHBhcmFtXHJcbiAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogU3RhdGljICovO1xyXG4gICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcqJyAmJiBjaGFyICE9PSAnPycgJiYgY2hhciAhPT0gJysnKVxyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbVJlID0gJyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNyYXNoKCdVbmtub3duIHN0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdGUgPT09IDIgLyogUGFyYW1SZWdFeHAgKi8pXHJcbiAgICAgICAgY3Jhc2goYFVuZmluaXNoZWQgY3VzdG9tIFJlZ0V4cCBmb3IgcGFyYW0gXCIke2J1ZmZlcn1cImApO1xyXG4gICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAvLyB0b2tlbkNhY2hlLnNldChwYXRoLCB0b2tlbnMpXHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlUmVjb3JkTWF0Y2hlcihyZWNvcmQsIHBhcmVudCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcGFyc2VyID0gdG9rZW5zVG9QYXJzZXIodG9rZW5pemVQYXRoKHJlY29yZC5wYXRoKSwgb3B0aW9ucyk7XHJcbiAgICAvLyB3YXJuIGFnYWluc3QgcGFyYW1zIHdpdGggdGhlIHNhbWUgbmFtZVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJzZXIua2V5cykge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdLZXlzLmhhcyhrZXkubmFtZSkpXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBGb3VuZCBkdXBsaWNhdGVkIHBhcmFtcyB3aXRoIG5hbWUgXCIke2tleS5uYW1lfVwiIGZvciBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIi4gT25seSB0aGUgbGFzdCBvbmUgd2lsbCBiZSBhdmFpbGFibGUgb24gXCIkcm91dGUucGFyYW1zXCIuYCk7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nS2V5cy5hZGQoa2V5Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoZXIgPSBhc3NpZ24ocGFyc2VyLCB7XHJcbiAgICAgICAgcmVjb3JkLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICAvLyB0aGVzZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYnkgdGhlIHBhcmVudFxyXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICBhbGlhczogW10sXHJcbiAgICB9KTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAvLyBib3RoIGFyZSBhbGlhc2VzIG9yIGJvdGggYXJlIG5vdCBhbGlhc2VzXHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtaXggdGhlbSBiZWNhdXNlIHRoZSBvcmRlciBpcyB1c2VkIHdoZW5cclxuICAgICAgICAvLyBwYXNzaW5nIG9yaWdpbmFsUmVjb3JkIGluIE1hdGNoZXIuYWRkUm91dGVcclxuICAgICAgICBpZiAoIW1hdGNoZXIucmVjb3JkLmFsaWFzT2YgPT09ICFwYXJlbnQucmVjb3JkLmFsaWFzT2YpXHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG1hdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZXI7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBSb3V0ZXIgTWF0Y2hlci5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSByb3V0ZXMgLSBhcnJheSBvZiBpbml0aWFsIHJvdXRlc1xyXG4gKiBAcGFyYW0gZ2xvYmFsT3B0aW9ucyAtIGdsb2JhbCByb3V0ZSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJNYXRjaGVyKHJvdXRlcywgZ2xvYmFsT3B0aW9ucykge1xyXG4gICAgLy8gbm9ybWFsaXplZCBvcmRlcmVkIGFycmF5IG9mIG1hdGNoZXJzXHJcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xyXG4gICAgY29uc3QgbWF0Y2hlck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGdsb2JhbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoeyBzdHJpY3Q6IGZhbHNlLCBlbmQ6IHRydWUsIHNlbnNpdGl2ZTogZmFsc2UgfSwgZ2xvYmFsT3B0aW9ucyk7XHJcbiAgICBmdW5jdGlvbiBnZXRSZWNvcmRNYXRjaGVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlck1hcC5nZXQobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRSb3V0ZShyZWNvcmQsIHBhcmVudCwgb3JpZ2luYWxSZWNvcmQpIHtcclxuICAgICAgICAvLyB1c2VkIGxhdGVyIG9uIHRvIHJlbW92ZSBieSBuYW1lXHJcbiAgICAgICAgY29uc3QgaXNSb290QWRkID0gIW9yaWdpbmFsUmVjb3JkO1xyXG4gICAgICAgIGNvbnN0IG1haW5Ob3JtYWxpemVkUmVjb3JkID0gbm9ybWFsaXplUm91dGVSZWNvcmQocmVjb3JkKTtcclxuICAgICAgICAvLyB3ZSBtaWdodCBiZSB0aGUgY2hpbGQgb2YgYW4gYWxpYXNcclxuICAgICAgICBtYWluTm9ybWFsaXplZFJlY29yZC5hbGlhc09mID0gb3JpZ2luYWxSZWNvcmQgJiYgb3JpZ2luYWxSZWNvcmQucmVjb3JkO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoZ2xvYmFsT3B0aW9ucywgcmVjb3JkKTtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBhbiBhcnJheSBvZiByZWNvcmRzIHRvIGNvcnJlY3RseSBoYW5kbGUgYWxpYXNlc1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWNvcmRzID0gW1xyXG4gICAgICAgICAgICBtYWluTm9ybWFsaXplZFJlY29yZCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmICgnYWxpYXMnIGluIHJlY29yZCkge1xyXG4gICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gdHlwZW9mIHJlY29yZC5hbGlhcyA9PT0gJ3N0cmluZycgPyBbcmVjb3JkLmFsaWFzXSA6IHJlY29yZC5hbGlhcztcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUmVjb3Jkcy5wdXNoKGFzc2lnbih7fSwgbWFpbk5vcm1hbGl6ZWRSZWNvcmQsIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyB1cyB0byBob2xkIGEgY29weSBvZiB0aGUgYGNvbXBvbmVudHNgIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgYXN5bmMgY29tcG9uZW50cyBjYWNoZSBpcyBob2xkIG9uIHRoZSBvcmlnaW5hbCByZWNvcmRcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvcmlnaW5hbFJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsUmVjb3JkLnJlY29yZC5jb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWFpbk5vcm1hbGl6ZWRSZWNvcmQuY29tcG9uZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBhbGlhcyxcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBiZSB0aGUgY2hpbGQgb2YgYW4gYWxpYXNcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc09mOiBvcmlnaW5hbFJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsUmVjb3JkLnJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1haW5Ob3JtYWxpemVkUmVjb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhbGlhc2VzIGFyZSBhbHdheXMgb2YgdGhlIHNhbWUga2luZCBhcyB0aGUgb3JpZ2luYWwgc2luY2UgdGhleVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIHJlY29yZFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaGVyO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbE1hdGNoZXI7XHJcbiAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkUmVjb3JkIG9mIG5vcm1hbGl6ZWRSZWNvcmRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gbm9ybWFsaXplZFJlY29yZDtcclxuICAgICAgICAgICAgLy8gQnVpbGQgdXAgdGhlIHBhdGggZm9yIG5lc3RlZCByb3V0ZXMgaWYgdGhlIGNoaWxkIGlzbid0IGFuIGFic29sdXRlXHJcbiAgICAgICAgICAgIC8vIHJvdXRlLiBPbmx5IGFkZCB0aGUgLyBkZWxpbWl0ZXIgaWYgdGhlIGNoaWxkIHBhdGggaXNuJ3QgZW1wdHkgYW5kIGlmIHRoZVxyXG4gICAgICAgICAgICAvLyBwYXJlbnQgcGF0aCBkb2Vzbid0IGhhdmUgYSB0cmFpbGluZyBzbGFzaFxyXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhcmVudC5yZWNvcmQucGF0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdTbGFzaCA9IHBhcmVudFBhdGhbcGFyZW50UGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJycgOiAnLyc7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUmVjb3JkLnBhdGggPVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZWNvcmQucGF0aCArIChwYXRoICYmIGNvbm5lY3RpbmdTbGFzaCArIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbm9ybWFsaXplZFJlY29yZC5wYXRoID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2F0Y2ggYWxsIHJvdXRlcyAoXCIqXCIpIG11c3Qgbm93IGJlIGRlZmluZWQgdXNpbmcgYSBwYXJhbSB3aXRoIGEgY3VzdG9tIHJlZ2V4cC5cXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAnU2VlIG1vcmUgYXQgaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uLyNyZW1vdmVkLXN0YXItb3ItY2F0Y2gtYWxsLXJvdXRlcy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIG9iamVjdCBiZWZvcmUgaGFuZCBzbyBpdCBjYW4gYmUgcGFzc2VkIHRvIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIG1hdGNoZXIgPSBjcmVhdGVSb3V0ZVJlY29yZE1hdGNoZXIobm9ybWFsaXplZFJlY29yZCwgcGFyZW50LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnQgJiYgcGF0aFswXSA9PT0gJy8nKVxyXG4gICAgICAgICAgICAgICAgY2hlY2tNaXNzaW5nUGFyYW1zSW5BYnNvbHV0ZVBhdGgobWF0Y2hlciwgcGFyZW50KTtcclxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGFuIGFsaWFzIHdlIG11c3QgdGVsbCB0aGUgb3JpZ2luYWwgcmVjb3JkIHRoYXQgd2UgZXhpc3RcclxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFJlY29yZC5hbGlhcy5wdXNoKG1hdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2FtZVBhcmFtcyhvcmlnaW5hbFJlY29yZCwgbWF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBmaXJzdCByZWNvcmQgaXMgdGhlIG9yaWdpbmFsIGFuZCBvdGhlcnMgYXJlIGFsaWFzZXNcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF0Y2hlciA9IG9yaWdpbmFsTWF0Y2hlciB8fCBtYXRjaGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTWF0Y2hlciAhPT0gbWF0Y2hlcilcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE1hdGNoZXIuYWxpYXMucHVzaChtYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcm91dGUgaWYgbmFtZWQgYW5kIG9ubHkgZm9yIHRoZSB0b3AgcmVjb3JkIChhdm9pZCBpbiBuZXN0ZWQgY2FsbHMpXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdvcmtzIGJlY2F1c2UgdGhlIG9yaWdpbmFsIHJlY29yZCBpcyB0aGUgZmlyc3Qgb25lXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSb290QWRkICYmIHJlY29yZC5uYW1lICYmICFpc0FsaWFzUmVjb3JkKG1hdGNoZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJvdXRlKHJlY29yZC5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJ2NoaWxkcmVuJyBpbiBtYWluTm9ybWFsaXplZFJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBtYWluTm9ybWFsaXplZFJlY29yZC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRSb3V0ZShjaGlsZHJlbltpXSwgbWF0Y2hlciwgb3JpZ2luYWxSZWNvcmQgJiYgb3JpZ2luYWxSZWNvcmQuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBvcmlnaW5hbCByZWNvcmQsIHRoZW4gdGhlIGZpcnN0IG9uZSB3YXMgbm90IGFuIGFsaWFzIGFuZCBhbGxcclxuICAgICAgICAgICAgLy8gb3RoZXIgYWxpYXMgKGlmIGFueSkgbmVlZCB0byByZWZlcmVuY2UgdGhpcyByZWNvcmQgd2hlbiBhZGRpbmcgY2hpbGRyZW5cclxuICAgICAgICAgICAgb3JpZ2luYWxSZWNvcmQgPSBvcmlnaW5hbFJlY29yZCB8fCBtYXRjaGVyO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgbm9ybWFsaXplZCByZWNvcmRzIGZvciBtb3JlIGZsZXhpYmlsaXR5XHJcbiAgICAgICAgICAgIC8vIGlmIChwYXJlbnQgJiYgaXNBbGlhc1JlY29yZChvcmlnaW5hbFJlY29yZCkpIHtcclxuICAgICAgICAgICAgLy8gICBwYXJlbnQuY2hpbGRyZW4ucHVzaChvcmlnaW5hbFJlY29yZClcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICBpbnNlcnRNYXRjaGVyKG1hdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNYXRjaGVyXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2Ugb3RoZXIgbWF0Y2hlcnMgYXJlIGFsaWFzZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgYnkgdGhlIG9yaWdpbmFsIG1hdGNoZXJcclxuICAgICAgICAgICAgICAgIHJlbW92ZVJvdXRlKG9yaWdpbmFsTWF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlUm91dGUobWF0Y2hlclJlZikge1xyXG4gICAgICAgIGlmIChpc1JvdXRlTmFtZShtYXRjaGVyUmVmKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gbWF0Y2hlck1hcC5nZXQobWF0Y2hlclJlZik7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyTWFwLmRlbGV0ZShtYXRjaGVyUmVmKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXJzLnNwbGljZShtYXRjaGVycy5pbmRleE9mKG1hdGNoZXIpLCAxKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXIuY2hpbGRyZW4uZm9yRWFjaChyZW1vdmVSb3V0ZSk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmFsaWFzLmZvckVhY2gocmVtb3ZlUm91dGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1hdGNoZXJzLmluZGV4T2YobWF0Y2hlclJlZik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXJSZWYucmVjb3JkLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck1hcC5kZWxldGUobWF0Y2hlclJlZi5yZWNvcmQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyUmVmLmNoaWxkcmVuLmZvckVhY2gocmVtb3ZlUm91dGUpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlclJlZi5hbGlhcy5mb3JFYWNoKHJlbW92ZVJvdXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJvdXRlcygpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnNlcnRNYXRjaGVyKG1hdGNoZXIpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXRjaGVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgY29tcGFyZVBhdGhQYXJzZXJTY29yZShtYXRjaGVyLCBtYXRjaGVyc1tpXSkgPj0gMCAmJlxyXG4gICAgICAgICAgICAvLyBBZGRpbmcgY2hpbGRyZW4gd2l0aCBlbXB0eSBwYXRoIHNob3VsZCBzdGlsbCBhcHBlYXIgYmVmb3JlIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvdXRlci9pc3N1ZXMvMTEyNFxyXG4gICAgICAgICAgICAobWF0Y2hlci5yZWNvcmQucGF0aCAhPT0gbWF0Y2hlcnNbaV0ucmVjb3JkLnBhdGggfHxcclxuICAgICAgICAgICAgICAgICFpc1JlY29yZENoaWxkT2YobWF0Y2hlciwgbWF0Y2hlcnNbaV0pKSlcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIG1hdGNoZXJzLnNwbGljZShpLCAwLCBtYXRjaGVyKTtcclxuICAgICAgICAvLyBvbmx5IGFkZCB0aGUgb3JpZ2luYWwgcmVjb3JkIHRvIHRoZSBuYW1lIG1hcFxyXG4gICAgICAgIGlmIChtYXRjaGVyLnJlY29yZC5uYW1lICYmICFpc0FsaWFzUmVjb3JkKG1hdGNoZXIpKVxyXG4gICAgICAgICAgICBtYXRjaGVyTWFwLnNldChtYXRjaGVyLnJlY29yZC5uYW1lLCBtYXRjaGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUobG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgICAgIGxldCBtYXRjaGVyO1xyXG4gICAgICAgIGxldCBwYXJhbXMgPSB7fTtcclxuICAgICAgICBsZXQgcGF0aDtcclxuICAgICAgICBsZXQgbmFtZTtcclxuICAgICAgICBpZiAoJ25hbWUnIGluIGxvY2F0aW9uICYmIGxvY2F0aW9uLm5hbWUpIHtcclxuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJNYXAuZ2V0KGxvY2F0aW9uLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVSb3V0ZXJFcnJvcigxIC8qIE1BVENIRVJfTk9UX0ZPVU5EICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbihcclxuICAgICAgICAgICAgLy8gcGFyYW1zRnJvbUxvY2F0aW9uIGlzIGEgbmV3IG9iamVjdFxyXG4gICAgICAgICAgICBwYXJhbXNGcm9tTG9jYXRpb24oY3VycmVudExvY2F0aW9uLnBhcmFtcywgXHJcbiAgICAgICAgICAgIC8vIG9ubHkga2VlcCBwYXJhbXMgdGhhdCBleGlzdCBpbiB0aGUgcmVzb2x2ZWQgbG9jYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETzogb25seSBrZWVwIG9wdGlvbmFsIHBhcmFtcyBjb21pbmcgZnJvbSBhIHBhcmVudCByZWNvcmRcclxuICAgICAgICAgICAgbWF0Y2hlci5rZXlzLmZpbHRlcihrID0+ICFrLm9wdGlvbmFsKS5tYXAoayA9PiBrLm5hbWUpKSwgbG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgLy8gdGhyb3dzIGlmIGNhbm5vdCBiZSBzdHJpbmdpZmllZFxyXG4gICAgICAgICAgICBwYXRoID0gbWF0Y2hlci5zdHJpbmdpZnkocGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3BhdGgnIGluIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmVzb2x2ZSB0aGUgcGF0aCB3aXRoIHRoZSBtYXRjaGVyIGFzIGl0IHdhcyBwcm92aWRlZFxyXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gYWxsb3dzIHRoZSB1c2VyIHRvIGNvbnRyb2wgdGhlIGVuY29kaW5nXHJcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgVGhlIE1hdGNoZXIgY2Fubm90IHJlc29sdmUgcmVsYXRpdmUgcGF0aHMgYnV0IHJlY2VpdmVkIFwiJHtwYXRofVwiLiBVbmxlc3MgeW91IGRpcmVjdGx5IGNhbGxlZCBcXGBtYXRjaGVyLnJlc29sdmUoXCIke3BhdGh9XCIpXFxgLCB0aGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIHZ1ZS1yb3V0ZXIuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9yb3V0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJzLmZpbmQobSA9PiBtLnJlLnRlc3QocGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBtYXRjaGVyIHNob3VsZCBoYXZlIGEgdmFsdWUgYWZ0ZXIgdGhlIGxvb3BcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRldiB3YXJuaW5nIG9mIHVudXNlZCBwYXJhbXMgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhlIG1hdGNoZXIgd29ya3MgYmVjYXVzZSB3ZSB0ZXN0ZWQgdGhlIHJlZ2V4cFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbWF0Y2hlci5wYXJzZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBtYXRjaGVyLnJlY29yZC5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxvY2F0aW9uIGlzIGEgcmVsYXRpdmUgcGF0aFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbWF0Y2ggYnkgbmFtZSBvciBwYXRoIG9mIGN1cnJlbnQgcm91dGVcclxuICAgICAgICAgICAgbWF0Y2hlciA9IGN1cnJlbnRMb2NhdGlvbi5uYW1lXHJcbiAgICAgICAgICAgICAgICA/IG1hdGNoZXJNYXAuZ2V0KGN1cnJlbnRMb2NhdGlvbi5uYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBtYXRjaGVycy5maW5kKG0gPT4gbS5yZS50ZXN0KGN1cnJlbnRMb2NhdGlvbi5wYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcilcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVJvdXRlckVycm9yKDEgLyogTUFUQ0hFUl9OT1RfRk9VTkQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHBpY2sgdGhlXHJcbiAgICAgICAgICAgIC8vIHBhcmFtcyBsaWtlIHdoZW4gYG5hbWVgIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uLnBhcmFtcywgbG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgcGF0aCA9IG1hdGNoZXIuc3RyaW5naWZ5KHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcclxuICAgICAgICBsZXQgcGFyZW50TWF0Y2hlciA9IG1hdGNoZXI7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudE1hdGNoZXIpIHtcclxuICAgICAgICAgICAgLy8gcmV2ZXJzZWQgb3JkZXIgc28gcGFyZW50cyBhcmUgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBtYXRjaGVkLnVuc2hpZnQocGFyZW50TWF0Y2hlci5yZWNvcmQpO1xyXG4gICAgICAgICAgICBwYXJlbnRNYXRjaGVyID0gcGFyZW50TWF0Y2hlci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgbWF0Y2hlZCxcclxuICAgICAgICAgICAgbWV0YTogbWVyZ2VNZXRhRmllbGRzKG1hdGNoZWQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgaW5pdGlhbCByb3V0ZXNcclxuICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IGFkZFJvdXRlKHJvdXRlKSk7XHJcbiAgICByZXR1cm4geyBhZGRSb3V0ZSwgcmVzb2x2ZSwgcmVtb3ZlUm91dGUsIGdldFJvdXRlcywgZ2V0UmVjb3JkTWF0Y2hlciB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcmFtc0Zyb21Mb2NhdGlvbihwYXJhbXMsIGtleXMpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIGlmIChrZXkgaW4gcGFyYW1zKVxyXG4gICAgICAgICAgICBuZXdQYXJhbXNba2V5XSA9IHBhcmFtc1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplcyBhIFJvdXRlUmVjb3JkUmF3LiBDcmVhdGVzIGEgY29weVxyXG4gKlxyXG4gKiBAcGFyYW0gcmVjb3JkXHJcbiAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHZlcnNpb25cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlUmVjb3JkKHJlY29yZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXRoOiByZWNvcmQucGF0aCxcclxuICAgICAgICByZWRpcmVjdDogcmVjb3JkLnJlZGlyZWN0LFxyXG4gICAgICAgIG5hbWU6IHJlY29yZC5uYW1lLFxyXG4gICAgICAgIG1ldGE6IHJlY29yZC5tZXRhIHx8IHt9LFxyXG4gICAgICAgIGFsaWFzT2Y6IHVuZGVmaW5lZCxcclxuICAgICAgICBiZWZvcmVFbnRlcjogcmVjb3JkLmJlZm9yZUVudGVyLFxyXG4gICAgICAgIHByb3BzOiBub3JtYWxpemVSZWNvcmRQcm9wcyhyZWNvcmQpLFxyXG4gICAgICAgIGNoaWxkcmVuOiByZWNvcmQuY2hpbGRyZW4gfHwgW10sXHJcbiAgICAgICAgaW5zdGFuY2VzOiB7fSxcclxuICAgICAgICBsZWF2ZUd1YXJkczogbmV3IFNldCgpLFxyXG4gICAgICAgIHVwZGF0ZUd1YXJkczogbmV3IFNldCgpLFxyXG4gICAgICAgIGVudGVyQ2FsbGJhY2tzOiB7fSxcclxuICAgICAgICBjb21wb25lbnRzOiAnY29tcG9uZW50cycgaW4gcmVjb3JkXHJcbiAgICAgICAgICAgID8gcmVjb3JkLmNvbXBvbmVudHMgfHwge31cclxuICAgICAgICAgICAgOiB7IGRlZmF1bHQ6IHJlY29yZC5jb21wb25lbnQgfSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSB0aGUgb3B0aW9uYWwgYHByb3BzYCBpbiBhIHJlY29yZCB0byBhbHdheXMgYmUgYW4gb2JqZWN0IHNpbWlsYXIgdG9cclxuICogY29tcG9uZW50cy4gQWxzbyBhY2NlcHQgYSBib29sZWFuIGZvciBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0gcmVjb3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVSZWNvcmRQcm9wcyhyZWNvcmQpIHtcclxuICAgIGNvbnN0IHByb3BzT2JqZWN0ID0ge307XHJcbiAgICAvLyBwcm9wcyBkb2VzIG5vdCBleGlzdCBvbiByZWRpcmVjdCByZWNvcmRzIGJ1dCB3ZSBjYW4gc2V0IGZhbHNlIGRpcmVjdGx5XHJcbiAgICBjb25zdCBwcm9wcyA9IHJlY29yZC5wcm9wcyB8fCBmYWxzZTtcclxuICAgIGlmICgnY29tcG9uZW50JyBpbiByZWNvcmQpIHtcclxuICAgICAgICBwcm9wc09iamVjdC5kZWZhdWx0ID0gcHJvcHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBOT1RFOiB3ZSBjb3VsZCBhbHNvIGFsbG93IGEgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byBldmVyeSBjb21wb25lbnQuXHJcbiAgICAgICAgLy8gV291bGQgbmVlZCB1c2VyIGZlZWRiYWNrIGZvciB1c2UgY2FzZXNcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVjb3JkLmNvbXBvbmVudHMpXHJcbiAgICAgICAgICAgIHByb3BzT2JqZWN0W25hbWVdID0gdHlwZW9mIHByb3BzID09PSAnYm9vbGVhbicgPyBwcm9wcyA6IHByb3BzW25hbWVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzT2JqZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSByZWNvcmQgb3IgYW55IG9mIGl0cyBwYXJlbnQgaXMgYW4gYWxpYXNcclxuICogQHBhcmFtIHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBbGlhc1JlY29yZChyZWNvcmQpIHtcclxuICAgIHdoaWxlIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLnJlY29yZC5hbGlhc09mKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBNZXJnZSBtZXRhIGZpZWxkcyBvZiBhbiBhcnJheSBvZiByZWNvcmRzXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRjaGVkIC0gYXJyYXkgb2YgbWF0Y2hlZCByZWNvcmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU1ldGFGaWVsZHMobWF0Y2hlZCkge1xyXG4gICAgcmV0dXJuIG1hdGNoZWQucmVkdWNlKChtZXRhLCByZWNvcmQpID0+IGFzc2lnbihtZXRhLCByZWNvcmQubWV0YSksIHt9KTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIHBhcnRpYWxPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xyXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IGtleSBpbiBwYXJ0aWFsT3B0aW9ucyA/IHBhcnRpYWxPcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lUGFyYW0oYSwgYikge1xyXG4gICAgcmV0dXJuIChhLm5hbWUgPT09IGIubmFtZSAmJlxyXG4gICAgICAgIGEub3B0aW9uYWwgPT09IGIub3B0aW9uYWwgJiZcclxuICAgICAgICBhLnJlcGVhdGFibGUgPT09IGIucmVwZWF0YWJsZSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcGF0aCBhbmQgaXRzIGFsaWFzIGhhdmUgdGhlIHNhbWUgcmVxdWlyZWQgcGFyYW1zXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gb3JpZ2luYWwgcmVjb3JkXHJcbiAqIEBwYXJhbSBiIC0gYWxpYXMgcmVjb3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1NhbWVQYXJhbXMoYSwgYikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKSB7XHJcbiAgICAgICAgaWYgKCFrZXkub3B0aW9uYWwgJiYgIWIua2V5cy5maW5kKGlzU2FtZVBhcmFtLmJpbmQobnVsbCwga2V5KSkpXHJcbiAgICAgICAgICAgIHJldHVybiB3YXJuKGBBbGlhcyBcIiR7Yi5yZWNvcmQucGF0aH1cIiBhbmQgdGhlIG9yaWdpbmFsIHJlY29yZDogXCIke2EucmVjb3JkLnBhdGh9XCIgc2hvdWxkIGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiYCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiLmtleXMpIHtcclxuICAgICAgICBpZiAoIWtleS5vcHRpb25hbCAmJiAhYS5rZXlzLmZpbmQoaXNTYW1lUGFyYW0uYmluZChudWxsLCBrZXkpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHdhcm4oYEFsaWFzIFwiJHtiLnJlY29yZC5wYXRofVwiIGFuZCB0aGUgb3JpZ2luYWwgcmVjb3JkOiBcIiR7YS5yZWNvcmQucGF0aH1cIiBzaG91bGQgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBwYXJhbSBuYW1lZCBcIiR7a2V5Lm5hbWV9XCJgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja01pc3NpbmdQYXJhbXNJbkFic29sdXRlUGF0aChyZWNvcmQsIHBhcmVudCkge1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyZW50LmtleXMpIHtcclxuICAgICAgICBpZiAoIXJlY29yZC5rZXlzLmZpbmQoaXNTYW1lUGFyYW0uYmluZChudWxsLCBrZXkpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHdhcm4oYEFic29sdXRlIHBhdGggXCIke3JlY29yZC5yZWNvcmQucGF0aH1cIiBzaG91bGQgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBwYXJhbSBuYW1lZCBcIiR7a2V5Lm5hbWV9XCIgYXMgaXRzIHBhcmVudCBcIiR7cGFyZW50LnJlY29yZC5wYXRofVwiLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVjb3JkQ2hpbGRPZihyZWNvcmQsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkID09PSByZWNvcmQgfHwgaXNSZWNvcmRDaGlsZE9mKHJlY29yZCwgY2hpbGQpKTtcclxufVxuXG4vKipcclxuICogRW5jb2RpbmcgUnVsZXMg4pCjID0gU3BhY2UgUGF0aDog4pCjIFwiIDwgPiAjID8geyB9IFF1ZXJ5OiDikKMgXCIgPCA+ICMgJiA9IEhhc2g6IOKQoyBcIlxyXG4gKiA8ID4gYFxyXG4gKlxyXG4gKiBPbiB0b3Agb2YgdGhhdCwgdGhlIFJGQzM5ODYgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4yKVxyXG4gKiBkZWZpbmVzIHNvbWUgZXh0cmEgY2hhcmFjdGVycyB0byBiZSBlbmNvZGVkLiBNb3N0IGJyb3dzZXJzIGRvIG5vdCBlbmNvZGUgdGhlbVxyXG4gKiBpbiBlbmNvZGVVUkkgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy91cmwvaXNzdWVzLzM2OSwgc28gaXQgbWF5IGJlIHNhZmVyIHRvXHJcbiAqIGFsc28gZW5jb2RlIGAhJygpKmAuIExlYXZpbmcgdW5lbmNvZGVkIG9ubHkgQVNDSUkgYWxwaGFudW1lcmljKGBhLXpBLVowLTlgKVxyXG4gKiBwbHVzIGAtLl9+YC4gVGhpcyBleHRyYSBzYWZldHkgc2hvdWxkIGJlIGFwcGxpZWQgdG8gcXVlcnkgYnkgcGF0Y2hpbmcgdGhlXHJcbiAqIHN0cmluZyByZXR1cm5lZCBieSBlbmNvZGVVUklDb21wb25lbnQgZW5jb2RlVVJJIGFsc28gZW5jb2RlcyBgW1xcXV5gLiBgXFxgXHJcbiAqIHNob3VsZCBiZSBlbmNvZGVkIHRvIGF2b2lkIGFtYmlndWl0eS4gQnJvd3NlcnMgKElFLCBGRiwgQykgdHJhbnNmb3JtIGEgYFxcYFxyXG4gKiBpbnRvIGEgYC9gIGlmIGRpcmVjdGx5IHR5cGVkIGluLiBUaGUgX2JhY2t0aWNrXyAoYGBgYGApIHNob3VsZCBhbHNvIGJlXHJcbiAqIGVuY29kZWQgZXZlcnl3aGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgbGlrZSBGRiBlbmNvZGUgaXQgd2hlbiBkaXJlY3RseVxyXG4gKiB3cml0dGVuIHdoaWxlIG90aGVycyBkb24ndC4gU2FmYXJpIGFuZCBJRSBkb24ndCBlbmNvZGUgYGBcIjw+e31gYGAgaW4gaGFzaC5cclxuICovXHJcbi8vIGNvbnN0IEVYVFJBX1JFU0VSVkVEX1JFID0gL1shJygpKl0vZ1xyXG4vLyBjb25zdCBlbmNvZGVSZXNlcnZlZFJlcGxhY2VyID0gKGM6IHN0cmluZykgPT4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KVxyXG5jb25zdCBIQVNIX1JFID0gLyMvZzsgLy8gJTIzXHJcbmNvbnN0IEFNUEVSU0FORF9SRSA9IC8mL2c7IC8vICUyNlxyXG5jb25zdCBTTEFTSF9SRSA9IC9cXC8vZzsgLy8gJTJGXHJcbmNvbnN0IEVRVUFMX1JFID0gLz0vZzsgLy8gJTNEXHJcbmNvbnN0IElNX1JFID0gL1xcPy9nOyAvLyAlM0ZcclxuY29uc3QgUExVU19SRSA9IC9cXCsvZzsgLy8gJTJCXHJcbi8qKlxyXG4gKiBOT1RFOiBJdCdzIG5vdCBjbGVhciB0byBtZSBpZiB3ZSBzaG91bGQgZW5jb2RlIHRoZSArIHN5bWJvbCBpbiBxdWVyaWVzLCBpdFxyXG4gKiBzZWVtcyB0byBiZSBsZXNzIGZsZXhpYmxlIHRoYW4gbm90IGRvaW5nIHNvIGFuZCBJIGNhbid0IGZpbmQgb3V0IHRoZSBsZWdhY3lcclxuICogc3lzdGVtcyByZXF1aXJpbmcgdGhpcyBmb3IgcmVndWxhciByZXF1ZXN0cyBsaWtlIHRleHQvaHRtbC4gSW4gdGhlIHN0YW5kYXJkLFxyXG4gKiB0aGUgZW5jb2Rpbmcgb2YgdGhlIHBsdXMgY2hhcmFjdGVyIGlzIG9ubHkgbWVudGlvbmVkIGZvclxyXG4gKiBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcclxuICogKGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsZW5jb2RlZC1wYXJzaW5nKSBhbmQgbW9zdCBicm93c2VycyBzZWVtcyBsb1xyXG4gKiBsZWF2ZSB0aGUgcGx1cyBjaGFyYWN0ZXIgYXMgaXMgaW4gcXVlcmllcy4gVG8gYmUgbW9yZSBmbGV4aWJsZSwgd2UgYWxsb3cgdGhlXHJcbiAqIHBsdXMgY2hhcmFjdGVyIG9uIHRoZSBxdWVyeSBidXQgaXQgY2FuIGFsc28gYmUgbWFudWFsbHkgZW5jb2RlZCBieSB0aGUgdXNlci5cclxuICpcclxuICogUmVzb3VyY2VzOlxyXG4gKiAtIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsZW5jb2RlZC1wYXJzaW5nXHJcbiAqIC0gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTYzNDI3MS91cmwtZW5jb2RpbmctdGhlLXNwYWNlLWNoYXJhY3Rlci1vci0yMFxyXG4gKi9cclxuY29uc3QgRU5DX0JSQUNLRVRfT1BFTl9SRSA9IC8lNUIvZzsgLy8gW1xyXG5jb25zdCBFTkNfQlJBQ0tFVF9DTE9TRV9SRSA9IC8lNUQvZzsgLy8gXVxyXG5jb25zdCBFTkNfQ0FSRVRfUkUgPSAvJTVFL2c7IC8vIF5cclxuY29uc3QgRU5DX0JBQ0tUSUNLX1JFID0gLyU2MC9nOyAvLyBgXHJcbmNvbnN0IEVOQ19DVVJMWV9PUEVOX1JFID0gLyU3Qi9nOyAvLyB7XHJcbmNvbnN0IEVOQ19QSVBFX1JFID0gLyU3Qy9nOyAvLyB8XHJcbmNvbnN0IEVOQ19DVVJMWV9DTE9TRV9SRSA9IC8lN0QvZzsgLy8gfVxyXG5jb25zdCBFTkNfU1BBQ0VfUkUgPSAvJTIwL2c7IC8vIH1cclxuLyoqXHJcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBwYXRoLCBzZWFyY2ggYW5kIGhhc2hcclxuICogc2VjdGlvbnMgb2YgdGhlIFVSTC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gY29tbW9uRW5jb2RlKHRleHQpIHtcclxuICAgIHJldHVybiBlbmNvZGVVUkkoJycgKyB0ZXh0KVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19QSVBFX1JFLCAnfCcpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0JSQUNLRVRfT1BFTl9SRSwgJ1snKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19CUkFDS0VUX0NMT1NFX1JFLCAnXScpO1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBvbiB0aGUgaGFzaCBzZWN0aW9uIG9mIHRoZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlSGFzaCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gY29tbW9uRW5jb2RlKHRleHQpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX09QRU5fUkUsICd7JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQ1VSTFlfQ0xPU0VfUkUsICd9JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQ0FSRVRfUkUsICdeJyk7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIHF1ZXJ5IHZhbHVlcyBvbiB0aGUgcXVlcnlcclxuICogc2VjdGlvbiBvZiB0aGUgVVJMLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5VmFsdWUodGV4dCkge1xyXG4gICAgcmV0dXJuIChjb21tb25FbmNvZGUodGV4dClcclxuICAgICAgICAvLyBFbmNvZGUgdGhlIHNwYWNlIGFzICssIGVuY29kZSB0aGUgKyB0byBkaWZmZXJlbnRpYXRlIGl0IGZyb20gdGhlIHNwYWNlXHJcbiAgICAgICAgLnJlcGxhY2UoUExVU19SRSwgJyUyQicpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX1NQQUNFX1JFLCAnKycpXHJcbiAgICAgICAgLnJlcGxhY2UoSEFTSF9SRSwgJyUyMycpXHJcbiAgICAgICAgLnJlcGxhY2UoQU1QRVJTQU5EX1JFLCAnJTI2JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQkFDS1RJQ0tfUkUsICdgJylcclxuICAgICAgICAucmVwbGFjZShFTkNfQ1VSTFlfT1BFTl9SRSwgJ3snKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DVVJMWV9DTE9TRV9SRSwgJ30nKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgJ14nKSk7XHJcbn1cclxuLyoqXHJcbiAqIExpa2UgYGVuY29kZVF1ZXJ5VmFsdWVgIGJ1dCBhbHNvIGVuY29kZXMgdGhlIGA9YCBjaGFyYWN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUXVlcnlLZXkodGV4dCkge1xyXG4gICAgcmV0dXJuIGVuY29kZVF1ZXJ5VmFsdWUodGV4dCkucmVwbGFjZShFUVVBTF9SRSwgJyUzRCcpO1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBvbiB0aGUgcGF0aCBzZWN0aW9uIG9mIHRoZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUGF0aCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gY29tbW9uRW5jb2RlKHRleHQpLnJlcGxhY2UoSEFTSF9SRSwgJyUyMycpLnJlcGxhY2UoSU1fUkUsICclM0YnKTtcclxufVxyXG4vKipcclxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgb24gdGhlIHBhdGggc2VjdGlvbiBvZiB0aGUgVVJMIGFzIGFcclxuICogcGFyYW0uIFRoaXMgZnVuY3Rpb24gZW5jb2RlcyBldmVyeXRoaW5nIHtAbGluayBlbmNvZGVQYXRofSBkb2VzIHBsdXMgdGhlXHJcbiAqIHNsYXNoIChgL2ApIGNoYXJhY3Rlci4gSWYgYHRleHRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgcmV0dXJucyBhbiBlbXB0eVxyXG4gKiBzdHJpbmcgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVQYXJhbSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dCA9PSBudWxsID8gJycgOiBlbmNvZGVQYXRoKHRleHQpLnJlcGxhY2UoU0xBU0hfUkUsICclMkYnKTtcclxufVxyXG4vKipcclxuICogRGVjb2RlIHRleHQgdXNpbmcgYGRlY29kZVVSSUNvbXBvbmVudGAuIFJldHVybnMgdGhlIG9yaWdpbmFsIHRleHQgaWYgaXRcclxuICogZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGRlY29kZVxyXG4gKiBAcmV0dXJucyBkZWNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlKHRleHQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCgnJyArIHRleHQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBFcnJvciBkZWNvZGluZyBcIiR7dGV4dH1cIi4gVXNpbmcgb3JpZ2luYWwgdmFsdWVgKTtcclxuICAgIH1cclxuICAgIHJldHVybiAnJyArIHRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYSBxdWVyeVN0cmluZyBpbnRvIGEge0BsaW5rIExvY2F0aW9uUXVlcnl9IG9iamVjdC4gQWNjZXB0IGJvdGgsIGFcclxuICogdmVyc2lvbiB3aXRoIHRoZSBsZWFkaW5nIGA/YCBhbmQgd2l0aG91dCBTaG91bGQgd29yayBhcyBVUkxTZWFyY2hQYXJhbXNcclxuXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogQHBhcmFtIHNlYXJjaCAtIHNlYXJjaCBzdHJpbmcgdG8gcGFyc2VcclxuICogQHJldHVybnMgYSBxdWVyeSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUXVlcnkoc2VhcmNoKSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IHt9O1xyXG4gICAgLy8gYXZvaWQgY3JlYXRpbmcgYW4gb2JqZWN0IHdpdGggYW4gZW1wdHkga2V5IGFuZCBlbXB0eSB2YWx1ZVxyXG4gICAgLy8gYmVjYXVzZSBvZiBzcGxpdCgnJicpXHJcbiAgICBpZiAoc2VhcmNoID09PSAnJyB8fCBzZWFyY2ggPT09ICc/JylcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICBjb25zdCBoYXNMZWFkaW5nSU0gPSBzZWFyY2hbMF0gPT09ICc/JztcclxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IChoYXNMZWFkaW5nSU0gPyBzZWFyY2guc2xpY2UoMSkgOiBzZWFyY2gpLnNwbGl0KCcmJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaFBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIC8vIHByZSBkZWNvZGUgdGhlICsgaW50byBzcGFjZVxyXG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtID0gc2VhcmNoUGFyYW1zW2ldLnJlcGxhY2UoUExVU19SRSwgJyAnKTtcclxuICAgICAgICAvLyBhbGxvdyB0aGUgPSBjaGFyYWN0ZXJcclxuICAgICAgICBjb25zdCBlcVBvcyA9IHNlYXJjaFBhcmFtLmluZGV4T2YoJz0nKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBkZWNvZGUoZXFQb3MgPCAwID8gc2VhcmNoUGFyYW0gOiBzZWFyY2hQYXJhbS5zbGljZSgwLCBlcVBvcykpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXFQb3MgPCAwID8gbnVsbCA6IGRlY29kZShzZWFyY2hQYXJhbS5zbGljZShlcVBvcyArIDEpKTtcclxuICAgICAgICBpZiAoa2V5IGluIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIC8vIGFuIGV4dHJhIHZhcmlhYmxlIGZvciB0cyB0eXBlc1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gcXVlcnlba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHF1ZXJ5W2tleV0gPSBbY3VycmVudFZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5O1xyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmdpZmllcyBhIHtAbGluayBMb2NhdGlvblF1ZXJ5UmF3fSBvYmplY3QuIExpa2UgYFVSTFNlYXJjaFBhcmFtc2AsIGl0XHJcbiAqIGRvZXNuJ3QgcHJlcGVuZCBhIGA/YFxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gcXVlcnkgb2JqZWN0IHRvIHN0cmluZ2lmeVxyXG4gKiBAcmV0dXJucyBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgcXVlcnkgd2l0aG91dCB0aGUgbGVhZGluZyBgP2BcclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICBsZXQgc2VhcmNoID0gJyc7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gcXVlcnkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XHJcbiAgICAgICAga2V5ID0gZW5jb2RlUXVlcnlLZXkoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IG51bGwgYWRkcyB0aGUgdmFsdWVcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaCArPSAoc2VhcmNoLmxlbmd0aCA/ICcmJyA6ICcnKSArIGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga2VlcCBudWxsIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpXHJcbiAgICAgICAgICAgID8gdmFsdWUubWFwKHYgPT4gdiAmJiBlbmNvZGVRdWVyeVZhbHVlKHYpKVxyXG4gICAgICAgICAgICA6IFt2YWx1ZSAmJiBlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKV07XHJcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAvLyBza2lwIHVuZGVmaW5lZCB2YWx1ZXMgaW4gYXJyYXlzIGFzIGlmIHRoZXkgd2VyZSBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIGNvZGUgdGhhbiB1c2luZyBmaWx0ZXJcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kICYgd2l0aCBub24tZW1wdHkgc2VhcmNoXHJcbiAgICAgICAgICAgICAgICBzZWFyY2ggKz0gKHNlYXJjaC5sZW5ndGggPyAnJicgOiAnJykgKyBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2ggKz0gJz0nICsgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZWFyY2g7XHJcbn1cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYSB7QGxpbmsgTG9jYXRpb25RdWVyeVJhd30gaW50byBhIHtAbGluayBMb2NhdGlvblF1ZXJ5fSBieSBjYXN0aW5nXHJcbiAqIG51bWJlcnMgaW50byBzdHJpbmdzLCByZW1vdmluZyBrZXlzIHdpdGggYW4gdW5kZWZpbmVkIHZhbHVlIGFuZCByZXBsYWNpbmdcclxuICogdW5kZWZpbmVkIHdpdGggbnVsbCBpbiBhcnJheXNcclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gcXVlcnkgb2JqZWN0IHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyBhIG5vcm1hbGl6ZWQgcXVlcnkgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVRdWVyeShxdWVyeSkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkUXVlcnlba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IHZhbHVlLm1hcCh2ID0+ICh2ID09IG51bGwgPyBudWxsIDogJycgKyB2KSlcclxuICAgICAgICAgICAgICAgIDogdmFsdWUgPT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6ICcnICsgdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRRdWVyeTtcclxufVxuXG4vKipcclxuICogQ3JlYXRlIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBjYW4gYmUgcmVzZXQuIFVzZWQgdG8gY3JlYXRlIGJlZm9yZSBhbmQgYWZ0ZXIgbmF2aWdhdGlvbiBndWFyZHMgbGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tzKCkge1xyXG4gICAgbGV0IGhhbmRsZXJzID0gW107XHJcbiAgICBmdW5jdGlvbiBhZGQoaGFuZGxlcikge1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaSA9IGhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGlmIChpID4gLTEpXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgICAgIGhhbmRsZXJzID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBsaXN0OiAoKSA9PiBoYW5kbGVycyxcclxuICAgICAgICByZXNldCxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJHdWFyZChyZWNvcmQsIG5hbWUsIGd1YXJkKSB7XHJcbiAgICBjb25zdCByZW1vdmVGcm9tTGlzdCA9ICgpID0+IHtcclxuICAgICAgICByZWNvcmRbbmFtZV0uZGVsZXRlKGd1YXJkKTtcclxuICAgIH07XHJcbiAgICBvblVubW91bnRlZChyZW1vdmVGcm9tTGlzdCk7XHJcbiAgICBvbkRlYWN0aXZhdGVkKHJlbW92ZUZyb21MaXN0KTtcclxuICAgIG9uQWN0aXZhdGVkKCgpID0+IHtcclxuICAgICAgICByZWNvcmRbbmFtZV0uYWRkKGd1YXJkKTtcclxuICAgIH0pO1xyXG4gICAgcmVjb3JkW25hbWVdLmFkZChndWFyZCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhIG5hdmlnYXRpb24gZ3VhcmQgdGhhdCB0cmlnZ2VycyB3aGVuZXZlciB0aGUgY29tcG9uZW50IGZvciB0aGUgY3VycmVudFxyXG4gKiBsb2NhdGlvbiBpcyBhYm91dCB0byBiZSBsZWZ0LiBTaW1pbGFyIHRvIHtAbGluayBiZWZvcmVSb3V0ZUxlYXZlfSBidXQgY2FuIGJlXHJcbiAqIHVzZWQgaW4gYW55IGNvbXBvbmVudC4gVGhlIGd1YXJkIGlzIHJlbW92ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cclxuICpcclxuICogQHBhcmFtIGxlYXZlR3VhcmQgLSB7QGxpbmsgTmF2aWdhdGlvbkd1YXJkfVxyXG4gKi9cclxuZnVuY3Rpb24gb25CZWZvcmVSb3V0ZUxlYXZlKGxlYXZlR3VhcmQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWdldEN1cnJlbnRJbnN0YW5jZSgpKSB7XHJcbiAgICAgICAgd2FybignZ2V0Q3VycmVudEluc3RhbmNlKCkgcmV0dXJuZWQgbnVsbC4gb25CZWZvcmVSb3V0ZUxlYXZlKCkgbXVzdCBiZSBjYWxsZWQgYXQgdGhlIHRvcCBvZiBhIHNldHVwIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWN0aXZlUmVjb3JkID0gaW5qZWN0KG1hdGNoZWRSb3V0ZUtleSwgXHJcbiAgICAvLyB0byBhdm9pZCB3YXJuaW5nXHJcbiAgICB7fSkudmFsdWU7XHJcbiAgICBpZiAoIWFjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKCdObyBhY3RpdmUgcm91dGUgcmVjb3JkIHdhcyBmb3VuZCB3aGVuIGNhbGxpbmcgYG9uQmVmb3JlUm91dGVMZWF2ZSgpYC4gTWFrZSBzdXJlIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gaW5zaWRlIG9mIGEgY29tcG9uZW50IGNoaWxkIG9mIDxyb3V0ZXItdmlldz4uIE1heWJlIHlvdSBjYWxsZWQgaXQgaW5zaWRlIG9mIEFwcC52dWU/Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJHdWFyZChhY3RpdmVSZWNvcmQsICdsZWF2ZUd1YXJkcycsIGxlYXZlR3VhcmQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBuYXZpZ2F0aW9uIGd1YXJkIHRoYXQgdHJpZ2dlcnMgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgbG9jYXRpb24gaXMgYWJvdXRcclxuICogdG8gYmUgdXBkYXRlZC4gU2ltaWxhciB0byB7QGxpbmsgYmVmb3JlUm91dGVVcGRhdGV9IGJ1dCBjYW4gYmUgdXNlZCBpbiBhbnlcclxuICogY29tcG9uZW50LiBUaGUgZ3VhcmQgaXMgcmVtb3ZlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXBkYXRlR3VhcmQgLSB7QGxpbmsgTmF2aWdhdGlvbkd1YXJkfVxyXG4gKi9cclxuZnVuY3Rpb24gb25CZWZvcmVSb3V0ZVVwZGF0ZSh1cGRhdGVHdWFyZCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZ2V0Q3VycmVudEluc3RhbmNlKCkpIHtcclxuICAgICAgICB3YXJuKCdnZXRDdXJyZW50SW5zdGFuY2UoKSByZXR1cm5lZCBudWxsLiBvbkJlZm9yZVJvdXRlVXBkYXRlKCkgbXVzdCBiZSBjYWxsZWQgYXQgdGhlIHRvcCBvZiBhIHNldHVwIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWN0aXZlUmVjb3JkID0gaW5qZWN0KG1hdGNoZWRSb3V0ZUtleSwgXHJcbiAgICAvLyB0byBhdm9pZCB3YXJuaW5nXHJcbiAgICB7fSkudmFsdWU7XHJcbiAgICBpZiAoIWFjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKCdObyBhY3RpdmUgcm91dGUgcmVjb3JkIHdhcyBmb3VuZCB3aGVuIGNhbGxpbmcgYG9uQmVmb3JlUm91dGVVcGRhdGUoKWAuIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIGluc2lkZSBvZiBhIGNvbXBvbmVudCBjaGlsZCBvZiA8cm91dGVyLXZpZXc+LiBNYXliZSB5b3UgY2FsbGVkIGl0IGluc2lkZSBvZiBBcHAudnVlPycpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyR3VhcmQoYWN0aXZlUmVjb3JkLCAndXBkYXRlR3VhcmRzJywgdXBkYXRlR3VhcmQpO1xyXG59XHJcbmZ1bmN0aW9uIGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tLCByZWNvcmQsIG5hbWUpIHtcclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGVudGVyQ2FsbGJhY2tBcnJheSB0byBwcmV2ZW50IHB1c2hpbmcgY2FsbGJhY2tzIGlmIGEgbmV3IG5hdmlnYXRpb24gdG9vayBwbGFjZVxyXG4gICAgY29uc3QgZW50ZXJDYWxsYmFja0FycmF5ID0gcmVjb3JkICYmXHJcbiAgICAgICAgLy8gbmFtZSBpcyBkZWZpbmVkIGlmIHJlY29yZCBpcyBiZWNhdXNlIG9mIHRoZSBmdW5jdGlvbiBvdmVybG9hZFxyXG4gICAgICAgIChyZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPSByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gfHwgW10pO1xyXG4gICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBuZXh0ID0gKHZhbGlkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoNCAvKiBOQVZJR0FUSU9OX0FCT1JURUQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWxpZCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QodmFsaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUm91dGVMb2NhdGlvbih2YWxpZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVSb3V0ZXJFcnJvcigyIC8qIE5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0byxcclxuICAgICAgICAgICAgICAgICAgICB0bzogdmFsaWQsXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJDYWxsYmFja0FycmF5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZW50ZXJDYWxsYmFja0FycmF5IGlzIHRydXRoeSwgYm90aCByZWNvcmQgYW5kIG5hbWUgYWxzbyBhcmVcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPT09IGVudGVyQ2FsbGJhY2tBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICBlbnRlckNhbGxiYWNrQXJyYXkucHVzaCh2YWxpZCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHdyYXBwaW5nIHdpdGggUHJvbWlzZS5yZXNvbHZlIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYm90aCBhc3luYyBhbmQgc3luYyBndWFyZHNcclxuICAgICAgICBjb25zdCBndWFyZFJldHVybiA9IGd1YXJkLmNhbGwocmVjb3JkICYmIHJlY29yZC5pbnN0YW5jZXNbbmFtZV0sIHRvLCBmcm9tLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjYW5Pbmx5QmVDYWxsZWRPbmNlKG5leHQsIHRvLCBmcm9tKSA6IG5leHQpO1xyXG4gICAgICAgIGxldCBndWFyZENhbGwgPSBQcm9taXNlLnJlc29sdmUoZ3VhcmRSZXR1cm4pO1xyXG4gICAgICAgIGlmIChndWFyZC5sZW5ndGggPCAzKVxyXG4gICAgICAgICAgICBndWFyZENhbGwgPSBndWFyZENhbGwudGhlbihuZXh0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGd1YXJkLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgXCJuZXh0XCIgY2FsbGJhY2sgd2FzIG5ldmVyIGNhbGxlZCBpbnNpZGUgb2YgJHtndWFyZC5uYW1lID8gJ1wiJyArIGd1YXJkLm5hbWUgKyAnXCInIDogJyd9OlxcbiR7Z3VhcmQudG9TdHJpbmcoKX1cXG4uIElmIHlvdSBhcmUgcmV0dXJuaW5nIGEgdmFsdWUgaW5zdGVhZCBvZiBjYWxsaW5nIFwibmV4dFwiLCBtYWtlIHN1cmUgdG8gcmVtb3ZlIHRoZSBcIm5leHRcIiBwYXJhbWV0ZXIgZnJvbSB5b3VyIGZ1bmN0aW9uLmA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3VhcmRSZXR1cm4gPT09ICdvYmplY3QnICYmICd0aGVuJyBpbiBndWFyZFJldHVybikge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmRDYWxsID0gZ3VhcmRDYWxsLnRoZW4ocmVzb2x2ZWRWYWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogX2NhbGxlZCBpcyBhZGRlZCBhdCBjYW5Pbmx5QmVDYWxsZWRPbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0Ll9jYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBuYXZpZ2F0aW9uIGd1YXJkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGVzdCBtZSFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChndWFyZFJldHVybiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBfY2FsbGVkIGlzIGFkZGVkIGF0IGNhbk9ubHlCZUNhbGxlZE9uY2VcclxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5fY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIG5hdmlnYXRpb24gZ3VhcmQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGd1YXJkQ2FsbC5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2FuT25seUJlQ2FsbGVkT25jZShuZXh0LCB0bywgZnJvbSkge1xyXG4gICAgbGV0IGNhbGxlZCA9IDA7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjYWxsZWQrKyA9PT0gMSlcclxuICAgICAgICAgICAgd2FybihgVGhlIFwibmV4dFwiIGNhbGxiYWNrIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaW4gb25lIG5hdmlnYXRpb24gZ3VhcmQgd2hlbiBnb2luZyBmcm9tIFwiJHtmcm9tLmZ1bGxQYXRofVwiIHRvIFwiJHt0by5mdWxsUGF0aH1cIi4gSXQgc2hvdWxkIGJlIGNhbGxlZCBleGFjdGx5IG9uZSB0aW1lIGluIGVhY2ggbmF2aWdhdGlvbiBndWFyZC4gVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbi5gKTtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBwdXQgaXQgaW4gdGhlIG9yaWdpbmFsIG9uZSBiZWNhdXNlIGl0J3MgZWFzaWVyIHRvIGNoZWNrXHJcbiAgICAgICAgbmV4dC5fY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoY2FsbGVkID09PSAxKVxyXG4gICAgICAgICAgICBuZXh0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RDb21wb25lbnRzR3VhcmRzKG1hdGNoZWQsIGd1YXJkVHlwZSwgdG8sIGZyb20pIHtcclxuICAgIGNvbnN0IGd1YXJkcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgbWF0Y2hlZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWNvcmQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBsZXQgcmF3Q29tcG9uZW50ID0gcmVjb3JkLmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmF3Q29tcG9uZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByYXdDb21wb25lbnQgIT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByYXdDb21wb25lbnQgIT09ICdmdW5jdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIG5vdGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgIGEgdmFsaWQgY29tcG9uZW50LiBSZWNlaXZlZCBcIiR7U3RyaW5nKHJhd0NvbXBvbmVudCl9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdG8gZW5zdXJlIHdlIHN0b3AgaGVyZSBidXQgd2FybiB0byBlbnN1cmUgdGhlIG1lc3NhZ2UgaXNuJ3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzZWQgYnkgdGhlIHVzZXJcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm91dGUgY29tcG9uZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgndGhlbicgaW4gcmF3Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybiBpZiB1c2VyIHdyb3RlIGltcG9ydCgnL2NvbXBvbmVudC52dWUnKSBpbnN0ZWFkIG9mICgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0KCcuL2NvbXBvbmVudC52dWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBpbiByZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgUHJvbWlzZSBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZS4gRGlkIHlvdSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdyaXRlIFwiaW1wb3J0KCcuL015UGFnZS52dWUnKVwiIGluc3RlYWQgb2YgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcIigpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiA/IFRoaXMgd2lsbCBicmVhayBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSByYXdDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Q29tcG9uZW50ID0gKCkgPT4gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd0NvbXBvbmVudC5fX2FzeW5jTG9hZGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybiBvbmx5IG9uY2UgcGVyIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICFyYXdDb21wb25lbnQuX193YXJuZWREZWZpbmVBc3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd0NvbXBvbmVudC5fX3dhcm5lZERlZmluZUFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaW4gcmVjb3JkIHdpdGggcGF0aCBcIiR7cmVjb3JkLnBhdGh9XCIgaXMgZGVmaW5lZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHVzaW5nIFwiZGVmaW5lQXN5bmNDb21wb25lbnQoKVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFdyaXRlIFwiKCkgPT4gaW1wb3J0KCcuL015UGFnZS52dWUnKVwiIGluc3RlYWQgb2YgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcImRlZmluZUFzeW5jQ29tcG9uZW50KCgpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJykpXCIuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB1cGRhdGUgYW5kIGxlYXZlIGd1YXJkcyBpZiB0aGUgcm91dGUgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkXHJcbiAgICAgICAgICAgIGlmIChndWFyZFR5cGUgIT09ICdiZWZvcmVSb3V0ZUVudGVyJyAmJiAhcmVjb3JkLmluc3RhbmNlc1tuYW1lXSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoaXNSb3V0ZUNvbXBvbmVudChyYXdDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfX3ZjY09wdHMgaXMgYWRkZWQgYnkgdnVlLWNsYXNzLWNvbXBvbmVudCBhbmQgY29udGFpbiB0aGUgcmVndWxhciBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcmF3Q29tcG9uZW50Ll9fdmNjT3B0cyB8fCByYXdDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBndWFyZCA9IG9wdGlvbnNbZ3VhcmRUeXBlXTtcclxuICAgICAgICAgICAgICAgIGd1YXJkICYmIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tLCByZWNvcmQsIG5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHJlcXVlc3RpbmcgdGhlIGNodW5rIGFscmVhZHlcclxuICAgICAgICAgICAgICAgIGxldCBjb21wb25lbnRQcm9taXNlID0gcmF3Q29tcG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICEoJ2NhdGNoJyBpbiBjb21wb25lbnRQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBpbiByZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBhIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgcmV0dXJuIGEgUHJvbWlzZS4gSWYgeW91IHdlcmUgcGFzc2luZyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LCBtYWtlIHN1cmUgdG8gYWRkIGEgXCJkaXNwbGF5TmFtZVwiIHRvIHRoZSBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayBpbiBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbXBvbmVudFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goKCkgPT4gY29tcG9uZW50UHJvbWlzZS50aGVuKHJlc29sdmVkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb3VsZG4ndCByZXNvbHZlIGNvbXBvbmVudCBcIiR7bmFtZX1cIiBhdCBcIiR7cmVjb3JkLnBhdGh9XCJgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRDb21wb25lbnQgPSBpc0VTTW9kdWxlKHJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVkLmRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHZlZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSByZXNvbHZlZCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQuY29tcG9uZW50c1tuYW1lXSA9IHJlc29sdmVkQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIF9fdmNjT3B0cyBpcyBhZGRlZCBieSB2dWUtY2xhc3MtY29tcG9uZW50IGFuZCBjb250YWluIHRoZSByZWd1bGFyIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZWRDb21wb25lbnQuX192Y2NPcHRzIHx8IHJlc29sdmVkQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gb3B0aW9uc1tndWFyZFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBndWFyZCAmJiBndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSwgcmVjb3JkLCBuYW1lKSgpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGd1YXJkcztcclxufVxyXG4vKipcclxuICogQWxsb3dzIGRpZmZlcmVudGlhdGluZyBsYXp5IGNvbXBvbmVudHMgZnJvbSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYW5kIHZ1ZS1jbGFzcy1jb21wb25lbnRcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSb3V0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgfHxcclxuICAgICAgICAnZGlzcGxheU5hbWUnIGluIGNvbXBvbmVudCB8fFxyXG4gICAgICAgICdwcm9wcycgaW4gY29tcG9uZW50IHx8XHJcbiAgICAgICAgJ19fdmNjT3B0cycgaW4gY29tcG9uZW50KTtcclxufVxuXG4vLyBUT0RPOiB3ZSBjb3VsZCBhbGxvdyBjdXJyZW50Um91dGUgYXMgYSBwcm9wIHRvIGV4cG9zZSBgaXNBY3RpdmVgIGFuZFxyXG4vLyBgaXNFeGFjdEFjdGl2ZWAgYmVoYXZpb3Igc2hvdWxkIGdvIHRocm91Z2ggYW4gUkZDXHJcbmZ1bmN0aW9uIHVzZUxpbmsocHJvcHMpIHtcclxuICAgIGNvbnN0IHJvdXRlciA9IGluamVjdChyb3V0ZXJLZXkpO1xyXG4gICAgY29uc3QgY3VycmVudFJvdXRlID0gaW5qZWN0KHJvdXRlTG9jYXRpb25LZXkpO1xyXG4gICAgY29uc3Qgcm91dGUgPSBjb21wdXRlZCgoKSA9PiByb3V0ZXIucmVzb2x2ZSh1bnJlZihwcm9wcy50bykpKTtcclxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZEluZGV4ID0gY29tcHV0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbWF0Y2hlZCB9ID0gcm91dGUudmFsdWU7XHJcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IG1hdGNoZWQ7XHJcbiAgICAgICAgY29uc3Qgcm91dGVNYXRjaGVkID0gbWF0Y2hlZFtsZW5ndGggLSAxXTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWF0Y2hlZCA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkO1xyXG4gICAgICAgIGlmICghcm91dGVNYXRjaGVkIHx8ICFjdXJyZW50TWF0Y2hlZC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRNYXRjaGVkLmZpbmRJbmRleChpc1NhbWVSb3V0ZVJlY29yZC5iaW5kKG51bGwsIHJvdXRlTWF0Y2hlZCkpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgLy8gcG9zc2libGUgcGFyZW50IHJlY29yZFxyXG4gICAgICAgIGNvbnN0IHBhcmVudFJlY29yZFBhdGggPSBnZXRPcmlnaW5hbFBhdGgobWF0Y2hlZFtsZW5ndGggLSAyXSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAvLyB3ZSBhcmUgZGVhbGluZyB3aXRoIG5lc3RlZCByb3V0ZXNcclxuICAgICAgICBsZW5ndGggPiAxICYmXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgYW5kIG1hdGNoZWQgcm91dGUgaGF2ZSB0aGUgc2FtZSBwYXRoLCB0aGlzIGxpbmsgaXNcclxuICAgICAgICAgICAgLy8gcmVmZXJyaW5nIHRvIHRoZSBlbXB0eSBjaGlsZC4gT3Igd2UgY3VycmVudGx5IGFyZSBvbiBhIGRpZmZlcmVudFxyXG4gICAgICAgICAgICAvLyBjaGlsZCBvZiB0aGUgc2FtZSBwYXJlbnRcclxuICAgICAgICAgICAgZ2V0T3JpZ2luYWxQYXRoKHJvdXRlTWF0Y2hlZCkgPT09IHBhcmVudFJlY29yZFBhdGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgY29tcGFyaW5nIHRoZSBjaGlsZCB3aXRoIGl0cyBwYXJlbnRcclxuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRbY3VycmVudE1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aCAhPT0gcGFyZW50UmVjb3JkUGF0aFxyXG4gICAgICAgICAgICA/IGN1cnJlbnRNYXRjaGVkLmZpbmRJbmRleChpc1NhbWVSb3V0ZVJlY29yZC5iaW5kKG51bGwsIG1hdGNoZWRbbGVuZ3RoIC0gMl0pKVxyXG4gICAgICAgICAgICA6IGluZGV4KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaXNBY3RpdmUgPSBjb21wdXRlZCgoKSA9PiBhY3RpdmVSZWNvcmRJbmRleC52YWx1ZSA+IC0xICYmXHJcbiAgICAgICAgaW5jbHVkZXNQYXJhbXMoY3VycmVudFJvdXRlLnBhcmFtcywgcm91dGUudmFsdWUucGFyYW1zKSk7XHJcbiAgICBjb25zdCBpc0V4YWN0QWN0aXZlID0gY29tcHV0ZWQoKCkgPT4gYWN0aXZlUmVjb3JkSW5kZXgudmFsdWUgPiAtMSAmJlxyXG4gICAgICAgIGFjdGl2ZVJlY29yZEluZGV4LnZhbHVlID09PSBjdXJyZW50Um91dGUubWF0Y2hlZC5sZW5ndGggLSAxICYmXHJcbiAgICAgICAgaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtcyhjdXJyZW50Um91dGUucGFyYW1zLCByb3V0ZS52YWx1ZS5wYXJhbXMpKTtcclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKGUgPSB7fSkge1xyXG4gICAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXJbdW5yZWYocHJvcHMucmVwbGFjZSkgPyAncmVwbGFjZScgOiAncHVzaCddKHVucmVmKHByb3BzLnRvKVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB1bmNhdWdodCBlcnJvcnMgYXJlIHRoZXkgYXJlIGxvZ2dlZCBhbnl3YXlcclxuICAgICAgICAgICAgKS5jYXRjaChub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gZGV2dG9vbHMgb25seVxyXG4gICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiBpc0Jyb3dzZXIpIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rQ29udGV4dERldnRvb2xzID0ge1xyXG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaXNFeGFjdEFjdGl2ZTogaXNFeGFjdEFjdGl2ZS52YWx1ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhpcyBpcyBpbnRlcm5hbFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZybF9kZXZ0b29scyA9IGluc3RhbmNlLl9fdnJsX2RldnRvb2xzIHx8IFtdO1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGlzIGlzIGludGVybmFsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdnJsX2RldnRvb2xzLnB1c2gobGlua0NvbnRleHREZXZ0b29scyk7XHJcbiAgICAgICAgICAgIHdhdGNoRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMucm91dGUgPSByb3V0ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMuaXNBY3RpdmUgPSBpc0FjdGl2ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxpbmtDb250ZXh0RGV2dG9vbHMuaXNFeGFjdEFjdGl2ZSA9IGlzRXhhY3RBY3RpdmUudmFsdWU7XHJcbiAgICAgICAgICAgIH0sIHsgZmx1c2g6ICdwb3N0JyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJvdXRlLFxyXG4gICAgICAgIGhyZWY6IGNvbXB1dGVkKCgpID0+IHJvdXRlLnZhbHVlLmhyZWYpLFxyXG4gICAgICAgIGlzQWN0aXZlLFxyXG4gICAgICAgIGlzRXhhY3RBY3RpdmUsXHJcbiAgICAgICAgbmF2aWdhdGUsXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJvdXRlckxpbmtJbXBsID0gLyojX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgbmFtZTogJ1JvdXRlckxpbmsnLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2U6IEJvb2xlYW4sXHJcbiAgICAgICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgICAgICAvLyBpbmFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgICAgIGN1c3RvbTogQm9vbGVhbixcclxuICAgICAgICBhcmlhQ3VycmVudFZhbHVlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ3BhZ2UnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgdXNlTGluayxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBsaW5rID0gcmVhY3RpdmUodXNlTGluayhwcm9wcykpO1xyXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5qZWN0KHJvdXRlcktleSk7XHJcbiAgICAgICAgY29uc3QgZWxDbGFzcyA9IGNvbXB1dGVkKCgpID0+ICh7XHJcbiAgICAgICAgICAgIFtnZXRMaW5rQ2xhc3MocHJvcHMuYWN0aXZlQ2xhc3MsIG9wdGlvbnMubGlua0FjdGl2ZUNsYXNzLCAncm91dGVyLWxpbmstYWN0aXZlJyldOiBsaW5rLmlzQWN0aXZlLFxyXG4gICAgICAgICAgICAvLyBbZ2V0TGlua0NsYXNzKFxyXG4gICAgICAgICAgICAvLyAgIHByb3BzLmluYWN0aXZlQ2xhc3MsXHJcbiAgICAgICAgICAgIC8vICAgb3B0aW9ucy5saW5rSW5hY3RpdmVDbGFzcyxcclxuICAgICAgICAgICAgLy8gICAncm91dGVyLWxpbmstaW5hY3RpdmUnXHJcbiAgICAgICAgICAgIC8vICldOiAhbGluay5pc0V4YWN0QWN0aXZlLFxyXG4gICAgICAgICAgICBbZ2V0TGlua0NsYXNzKHByb3BzLmV4YWN0QWN0aXZlQ2xhc3MsIG9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3MsICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnKV06IGxpbmsuaXNFeGFjdEFjdGl2ZSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQobGluayk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5jdXN0b21cclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIDogaCgnYScsIHtcclxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1jdXJyZW50JzogbGluay5pc0V4YWN0QWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcHMuYXJpYUN1cnJlbnRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgb3ZlcnJpZGUgdXNlciBhZGRlZCBhdHRycyBidXQgVnVlIHdpbGwgc3RpbGwgYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxpc3RlbmVyIHNvIHdlIGVuZCB1cCB0cmlnZ2VyaW5nIGJvdGhcclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBsaW5rLm5hdmlnYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBlbENsYXNzLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdG8gcmVuZGVyIGEgbGluayB0aGF0IHRyaWdnZXJzIGEgbmF2aWdhdGlvbiBvbiBjbGljay5cclxuICovXHJcbmNvbnN0IFJvdXRlckxpbmsgPSBSb3V0ZXJMaW5rSW1wbDtcclxuZnVuY3Rpb24gZ3VhcmRFdmVudChlKSB7XHJcbiAgICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xyXG4gICAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxyXG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xyXG4gICAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBnZXRBdHRyaWJ1dGUgZG9lcyBleGlzdFxyXG4gICAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBnZXRBdHRyaWJ1dGUgZXhpc3RzXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XHJcbiAgICAgICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcclxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGluY2x1ZGVzUGFyYW1zKG91dGVyLCBpbm5lcikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5uZXIpIHtcclxuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gaW5uZXJba2V5XTtcclxuICAgICAgICBjb25zdCBvdXRlclZhbHVlID0gb3V0ZXJba2V5XTtcclxuICAgICAgICBpZiAodHlwZW9mIGlubmVyVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChpbm5lclZhbHVlICE9PSBvdXRlclZhbHVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG91dGVyVmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICBvdXRlclZhbHVlLmxlbmd0aCAhPT0gaW5uZXJWYWx1ZS5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgIGlubmVyVmFsdWUuc29tZSgodmFsdWUsIGkpID0+IHZhbHVlICE9PSBvdXRlclZhbHVlW2ldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBvcmlnaW5hbCBwYXRoIHZhbHVlIG9mIGEgcmVjb3JkIGJ5IGZvbGxvd2luZyBpdHMgYWxpYXNPZlxyXG4gKiBAcGFyYW0gcmVjb3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFBhdGgocmVjb3JkKSB7XHJcbiAgICByZXR1cm4gcmVjb3JkID8gKHJlY29yZC5hbGlhc09mID8gcmVjb3JkLmFsaWFzT2YucGF0aCA6IHJlY29yZC5wYXRoKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBVdGlsaXR5IGNsYXNzIHRvIGdldCB0aGUgYWN0aXZlIGNsYXNzIGJhc2VkIG9uIGRlZmF1bHRzLlxyXG4gKiBAcGFyYW0gcHJvcENsYXNzXHJcbiAqIEBwYXJhbSBnbG9iYWxDbGFzc1xyXG4gKiBAcGFyYW0gZGVmYXVsdENsYXNzXHJcbiAqL1xyXG5jb25zdCBnZXRMaW5rQ2xhc3MgPSAocHJvcENsYXNzLCBnbG9iYWxDbGFzcywgZGVmYXVsdENsYXNzKSA9PiBwcm9wQ2xhc3MgIT0gbnVsbFxyXG4gICAgPyBwcm9wQ2xhc3NcclxuICAgIDogZ2xvYmFsQ2xhc3MgIT0gbnVsbFxyXG4gICAgICAgID8gZ2xvYmFsQ2xhc3NcclxuICAgICAgICA6IGRlZmF1bHRDbGFzcztcblxuY29uc3QgUm91dGVyVmlld0ltcGwgPSAvKiNfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICBuYW1lOiAnUm91dGVyVmlldycsXHJcbiAgICAvLyAjNjc0IHdlIG1hbnVhbGx5IGluaGVyaXQgdGhlbVxyXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbmFtZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdXRlOiBPYmplY3QsXHJcbiAgICB9LFxyXG4gICAgLy8gQmV0dGVyIGNvbXBhdCBmb3IgQHZ1ZS9jb21wYXQgdXNlcnNcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb3V0ZXIvaXNzdWVzLzEzMTVcclxuICAgIGNvbXBhdENvbmZpZzogeyBNT0RFOiAzIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBhdHRycywgc2xvdHMgfSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuRGVwcmVjYXRlZFVzYWdlKCk7XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWRSb3V0ZSA9IGluamVjdChyb3V0ZXJWaWV3TG9jYXRpb25LZXkpO1xyXG4gICAgICAgIGNvbnN0IHJvdXRlVG9EaXNwbGF5ID0gY29tcHV0ZWQoKCkgPT4gcHJvcHMucm91dGUgfHwgaW5qZWN0ZWRSb3V0ZS52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZGVwdGggPSBpbmplY3Qodmlld0RlcHRoS2V5LCAwKTtcclxuICAgICAgICBjb25zdCBtYXRjaGVkUm91dGVSZWYgPSBjb21wdXRlZCgoKSA9PiByb3V0ZVRvRGlzcGxheS52YWx1ZS5tYXRjaGVkW2RlcHRoXSk7XHJcbiAgICAgICAgcHJvdmlkZSh2aWV3RGVwdGhLZXksIGRlcHRoICsgMSk7XHJcbiAgICAgICAgcHJvdmlkZShtYXRjaGVkUm91dGVLZXksIG1hdGNoZWRSb3V0ZVJlZik7XHJcbiAgICAgICAgcHJvdmlkZShyb3V0ZXJWaWV3TG9jYXRpb25LZXksIHJvdXRlVG9EaXNwbGF5KTtcclxuICAgICAgICBjb25zdCB2aWV3UmVmID0gcmVmKCk7XHJcbiAgICAgICAgLy8gd2F0Y2ggYXQgdGhlIHNhbWUgdGltZSB0aGUgY29tcG9uZW50IGluc3RhbmNlLCB0aGUgcm91dGUgcmVjb3JkIHdlIGFyZVxyXG4gICAgICAgIC8vIHJlbmRlcmluZywgYW5kIHRoZSBuYW1lXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3ZpZXdSZWYudmFsdWUsIG1hdGNoZWRSb3V0ZVJlZi52YWx1ZSwgcHJvcHMubmFtZV0sIChbaW5zdGFuY2UsIHRvLCBuYW1lXSwgW29sZEluc3RhbmNlLCBmcm9tLCBvbGROYW1lXSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb3B5IHJldXNlZCBpbnN0YW5jZXNcclxuICAgICAgICAgICAgaWYgKHRvKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdXBkYXRlIHRoZSBpbnN0YW5jZSBmb3IgbmV3IGluc3RhbmNlcyBhcyB3ZWxsIGFzIHJldXNlZFxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2VzIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyByb3V0ZVxyXG4gICAgICAgICAgICAgICAgdG8uaW5zdGFuY2VzW25hbWVdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBmb3IgYSBkaWZmZXJlbnQgcm91dGUgb3IgbmFtZSBzb1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgY29weSBhbnkgc2F2ZWQgdXBkYXRlIG9yIGxlYXZlIGd1YXJkcy4gV2l0aCBhc3luYyBzZXR1cCwgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGluZyBjb21wb25lbnQgd2lsbCBtb3VudCBiZWZvcmUgdGhlIG1hdGNoZWRSb3V0ZSBjaGFuZ2VzLFxyXG4gICAgICAgICAgICAgICAgLy8gbWFraW5nIGluc3RhbmNlID09PSBvbGRJbnN0YW5jZSwgc28gd2UgY2hlY2sgaWYgZ3VhcmRzIGhhdmUgYmVlblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgYmVmb3JlLiBUaGlzIHdvcmtzIGJlY2F1c2Ugd2UgcmVtb3ZlIGd1YXJkcyB3aGVuXHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50aW5nL2RlYWN0aXZhdGluZyBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiBmcm9tICE9PSB0byAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZSA9PT0gb2xkSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLmxlYXZlR3VhcmRzLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG8ubGVhdmVHdWFyZHMgPSBmcm9tLmxlYXZlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLnVwZGF0ZUd1YXJkcy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLnVwZGF0ZUd1YXJkcyA9IGZyb20udXBkYXRlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGJlZm9yZVJvdXRlRW50ZXIgbmV4dCBjYWxsYmFja3NcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICB0byAmJlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYnV0IHRvIGFuZCBmcm9tIGFyZSB0aGUgc2FtZSB0aGlzIG1pZ2h0IGJlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmlzaXRcclxuICAgICAgICAgICAgICAgICghZnJvbSB8fCAhaXNTYW1lUm91dGVSZWNvcmQodG8sIGZyb20pIHx8ICFvbGRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICh0by5lbnRlckNhbGxiYWNrc1tuYW1lXSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgeyBmbHVzaDogJ3Bvc3QnIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVUb0Rpc3BsYXkudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRSb3V0ZSA9IG1hdGNoZWRSb3V0ZVJlZi52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgVmlld0NvbXBvbmVudCA9IG1hdGNoZWRSb3V0ZSAmJiBtYXRjaGVkUm91dGUuY29tcG9uZW50c1twcm9wcy5uYW1lXTtcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgdmFsdWUgYXQgdGhlIHRpbWUgd2UgcmVuZGVyIGJlY2F1c2Ugd2hlbiB3ZSB1bm1vdW50LCB3ZVxyXG4gICAgICAgICAgICAvLyBuYXZpZ2F0ZWQgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gc28gdGhlIHZhbHVlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmFtZSA9IHByb3BzLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICghVmlld0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3Qoc2xvdHMuZGVmYXVsdCwgeyBDb21wb25lbnQ6IFZpZXdDb21wb25lbnQsIHJvdXRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZyb20gcm91dGUgY29uZmlndXJhdGlvblxyXG4gICAgICAgICAgICBjb25zdCByb3V0ZVByb3BzT3B0aW9uID0gbWF0Y2hlZFJvdXRlLnByb3BzW3Byb3BzLm5hbWVdO1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZVByb3BzID0gcm91dGVQcm9wc09wdGlvblxyXG4gICAgICAgICAgICAgICAgPyByb3V0ZVByb3BzT3B0aW9uID09PSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyByb3V0ZS5wYXJhbXNcclxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiByb3V0ZVByb3BzT3B0aW9uID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcm91dGVQcm9wc09wdGlvbihyb3V0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByb3V0ZVByb3BzT3B0aW9uXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uVm5vZGVVbm1vdW50ZWQgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGluc3RhbmNlIHJlZmVyZW5jZSB0byBwcmV2ZW50IGxlYWtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5jb21wb25lbnQuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUm91dGUuaW5zdGFuY2VzW2N1cnJlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGgoVmlld0NvbXBvbmVudCwgYXNzaWduKHt9LCByb3V0ZVByb3BzLCBhdHRycywge1xyXG4gICAgICAgICAgICAgICAgb25Wbm9kZVVubW91bnRlZCxcclxuICAgICAgICAgICAgICAgIHJlZjogdmlld1JlZixcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmXHJcbiAgICAgICAgICAgICAgICBpc0Jyb3dzZXIgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhbiBkaXNwbGF5IGlmIGl0J3MgYW4gYWxpYXMsIGl0cyBwcm9wc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkZXB0aCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaGVkUm91dGUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBtYXRjaGVkUm91dGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtYXRjaGVkUm91dGUubWV0YSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlcyA9IEFycmF5LmlzQXJyYXkoY29tcG9uZW50LnJlZilcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvbmVudC5yZWYubWFwKHIgPT4gci5pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogW2NvbXBvbmVudC5yZWYuaV07XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX192cnZfZGV2dG9vbHMgPSBpbmZvO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgdm5vZGUgdG8gdGhlIHNsb3QgYXMgYSBwcm9wLlxyXG4gICAgICAgICAgICAvLyBoIGFuZCA8Y29tcG9uZW50IDppcz1cIi4uLlwiPiBib3RoIGFjY2VwdCB2bm9kZXNcclxuICAgICAgICAgICAgbm9ybWFsaXplU2xvdChzbG90cy5kZWZhdWx0LCB7IENvbXBvbmVudDogY29tcG9uZW50LCByb3V0ZSB9KSB8fFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNsb3Qoc2xvdCwgZGF0YSkge1xyXG4gICAgaWYgKCFzbG90KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgY29uc3Qgc2xvdENvbnRlbnQgPSBzbG90KGRhdGEpO1xyXG4gICAgcmV0dXJuIHNsb3RDb250ZW50Lmxlbmd0aCA9PT0gMSA/IHNsb3RDb250ZW50WzBdIDogc2xvdENvbnRlbnQ7XHJcbn1cclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdG8gZGlzcGxheSB0aGUgY3VycmVudCByb3V0ZSB0aGUgdXNlciBpcyBhdC5cclxuICovXHJcbmNvbnN0IFJvdXRlclZpZXcgPSBSb3V0ZXJWaWV3SW1wbDtcclxuLy8gd2FybiBhZ2FpbnN0IGRlcHJlY2F0ZWQgdXNhZ2Ugd2l0aCA8dHJhbnNpdGlvbj4gJiA8a2VlcC1hbGl2ZT5cclxuLy8gZHVlIHRvIGZ1bmN0aW9uYWwgY29tcG9uZW50IGJlaW5nIG5vIGxvbmdlciBlYWdlciBpbiBWdWUgM1xyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRlZFVzYWdlKCkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGNvbnN0IHBhcmVudE5hbWUgPSBpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnR5cGUubmFtZTtcclxuICAgIGlmIChwYXJlbnROYW1lICYmXHJcbiAgICAgICAgKHBhcmVudE5hbWUgPT09ICdLZWVwQWxpdmUnIHx8IHBhcmVudE5hbWUuaW5jbHVkZXMoJ1RyYW5zaXRpb24nKSkpIHtcclxuICAgICAgICBjb25zdCBjb21wID0gcGFyZW50TmFtZSA9PT0gJ0tlZXBBbGl2ZScgPyAna2VlcC1hbGl2ZScgOiAndHJhbnNpdGlvbic7XHJcbiAgICAgICAgd2FybihgPHJvdXRlci12aWV3PiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgZGlyZWN0bHkgaW5zaWRlIDx0cmFuc2l0aW9uPiBvciA8a2VlcC1hbGl2ZT4uXFxuYCArXHJcbiAgICAgICAgICAgIGBVc2Ugc2xvdCBwcm9wcyBpbnN0ZWFkOlxcblxcbmAgK1xyXG4gICAgICAgICAgICBgPHJvdXRlci12aWV3IHYtc2xvdD1cInsgQ29tcG9uZW50IH1cIj5cXG5gICtcclxuICAgICAgICAgICAgYCAgPCR7Y29tcH0+XFxuYCArXHJcbiAgICAgICAgICAgIGAgICAgPGNvbXBvbmVudCA6aXM9XCJDb21wb25lbnRcIiAvPlxcbmAgK1xyXG4gICAgICAgICAgICBgICA8LyR7Y29tcH0+XFxuYCArXHJcbiAgICAgICAgICAgIGA8L3JvdXRlci12aWV3PmApO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJvdXRlTG9jYXRpb24ocm91dGVMb2NhdGlvbiwgdG9vbHRpcCkge1xyXG4gICAgY29uc3QgY29weSA9IGFzc2lnbih7fSwgcm91dGVMb2NhdGlvbiwge1xyXG4gICAgICAgIC8vIHJlbW92ZSB2YXJpYWJsZXMgdGhhdCBjYW4gY29udGFpbiB2dWUgaW5zdGFuY2VzXHJcbiAgICAgICAgbWF0Y2hlZDogcm91dGVMb2NhdGlvbi5tYXRjaGVkLm1hcChtYXRjaGVkID0+IG9taXQobWF0Y2hlZCwgWydpbnN0YW5jZXMnLCAnY2hpbGRyZW4nLCAnYWxpYXNPZiddKSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICB0eXBlOiBudWxsLFxyXG4gICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgZGlzcGxheTogcm91dGVMb2NhdGlvbi5mdWxsUGF0aCxcclxuICAgICAgICAgICAgdG9vbHRpcCxcclxuICAgICAgICAgICAgdmFsdWU6IGNvcHksXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0RGlzcGxheShkaXNwbGF5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgZGlzcGxheSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG4vLyB0byBzdXBwb3J0IG11bHRpcGxlIHJvdXRlciBpbnN0YW5jZXNcclxubGV0IHJvdXRlcklkID0gMDtcclxuZnVuY3Rpb24gYWRkRGV2dG9vbHMoYXBwLCByb3V0ZXIsIG1hdGNoZXIpIHtcclxuICAgIC8vIFRha2Ugb3ZlciByb3V0ZXIuYmVmb3JlRWFjaCBhbmQgYWZ0ZXJFYWNoXHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIG5vdCByZWdpc3RlcmluZyB0aGUgZGV2dG9vbCB0d2ljZVxyXG4gICAgaWYgKHJvdXRlci5fX2hhc0RldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHJvdXRlci5fX2hhc0RldnRvb2xzID0gdHJ1ZTtcclxuICAgIC8vIGluY3JlbWVudCB0byBzdXBwb3J0IG11bHRpcGxlIHJvdXRlciBpbnN0YW5jZXNcclxuICAgIGNvbnN0IGlkID0gcm91dGVySWQrKztcclxuICAgIHNldHVwRGV2dG9vbHNQbHVnaW4oe1xyXG4gICAgICAgIGlkOiAnb3JnLnZ1ZWpzLnJvdXRlcicgKyAoaWQgPyAnLicgKyBpZCA6ICcnKSxcclxuICAgICAgICBsYWJlbDogJ1Z1ZSBSb3V0ZXInLFxyXG4gICAgICAgIHBhY2thZ2VOYW1lOiAndnVlLXJvdXRlcicsXHJcbiAgICAgICAgaG9tZXBhZ2U6ICdodHRwczovL3JvdXRlci52dWVqcy5vcmcnLFxyXG4gICAgICAgIGxvZ286ICdodHRwczovL3JvdXRlci52dWVqcy5vcmcvbG9nby5wbmcnLFxyXG4gICAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXM6IFsnUm91dGluZyddLFxyXG4gICAgICAgIGFwcCxcclxuICAgIH0sIGFwaSA9PiB7XHJcbiAgICAgICAgLy8gZGlzcGxheSBzdGF0ZSBhZGRlZCBieSB0aGUgcm91dGVyXHJcbiAgICAgICAgYXBpLm9uLmluc3BlY3RDb21wb25lbnQoKHBheWxvYWQsIGN0eCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5pbnN0YW5jZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSb3V0aW5nJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICckcm91dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0Um91dGVMb2NhdGlvbihyb3V0ZXIuY3VycmVudFJvdXRlLnZhbHVlLCAnQ3VycmVudCBSb3V0ZScpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBtYXJrIHJvdXRlci1saW5rIGFzIGFjdGl2ZSBhbmQgZGlzcGxheSB0YWdzIG9uIHJvdXRlciB2aWV3c1xyXG4gICAgICAgIGFwaS5vbi52aXNpdENvbXBvbmVudFRyZWUoKHsgdHJlZU5vZGU6IG5vZGUsIGNvbXBvbmVudEluc3RhbmNlIH0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEluc3RhbmNlLl9fdnJ2X2RldnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gY29tcG9uZW50SW5zdGFuY2UuX192cnZfZGV2dG9vbHM7XHJcbiAgICAgICAgICAgICAgICBub2RlLnRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IChpbmZvLm5hbWUgPyBgJHtpbmZvLm5hbWUudG9TdHJpbmcoKX06IGAgOiAnJykgKyBpbmZvLnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdUaGlzIGNvbXBvbmVudCBpcyByZW5kZXJlZCBieSAmbHQ7cm91dGVyLXZpZXcmZ3Q7JyxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFBJTktfNTAwLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgdXNlTGluayBhcmUgdXNlZFxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnRJbnN0YW5jZS5fX3ZybF9kZXZ0b29scykpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9fZGV2dG9vbHNBcGkgPSBhcGk7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5fX3ZybF9kZXZ0b29scy5mb3JFYWNoKGRldnRvb2xzRGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhY2tncm91bmRDb2xvciA9IE9SQU5HRV80MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2dG9vbHNEYXRhLmlzRXhhY3RBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gTElNRV81MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAgPSAnVGhpcyBpcyBleGFjdGx5IGFjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRldnRvb2xzRGF0YS5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBCTFVFXzYwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9ICdUaGlzIGxpbmsgaXMgYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGV2dG9vbHNEYXRhLnJvdXRlLnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB3YXRjaChyb3V0ZXIuY3VycmVudFJvdXRlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggYWN0aXZlIHN0YXRlXHJcbiAgICAgICAgICAgIHJlZnJlc2hSb3V0ZXNWaWV3KCk7XHJcbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcclxuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKHJvdXRlckluc3BlY3RvcklkKTtcclxuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShyb3V0ZXJJbnNwZWN0b3JJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbmF2aWdhdGlvbnNMYXllcklkID0gJ3JvdXRlcjpuYXZpZ2F0aW9uczonICsgaWQ7XHJcbiAgICAgICAgYXBpLmFkZFRpbWVsaW5lTGF5ZXIoe1xyXG4gICAgICAgICAgICBpZDogbmF2aWdhdGlvbnNMYXllcklkLFxyXG4gICAgICAgICAgICBsYWJlbDogYFJvdXRlciR7aWQgPyAnICcgKyBpZCA6ICcnfSBOYXZpZ2F0aW9uc2AsXHJcbiAgICAgICAgICAgIGNvbG9yOiAweDQwYThjNCxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjb25zdCBlcnJvcnNMYXllcklkID0gJ3JvdXRlcjplcnJvcnMnXHJcbiAgICAgICAgLy8gYXBpLmFkZFRpbWVsaW5lTGF5ZXIoe1xyXG4gICAgICAgIC8vICAgaWQ6IGVycm9yc0xheWVySWQsXHJcbiAgICAgICAgLy8gICBsYWJlbDogJ1JvdXRlciBFcnJvcnMnLFxyXG4gICAgICAgIC8vICAgY29sb3I6IDB4ZWE1NDU1LFxyXG4gICAgICAgIC8vIH0pXHJcbiAgICAgICAgcm91dGVyLm9uRXJyb3IoKGVycm9yLCB0bykgPT4ge1xyXG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XHJcbiAgICAgICAgICAgICAgICBsYXllcklkOiBuYXZpZ2F0aW9uc0xheWVySWQsXHJcbiAgICAgICAgICAgICAgICBldmVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgZHVyaW5nIE5hdmlnYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiB0by5mdWxsUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGFwaS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGVycm9yIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdG8ubWV0YS5fX25hdmlnYXRpb25JZCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIGBtZXRhYCBhbmQgdXNlZCB0byBncm91cCBldmVudHNcclxuICAgICAgICBsZXQgbmF2aWdhdGlvbklkID0gMDtcclxuICAgICAgICByb3V0ZXIuYmVmb3JlRWFjaCgodG8sIGZyb20pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGd1YXJkOiBmb3JtYXREaXNwbGF5KCdiZWZvcmVFYWNoJyksXHJcbiAgICAgICAgICAgICAgICBmcm9tOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKGZyb20sICdDdXJyZW50IExvY2F0aW9uIGR1cmluZyB0aGlzIG5hdmlnYXRpb24nKSxcclxuICAgICAgICAgICAgICAgIHRvOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKHRvLCAnVGFyZ2V0IGxvY2F0aW9uJyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gZ3JvdXAgbmF2aWdhdGlvbnMgdG9nZXRoZXIsIGhpZGUgZnJvbSBkZXZ0b29sc1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8ubWV0YSwgJ19fbmF2aWdhdGlvbklkJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hdmlnYXRpb25JZCsrLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogbmF2aWdhdGlvbnNMYXllcklkLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBhcGkubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdGFydCBvZiBuYXZpZ2F0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogdG8uZnVsbFBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiB0by5tZXRhLl9fbmF2aWdhdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcm91dGVyLmFmdGVyRWFjaCgodG8sIGZyb20sIGZhaWx1cmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGd1YXJkOiBmb3JtYXREaXNwbGF5KCdhZnRlckVhY2gnKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuZmFpbHVyZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFpbHVyZSA/IGZhaWx1cmUubWVzc2FnZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnTmF2aWdhdGlvbiBGYWlsdXJlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhaWx1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IGZvcm1hdERpc3BsYXkoJ+KdjCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5zdGF0dXMgPSBmb3JtYXREaXNwbGF5KCfinIUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBzZXQgaGVyZSB0byBoYXZlIHRoZSByaWdodCBvcmRlclxyXG4gICAgICAgICAgICBkYXRhLmZyb20gPSBmb3JtYXRSb3V0ZUxvY2F0aW9uKGZyb20sICdDdXJyZW50IExvY2F0aW9uIGR1cmluZyB0aGlzIG5hdmlnYXRpb24nKTtcclxuICAgICAgICAgICAgZGF0YS50byA9IGZvcm1hdFJvdXRlTG9jYXRpb24odG8sICdUYXJnZXQgbG9jYXRpb24nKTtcclxuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogbmF2aWdhdGlvbnNMYXllcklkLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0VuZCBvZiBuYXZpZ2F0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogdG8uZnVsbFBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogYXBpLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nVHlwZTogZmFpbHVyZSA/ICd3YXJuaW5nJyA6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiB0by5tZXRhLl9fbmF2aWdhdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zcGVjdG9yIG9mIEV4aXN0aW5nIHJvdXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHJvdXRlckluc3BlY3RvcklkID0gJ3JvdXRlci1pbnNwZWN0b3I6JyArIGlkO1xyXG4gICAgICAgIGFwaS5hZGRJbnNwZWN0b3Ioe1xyXG4gICAgICAgICAgICBpZDogcm91dGVySW5zcGVjdG9ySWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnUm91dGVzJyArIChpZCA/ICcgJyArIGlkIDogJycpLFxyXG4gICAgICAgICAgICBpY29uOiAnYm9vaycsXHJcbiAgICAgICAgICAgIHRyZWVGaWx0ZXJQbGFjZWhvbGRlcjogJ1NlYXJjaCByb3V0ZXMnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hSb3V0ZXNWaWV3KCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcm91dGVzIHZpZXcgaXNuJ3QgYWN0aXZlXHJcbiAgICAgICAgICAgIGlmICghYWN0aXZlUm91dGVzUGF5bG9hZClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGFjdGl2ZVJvdXRlc1BheWxvYWQ7XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIHJvdXRlcyB3aWxsIGFwcGVhciBhcyBuZXN0ZWRcclxuICAgICAgICAgICAgbGV0IHJvdXRlcyA9IG1hdGNoZXIuZ2V0Um91dGVzKCkuZmlsdGVyKHJvdXRlID0+ICFyb3V0ZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAvLyByZXNldCBtYXRjaCBzdGF0ZSB0byBmYWxzZVxyXG4gICAgICAgICAgICByb3V0ZXMuZm9yRWFjaChyZXNldE1hdGNoU3RhdGVPblJvdXRlUmVjb3JkKTtcclxuICAgICAgICAgICAgLy8gYXBwbHkgYSBtYXRjaCBzdGF0ZSBpZiB0aGVyZSBpcyBhIHBheWxvYWRcclxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZXMgPSByb3V0ZXMuZmlsdGVyKHJvdXRlID0+IFxyXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBtYXRjaGVzIHN0YXRlIGJhc2VkIG9uIHRoZSBwYXlsb2FkXHJcbiAgICAgICAgICAgICAgICBpc1JvdXRlTWF0Y2hpbmcocm91dGUsIHBheWxvYWQuZmlsdGVyLnRvTG93ZXJDYXNlKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYXJrIGFjdGl2ZSByb3V0ZXNcclxuICAgICAgICAgICAgcm91dGVzLmZvckVhY2gocm91dGUgPT4gbWFya1JvdXRlUmVjb3JkQWN0aXZlKHJvdXRlLCByb3V0ZXIuY3VycmVudFJvdXRlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHBheWxvYWQucm9vdE5vZGVzID0gcm91dGVzLm1hcChmb3JtYXRSb3V0ZVJlY29yZEZvckluc3BlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhY3RpdmVSb3V0ZXNQYXlsb2FkO1xyXG4gICAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JUcmVlKHBheWxvYWQgPT4ge1xyXG4gICAgICAgICAgICBhY3RpdmVSb3V0ZXNQYXlsb2FkID0gcGF5bG9hZDtcclxuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gcm91dGVySW5zcGVjdG9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHJlZnJlc2hSb3V0ZXNWaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNwbGF5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm91dGUgcmVjb3JkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclN0YXRlKHBheWxvYWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSByb3V0ZXJJbnNwZWN0b3JJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVzID0gbWF0Y2hlci5nZXRSb3V0ZXMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVzLmZpbmQocm91dGUgPT4gcm91dGUucmVjb3JkLl9fdmRfaWQgPT09IHBheWxvYWQubm9kZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGZvcm1hdFJvdXRlUmVjb3JkTWF0Y2hlckZvclN0YXRlSW5zcGVjdG9yKHJvdXRlKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKHJvdXRlckluc3BlY3RvcklkKTtcclxuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKHJvdXRlckluc3BlY3RvcklkKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG1vZGlmaWVyRm9yS2V5KGtleSkge1xyXG4gICAgaWYgKGtleS5vcHRpb25hbCkge1xyXG4gICAgICAgIHJldHVybiBrZXkucmVwZWF0YWJsZSA/ICcqJyA6ICc/JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBrZXkucmVwZWF0YWJsZSA/ICcrJyA6ICcnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFJvdXRlUmVjb3JkTWF0Y2hlckZvclN0YXRlSW5zcGVjdG9yKHJvdXRlKSB7XHJcbiAgICBjb25zdCB7IHJlY29yZCB9ID0gcm91dGU7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXHJcbiAgICAgICAgeyBlZGl0YWJsZTogZmFsc2UsIGtleTogJ3BhdGgnLCB2YWx1ZTogcmVjb3JkLnBhdGggfSxcclxuICAgIF07XHJcbiAgICBpZiAocmVjb3JkLm5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHtcclxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBrZXk6ICduYW1lJyxcclxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5uYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZmllbGRzLnB1c2goeyBlZGl0YWJsZTogZmFsc2UsIGtleTogJ3JlZ2V4cCcsIHZhbHVlOiByb3V0ZS5yZSB9KTtcclxuICAgIGlmIChyb3V0ZS5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHtcclxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBrZXk6ICdrZXlzJyxcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHJvdXRlLmtleXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gYCR7a2V5Lm5hbWV9JHttb2RpZmllckZvcktleShrZXkpfWApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyksXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1BhcmFtIGtleXMnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5rZXlzLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyZWNvcmQucmVkaXJlY3QgIT0gbnVsbCkge1xyXG4gICAgICAgIGZpZWxkcy5wdXNoKHtcclxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBrZXk6ICdyZWRpcmVjdCcsXHJcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQucmVkaXJlY3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuYWxpYXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ2FsaWFzZXMnLFxyXG4gICAgICAgICAgICB2YWx1ZTogcm91dGUuYWxpYXMubWFwKGFsaWFzID0+IGFsaWFzLnJlY29yZC5wYXRoKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpZWxkcy5wdXNoKHtcclxuICAgICAgICBrZXk6ICdzY29yZScsXHJcbiAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgIF9jdXN0b206IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHJvdXRlLnNjb3JlLm1hcChzY29yZSA9PiBzY29yZS5qb2luKCcsICcpKS5qb2luKCcgfCAnKSxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTY29yZSB1c2VkIHRvIHNvcnQgcm91dGVzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5zY29yZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmllbGRzO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0ZWQgZnJvbSB0YWlsd2luZCBwYWxldHRlXHJcbiAqL1xyXG5jb25zdCBQSU5LXzUwMCA9IDB4ZWM0ODk5O1xyXG5jb25zdCBCTFVFXzYwMCA9IDB4MjU2M2ViO1xyXG5jb25zdCBMSU1FXzUwMCA9IDB4ODRjYzE2O1xyXG5jb25zdCBDWUFOXzQwMCA9IDB4MjJkM2VlO1xyXG5jb25zdCBPUkFOR0VfNDAwID0gMHhmYjkyM2M7XHJcbi8vIGNvbnN0IEdSQVlfMTAwID0gMHhmNGY0ZjVcclxuY29uc3QgREFSSyA9IDB4NjY2NjY2O1xyXG5mdW5jdGlvbiBmb3JtYXRSb3V0ZVJlY29yZEZvckluc3BlY3Rvcihyb3V0ZSkge1xyXG4gICAgY29uc3QgdGFncyA9IFtdO1xyXG4gICAgY29uc3QgeyByZWNvcmQgfSA9IHJvdXRlO1xyXG4gICAgaWYgKHJlY29yZC5uYW1lICE9IG51bGwpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogU3RyaW5nKHJlY29yZC5uYW1lKSxcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENZQU5fNDAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY29yZC5hbGlhc09mKSB7XHJcbiAgICAgICAgdGFncy5wdXNoKHtcclxuICAgICAgICAgICAgbGFiZWw6ICdhbGlhcycsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBPUkFOR0VfNDAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJvdXRlLl9fdmRfbWF0Y2gpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ21hdGNoZXMnLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogUElOS181MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuX192ZF9leGFjdEFjdGl2ZSkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnZXhhY3QnLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogTElNRV81MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuX192ZF9hY3RpdmUpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ2FjdGl2ZScsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBCTFVFXzYwMCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyZWNvcmQucmVkaXJlY3QpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ3JlZGlyZWN0OiAnICtcclxuICAgICAgICAgICAgICAgICh0eXBlb2YgcmVjb3JkLnJlZGlyZWN0ID09PSAnc3RyaW5nJyA/IHJlY29yZC5yZWRpcmVjdCA6ICdPYmplY3QnKSxcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAweGZmZmZmZixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBEQVJLLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gYWRkIGFuIGlkIHRvIGJlIGFibGUgdG8gc2VsZWN0IGl0LiBVc2luZyB0aGUgYHBhdGhgIGlzIG5vdCBwb3NzaWJsZSBiZWNhdXNlXHJcbiAgICAvLyBlbXB0eSBwYXRoIGNoaWxkcmVuIHdvdWxkIGNvbGxpZGUgd2l0aCB0aGVpciBwYXJlbnRzXHJcbiAgICBsZXQgaWQgPSByZWNvcmQuX192ZF9pZDtcclxuICAgIGlmIChpZCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWQgPSBTdHJpbmcocm91dGVSZWNvcmRJZCsrKTtcclxuICAgICAgICByZWNvcmQuX192ZF9pZCA9IGlkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBsYWJlbDogcmVjb3JkLnBhdGgsXHJcbiAgICAgICAgdGFncyxcclxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW4ubWFwKGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKSxcclxuICAgIH07XHJcbn1cclxuLy8gIGluY3JlbWVudGFsIGlkIGZvciByb3V0ZSByZWNvcmRzIGFuZCBpbnNwZWN0b3Igc3RhdGVcclxubGV0IHJvdXRlUmVjb3JkSWQgPSAwO1xyXG5jb25zdCBFWFRSQUNUX1JFR0VYUF9SRSA9IC9eXFwvKC4qKVxcLyhbYS16XSopJC87XHJcbmZ1bmN0aW9uIG1hcmtSb3V0ZVJlY29yZEFjdGl2ZShyb3V0ZSwgY3VycmVudFJvdXRlKSB7XHJcbiAgICAvLyBubyByb3V0ZSB3aWxsIGJlIGFjdGl2ZSBpZiBtYXRjaGVkIGlzIGVtcHR5XHJcbiAgICAvLyByZXNldCB0aGUgbWF0Y2hpbmcgc3RhdGVcclxuICAgIGNvbnN0IGlzRXhhY3RBY3RpdmUgPSBjdXJyZW50Um91dGUubWF0Y2hlZC5sZW5ndGggJiZcclxuICAgICAgICBpc1NhbWVSb3V0ZVJlY29yZChjdXJyZW50Um91dGUubWF0Y2hlZFtjdXJyZW50Um91dGUubWF0Y2hlZC5sZW5ndGggLSAxXSwgcm91dGUucmVjb3JkKTtcclxuICAgIHJvdXRlLl9fdmRfZXhhY3RBY3RpdmUgPSByb3V0ZS5fX3ZkX2FjdGl2ZSA9IGlzRXhhY3RBY3RpdmU7XHJcbiAgICBpZiAoIWlzRXhhY3RBY3RpdmUpIHtcclxuICAgICAgICByb3V0ZS5fX3ZkX2FjdGl2ZSA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkLnNvbWUobWF0Y2ggPT4gaXNTYW1lUm91dGVSZWNvcmQobWF0Y2gsIHJvdXRlLnJlY29yZCkpO1xyXG4gICAgfVxyXG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZFJvdXRlID0+IG1hcmtSb3V0ZVJlY29yZEFjdGl2ZShjaGlsZFJvdXRlLCBjdXJyZW50Um91dGUpKTtcclxufVxyXG5mdW5jdGlvbiByZXNldE1hdGNoU3RhdGVPblJvdXRlUmVjb3JkKHJvdXRlKSB7XHJcbiAgICByb3V0ZS5fX3ZkX21hdGNoID0gZmFsc2U7XHJcbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUm91dGVNYXRjaGluZyhyb3V0ZSwgZmlsdGVyKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IFN0cmluZyhyb3V0ZS5yZSkubWF0Y2goRVhUUkFDVF9SRUdFWFBfUkUpO1xyXG4gICAgcm91dGUuX192ZF9tYXRjaCA9IGZhbHNlO1xyXG4gICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gdXNlIGEgcmVnZXhwIHdpdGhvdXQgJCBhdCB0aGUgZW5kIHRvIG1hdGNoIG5lc3RlZCByb3V0ZXMgYmV0dGVyXHJcbiAgICBjb25zdCBub25FbmRpbmdSRSA9IG5ldyBSZWdFeHAoZm91bmRbMV0ucmVwbGFjZSgvXFwkJC8sICcnKSwgZm91bmRbMl0pO1xyXG4gICAgaWYgKG5vbkVuZGluZ1JFLnRlc3QoZmlsdGVyKSkge1xyXG4gICAgICAgIC8vIG1hcmsgY2hpbGRyZW4gYXMgbWF0Y2hlc1xyXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gaXNSb3V0ZU1hdGNoaW5nKGNoaWxkLCBmaWx0ZXIpKTtcclxuICAgICAgICAvLyBleGNlcHRpb24gY2FzZTogYC9gXHJcbiAgICAgICAgaWYgKHJvdXRlLnJlY29yZC5wYXRoICE9PSAnLycgfHwgZmlsdGVyID09PSAnLycpIHtcclxuICAgICAgICAgICAgcm91dGUuX192ZF9tYXRjaCA9IHJvdXRlLnJlLnRlc3QoZmlsdGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhpZGUgdGhlIC8gcm91dGVcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXRoID0gcm91dGUucmVjb3JkLnBhdGgudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGRlY29kZWRQYXRoID0gZGVjb2RlKHBhdGgpO1xyXG4gICAgLy8gYWxzbyBhbGxvdyBwYXJ0aWFsIG1hdGNoaW5nIG9uIHRoZSBwYXRoXHJcbiAgICBpZiAoIWZpbHRlci5zdGFydHNXaXRoKCcvJykgJiZcclxuICAgICAgICAoZGVjb2RlZFBhdGguaW5jbHVkZXMoZmlsdGVyKSB8fCBwYXRoLmluY2x1ZGVzKGZpbHRlcikpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGRlY29kZWRQYXRoLnN0YXJ0c1dpdGgoZmlsdGVyKSB8fCBwYXRoLnN0YXJ0c1dpdGgoZmlsdGVyKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChyb3V0ZS5yZWNvcmQubmFtZSAmJiBTdHJpbmcocm91dGUucmVjb3JkLm5hbWUpLmluY2x1ZGVzKGZpbHRlcikpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gcm91dGUuY2hpbGRyZW4uc29tZShjaGlsZCA9PiBpc1JvdXRlTWF0Y2hpbmcoY2hpbGQsIGZpbHRlcikpO1xyXG59XHJcbmZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgUm91dGVyIGluc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgYnkgYSBWdWUgYXBwLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBSb3V0ZXJPcHRpb25zfVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUm91dGVyKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG1hdGNoZXIgPSBjcmVhdGVSb3V0ZXJNYXRjaGVyKG9wdGlvbnMucm91dGVzLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHBhcnNlUXVlcnkkMSA9IG9wdGlvbnMucGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xyXG4gICAgY29uc3Qgc3RyaW5naWZ5UXVlcnkkMSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XHJcbiAgICBjb25zdCByb3V0ZXJIaXN0b3J5ID0gb3B0aW9ucy5oaXN0b3J5O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcm91dGVySGlzdG9yeSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgdGhlIFwiaGlzdG9yeVwiIG9wdGlvbiB3aGVuIGNhbGxpbmcgXCJjcmVhdGVSb3V0ZXIoKVwiOicgK1xyXG4gICAgICAgICAgICAnIGh0dHBzOi8vbmV4dC5yb3V0ZXIudnVlanMub3JnL2FwaS8jaGlzdG9yeS4nKTtcclxuICAgIGNvbnN0IGJlZm9yZUd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgY29uc3QgYmVmb3JlUmVzb2x2ZUd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgY29uc3QgYWZ0ZXJHdWFyZHMgPSB1c2VDYWxsYmFja3MoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRSb3V0ZSA9IHNoYWxsb3dSZWYoU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCk7XHJcbiAgICBsZXQgcGVuZGluZ0xvY2F0aW9uID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgIC8vIGxlYXZlIHRoZSBzY3JvbGxSZXN0b3JhdGlvbiBpZiBubyBzY3JvbGxCZWhhdmlvciBpcyBwcm92aWRlZFxyXG4gICAgaWYgKGlzQnJvd3NlciAmJiBvcHRpb25zLnNjcm9sbEJlaGF2aW9yICYmICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xyXG4gICAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcclxuICAgIH1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZVBhcmFtcyA9IGFwcGx5VG9QYXJhbXMuYmluZChudWxsLCBwYXJhbVZhbHVlID0+ICcnICsgcGFyYW1WYWx1ZSk7XHJcbiAgICBjb25zdCBlbmNvZGVQYXJhbXMgPSBhcHBseVRvUGFyYW1zLmJpbmQobnVsbCwgZW5jb2RlUGFyYW0pO1xyXG4gICAgY29uc3QgZGVjb2RlUGFyYW1zID0gXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbGx5IGF2b2lkIHRoZSB0eXBlIGNoZWNrXHJcbiAgICBhcHBseVRvUGFyYW1zLmJpbmQobnVsbCwgZGVjb2RlKTtcclxuICAgIGZ1bmN0aW9uIGFkZFJvdXRlKHBhcmVudE9yUm91dGUsIHJvdXRlKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudDtcclxuICAgICAgICBsZXQgcmVjb3JkO1xyXG4gICAgICAgIGlmIChpc1JvdXRlTmFtZShwYXJlbnRPclJvdXRlKSkge1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBtYXRjaGVyLmdldFJlY29yZE1hdGNoZXIocGFyZW50T3JSb3V0ZSk7XHJcbiAgICAgICAgICAgIHJlY29yZCA9IHJvdXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVjb3JkID0gcGFyZW50T3JSb3V0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuYWRkUm91dGUocmVjb3JkLCBwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlUm91dGUobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHJlY29yZE1hdGNoZXIgPSBtYXRjaGVyLmdldFJlY29yZE1hdGNoZXIobmFtZSk7XHJcbiAgICAgICAgaWYgKHJlY29yZE1hdGNoZXIpIHtcclxuICAgICAgICAgICAgbWF0Y2hlci5yZW1vdmVSb3V0ZShyZWNvcmRNYXRjaGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENhbm5vdCByZW1vdmUgbm9uLWV4aXN0ZW50IHJvdXRlIFwiJHtTdHJpbmcobmFtZSl9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSb3V0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuZ2V0Um91dGVzKCkubWFwKHJvdXRlTWF0Y2hlciA9PiByb3V0ZU1hdGNoZXIucmVjb3JkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gISFtYXRjaGVyLmdldFJlY29yZE1hdGNoZXIobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKHJhd0xvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24pIHtcclxuICAgICAgICAvLyBjb25zdCBvYmplY3RMb2NhdGlvbiA9IHJvdXRlckxvY2F0aW9uQXNPYmplY3QocmF3TG9jYXRpb24pXHJcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgY29weSB0byBtb2RpZnkgaXQgbGF0ZXJcclxuICAgICAgICBjdXJyZW50TG9jYXRpb24gPSBhc3NpZ24oe30sIGN1cnJlbnRMb2NhdGlvbiB8fCBjdXJyZW50Um91dGUudmFsdWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3TG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uTm9ybWFsaXplZCA9IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgcmF3TG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFJvdXRlID0gbWF0Y2hlci5yZXNvbHZlKHsgcGF0aDogbG9jYXRpb25Ob3JtYWxpemVkLnBhdGggfSwgY3VycmVudExvY2F0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHJvdXRlckhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbk5vcm1hbGl6ZWQuZnVsbFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaHJlZi5zdGFydHNXaXRoKCcvLycpKVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYExvY2F0aW9uIFwiJHtyYXdMb2NhdGlvbn1cIiByZXNvbHZlZCB0byBcIiR7aHJlZn1cIi4gQSByZXNvbHZlZCBsb2NhdGlvbiBjYW5ub3Qgc3RhcnQgd2l0aCBtdWx0aXBsZSBzbGFzaGVzLmApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZWRSb3V0ZS5tYXRjaGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYE5vIG1hdGNoIGZvdW5kIGZvciBsb2NhdGlvbiB3aXRoIHBhdGggXCIke3Jhd0xvY2F0aW9ufVwiYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbG9jYXRpb25Ob3JtYWxpemVkIGlzIGFsd2F5cyBhIG5ldyBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIGFzc2lnbihsb2NhdGlvbk5vcm1hbGl6ZWQsIG1hdGNoZWRSb3V0ZSwge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBkZWNvZGVQYXJhbXMobWF0Y2hlZFJvdXRlLnBhcmFtcyksXHJcbiAgICAgICAgICAgICAgICBoYXNoOiBkZWNvZGUobG9jYXRpb25Ob3JtYWxpemVkLmhhc2gpLFxyXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb206IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGhyZWYsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2hlckxvY2F0aW9uO1xyXG4gICAgICAgIC8vIHBhdGggY291bGQgYmUgcmVsYXRpdmUgaW4gb2JqZWN0IGFzIHdlbGxcclxuICAgICAgICBpZiAoJ3BhdGgnIGluIHJhd0xvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICdwYXJhbXMnIGluIHJhd0xvY2F0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiByYXdMb2NhdGlvbikgJiZcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSB0eXBlIGlzIG5ldmVyXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdMb2NhdGlvbi5wYXJhbXMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgUGF0aCBcIiR7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGUgdHlwZSBpcyBuZXZlclxyXG4gICAgICAgICAgICAgICAgcmF3TG9jYXRpb24ucGF0aH1cIiB3YXMgcGFzc2VkIHdpdGggcGFyYW1zIGJ1dCB0aGV5IHdpbGwgYmUgaWdub3JlZC4gVXNlIGEgbmFtZWQgcm91dGUgYWxvbmdzaWRlIHBhcmFtcyBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGNoZXJMb2NhdGlvbiA9IGFzc2lnbih7fSwgcmF3TG9jYXRpb24sIHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgcmF3TG9jYXRpb24ucGF0aCwgY3VycmVudExvY2F0aW9uLnBhdGgpLnBhdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBudWxsaXNoIHBhcmFtXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhcmFtcyA9IGFzc2lnbih7fSwgcmF3TG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0UGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UGFyYW1zW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRQYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwYXNzIGVuY29kZWQgdmFsdWVzIHRvIHRoZSBtYXRjaGVyIHNvIGl0IGNhbiBwcm9kdWNlIGVuY29kZWQgcGF0aCBhbmQgZnVsbFBhdGhcclxuICAgICAgICAgICAgbWF0Y2hlckxvY2F0aW9uID0gYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBlbmNvZGVQYXJhbXMocmF3TG9jYXRpb24ucGFyYW1zKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgbG9jYXRpb24gcGFyYW1zIGFyZSBkZWNvZGVkLCB3ZSBuZWVkIHRvIGVuY29kZSB0aGVtIGluIGNhc2UgdGhlXHJcbiAgICAgICAgICAgIC8vIG1hdGNoZXIgbWVyZ2VzIHRoZSBwYXJhbXNcclxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLnBhcmFtcyA9IGVuY29kZVBhcmFtcyhjdXJyZW50TG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlZFJvdXRlID0gbWF0Y2hlci5yZXNvbHZlKG1hdGNoZXJMb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gcmF3TG9jYXRpb24uaGFzaCB8fCAnJztcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc2ggJiYgIWhhc2guc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEEgXFxgaGFzaFxcYCBzaG91bGQgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGNoYXJhY3RlciBcIiNcIi4gUmVwbGFjZSBcIiR7aGFzaH1cIiB3aXRoIFwiIyR7aGFzaH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVjb2RpbmcgdGhlbSkgdGhlIG1hdGNoZXIgbWlnaHQgaGF2ZSBtZXJnZWQgY3VycmVudCBsb2NhdGlvbiBwYXJhbXMgc29cclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJ1biB0aGUgZGVjb2RpbmcgYWdhaW5cclxuICAgICAgICBtYXRjaGVkUm91dGUucGFyYW1zID0gbm9ybWFsaXplUGFyYW1zKGRlY29kZVBhcmFtcyhtYXRjaGVkUm91dGUucGFyYW1zKSk7XHJcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBzdHJpbmdpZnlVUkwoc3RyaW5naWZ5UXVlcnkkMSwgYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xyXG4gICAgICAgICAgICBoYXNoOiBlbmNvZGVIYXNoKGhhc2gpLFxyXG4gICAgICAgICAgICBwYXRoOiBtYXRjaGVkUm91dGUucGF0aCxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc3QgaHJlZiA9IHJvdXRlckhpc3RvcnkuY3JlYXRlSHJlZihmdWxsUGF0aCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBpZiAoaHJlZi5zdGFydHNXaXRoKCcvLycpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBMb2NhdGlvbiBcIiR7cmF3TG9jYXRpb259XCIgcmVzb2x2ZWQgdG8gXCIke2hyZWZ9XCIuIEEgcmVzb2x2ZWQgbG9jYXRpb24gY2Fubm90IHN0YXJ0IHdpdGggbXVsdGlwbGUgc2xhc2hlcy5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghbWF0Y2hlZFJvdXRlLm1hdGNoZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBObyBtYXRjaCBmb3VuZCBmb3IgbG9jYXRpb24gd2l0aCBwYXRoIFwiJHsncGF0aCcgaW4gcmF3TG9jYXRpb24gPyByYXdMb2NhdGlvbi5wYXRoIDogcmF3TG9jYXRpb259XCJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXNzaWduKHtcclxuICAgICAgICAgICAgZnVsbFBhdGgsXHJcbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIGhhc2ggZW5jb2RlZCBzbyBmdWxsUGF0aCBpcyBlZmZlY3RpdmVseSBwYXRoICsgZW5jb2RlZFF1ZXJ5ICtcclxuICAgICAgICAgICAgLy8gaGFzaFxyXG4gICAgICAgICAgICBoYXNoLFxyXG4gICAgICAgICAgICBxdWVyeTogXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGlzIHVzaW5nIGEgY3VzdG9tIHF1ZXJ5IGxpYiBsaWtlIHFzLCB3ZSBtaWdodCBoYXZlXHJcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzLCBzbyB3ZSBrZWVwIHRoZSBxdWVyeSBhcyBpcywgbWVhbmluZyBpdCBjYW4gY29udGFpblxyXG4gICAgICAgICAgICAvLyBudW1iZXJzIGF0IGAkcm91dGUucXVlcnlgLCBidXQgYXQgdGhlIHBvaW50LCB0aGUgdXNlciB3aWxsIGhhdmUgdG9cclxuICAgICAgICAgICAgLy8gdXNlIHRoZWlyIG93biB0eXBlIGFueXdheS5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvdXRlci9pc3N1ZXMvMzI4I2lzc3VlY29tbWVudC02NDk0ODE1NjdcclxuICAgICAgICAgICAgc3RyaW5naWZ5UXVlcnkkMSA9PT0gc3RyaW5naWZ5UXVlcnlcclxuICAgICAgICAgICAgICAgID8gbm9ybWFsaXplUXVlcnkocmF3TG9jYXRpb24ucXVlcnkpXHJcbiAgICAgICAgICAgICAgICA6IChyYXdMb2NhdGlvbi5xdWVyeSB8fCB7fSksXHJcbiAgICAgICAgfSwgbWF0Y2hlZFJvdXRlLCB7XHJcbiAgICAgICAgICAgIHJlZGlyZWN0ZWRGcm9tOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGhyZWYsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsb2NhdGlvbkFzT2JqZWN0KHRvKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBwYXJzZVVSTChwYXJzZVF1ZXJ5JDEsIHRvLCBjdXJyZW50Um91dGUudmFsdWUucGF0aClcclxuICAgICAgICAgICAgOiBhc3NpZ24oe30sIHRvKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uKHRvLCBmcm9tKSB7XHJcbiAgICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJvdXRlckVycm9yKDggLyogTkFWSUdBVElPTl9DQU5DRUxMRUQgKi8sIHtcclxuICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaCh0bykge1xyXG4gICAgICAgIHJldHVybiBwdXNoV2l0aFJlZGlyZWN0KHRvKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2UodG8pIHtcclxuICAgICAgICByZXR1cm4gcHVzaChhc3NpZ24obG9jYXRpb25Bc09iamVjdCh0byksIHsgcmVwbGFjZTogdHJ1ZSB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZWRpcmVjdFJlY29yZCh0bykge1xyXG4gICAgICAgIGNvbnN0IGxhc3RNYXRjaGVkID0gdG8ubWF0Y2hlZFt0by5tYXRjaGVkLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChsYXN0TWF0Y2hlZCAmJiBsYXN0TWF0Y2hlZC5yZWRpcmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHJlZGlyZWN0IH0gPSBsYXN0TWF0Y2hlZDtcclxuICAgICAgICAgICAgbGV0IG5ld1RhcmdldExvY2F0aW9uID0gdHlwZW9mIHJlZGlyZWN0ID09PSAnZnVuY3Rpb24nID8gcmVkaXJlY3QodG8pIDogcmVkaXJlY3Q7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGFyZ2V0TG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFyZ2V0TG9jYXRpb24uaW5jbHVkZXMoJz8nKSB8fCBuZXdUYXJnZXRMb2NhdGlvbi5pbmNsdWRlcygnIycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKG5ld1RhcmdldExvY2F0aW9uID0gbG9jYXRpb25Bc09iamVjdChuZXdUYXJnZXRMb2NhdGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gZm9yY2UgZW1wdHkgcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHBhdGg6IG5ld1RhcmdldExvY2F0aW9uIH07XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBmb3JjZSBlbXB0eSBwYXJhbXMgd2hlbiBhIHN0cmluZyBpcyBwYXNzZWQgdG8gbGV0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm91dGVyIHBhcnNlIHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldExvY2F0aW9uLnBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICEoJ3BhdGgnIGluIG5ld1RhcmdldExvY2F0aW9uKSAmJlxyXG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gbmV3VGFyZ2V0TG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHJlZGlyZWN0IGZvdW5kOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3VGFyZ2V0TG9jYXRpb24sIG51bGwsIDIpfVxcbiB3aGVuIG5hdmlnYXRpbmcgdG8gXCIke3RvLmZ1bGxQYXRofVwiLiBBIHJlZGlyZWN0IG11c3QgY29udGFpbiBhIG5hbWUgb3IgcGF0aC4gVGhpcyB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVkaXJlY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB0by5xdWVyeSxcclxuICAgICAgICAgICAgICAgIGhhc2g6IHRvLmhhc2gsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHRvLnBhcmFtcyxcclxuICAgICAgICAgICAgfSwgbmV3VGFyZ2V0TG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1c2hXaXRoUmVkaXJlY3QodG8sIHJlZGlyZWN0ZWRGcm9tKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0TG9jYXRpb24gPSAocGVuZGluZ0xvY2F0aW9uID0gcmVzb2x2ZSh0bykpO1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50Um91dGUudmFsdWU7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRvLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGZvcmNlID0gdG8uZm9yY2U7XHJcbiAgICAgICAgLy8gdG8gY291bGQgYmUgYSBzdHJpbmcgd2hlcmUgYHJlcGxhY2VgIGlzIGEgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCByZXBsYWNlID0gdG8ucmVwbGFjZSA9PT0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBzaG91bGRSZWRpcmVjdCA9IGhhbmRsZVJlZGlyZWN0UmVjb3JkKHRhcmdldExvY2F0aW9uKTtcclxuICAgICAgICBpZiAoc2hvdWxkUmVkaXJlY3QpXHJcbiAgICAgICAgICAgIHJldHVybiBwdXNoV2l0aFJlZGlyZWN0KGFzc2lnbihsb2NhdGlvbkFzT2JqZWN0KHNob3VsZFJlZGlyZWN0KSwge1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBmb3JjZSxcclxuICAgICAgICAgICAgICAgIHJlcGxhY2UsXHJcbiAgICAgICAgICAgIH0pLCBcclxuICAgICAgICAgICAgLy8ga2VlcCBvcmlnaW5hbCByZWRpcmVjdGVkRnJvbSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gfHwgdGFyZ2V0TG9jYXRpb24pO1xyXG4gICAgICAgIC8vIGlmIGl0IHdhcyBhIHJlZGlyZWN0IHdlIGFscmVhZHkgY2FsbGVkIGBwdXNoV2l0aFJlZGlyZWN0YCBhYm92ZVxyXG4gICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0YXJnZXRMb2NhdGlvbjtcclxuICAgICAgICB0b0xvY2F0aW9uLnJlZGlyZWN0ZWRGcm9tID0gcmVkaXJlY3RlZEZyb207XHJcbiAgICAgICAgbGV0IGZhaWx1cmU7XHJcbiAgICAgICAgaWYgKCFmb3JjZSAmJiBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIGZyb20sIHRhcmdldExvY2F0aW9uKSkge1xyXG4gICAgICAgICAgICBmYWlsdXJlID0gY3JlYXRlUm91dGVyRXJyb3IoMTYgLyogTkFWSUdBVElPTl9EVVBMSUNBVEVEICovLCB7IHRvOiB0b0xvY2F0aW9uLCBmcm9tIH0pO1xyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHNjcm9sbCB0byBhbGxvdyBzY3JvbGxpbmcgdG8gdGhlIHNhbWUgYW5jaG9yXHJcbiAgICAgICAgICAgIGhhbmRsZVNjcm9sbChmcm9tLCBmcm9tLCBcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHB1c2gsIHRoZSBvbmx5IHdheSBmb3IgaXQgdG8gYmUgdHJpZ2dlcmVkIGZyb20gYVxyXG4gICAgICAgICAgICAvLyBoaXN0b3J5Lmxpc3RlbiBpcyB3aXRoIGEgcmVkaXJlY3QsIHdoaWNoIG1ha2VzIGl0IGJlY29tZSBhIHB1c2hcclxuICAgICAgICAgICAgdHJ1ZSwgXHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIHRoZSBmaXJzdCBuYXZpZ2F0aW9uIGJlY2F1c2UgdGhlIGluaXRpYWwgbG9jYXRpb25cclxuICAgICAgICAgICAgLy8gY2Fubm90IGJlIG1hbnVhbGx5IG5hdmlnYXRlZCB0b1xyXG4gICAgICAgICAgICBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZmFpbHVyZSA/IFByb21pc2UucmVzb2x2ZShmYWlsdXJlKSA6IG5hdmlnYXRlKHRvTG9jYXRpb24sIGZyb20pKVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yKVxyXG4gICAgICAgICAgICA/IC8vIG5hdmlnYXRpb24gcmVkaXJlY3RzIHN0aWxsIG1hcmsgdGhlIHJvdXRlciBhcyByZWFkeVxyXG4gICAgICAgICAgICAgICAgaXNOYXZpZ2F0aW9uRmFpbHVyZShlcnJvciwgMiAvKiBOQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICA6IG1hcmtBc1JlYWR5KGVycm9yKSAvLyBhbHNvIHJldHVybnMgdGhlIGVycm9yXHJcbiAgICAgICAgICAgIDogLy8gcmVqZWN0IGFueSB1bmtub3duIGVycm9yXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3IoZXJyb3IsIHRvTG9jYXRpb24sIGZyb20pKVxyXG4gICAgICAgICAgICAudGhlbigoZmFpbHVyZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZmFpbHVyZSwgMiAvKiBOQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHJlZGlyZWN0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uIHdlIHdlcmUgYWxyZWFkeSBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uKHN0cmluZ2lmeVF1ZXJ5JDEsIHJlc29sdmUoZmFpbHVyZS50byksIHRvTG9jYXRpb24pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBoYXZlIGRvbmUgaXQgYSBjb3VwbGUgb2YgdGltZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYWRkZWQgb25seSBpbiBkZXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlZGlyZWN0ZWRGcm9tLl9jb3VudCA9IHJlZGlyZWN0ZWRGcm9tLl9jb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20uX2NvdW50ICsgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxKSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYERldGVjdGVkIGFuIGluZmluaXRlIHJlZGlyZWN0aW9uIGluIGEgbmF2aWdhdGlvbiBndWFyZCB3aGVuIGdvaW5nIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3RvTG9jYXRpb24uZnVsbFBhdGh9XCIuIEFib3J0aW5nIHRvIGF2b2lkIGEgU3RhY2sgT3ZlcmZsb3cuIFRoaXMgd2lsbCBicmVhayBpbiBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW5maW5pdGUgcmVkaXJlY3QgaW4gbmF2aWdhdGlvbiBndWFyZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1c2hXaXRoUmVkaXJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGxvY2F0aW9uQXNPYmplY3QoZmFpbHVyZS50byksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgcmVkaXJlY3RlZEZyb20gaWYgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZEZyb20gfHwgdG9Mb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmYWlsIHdlIGRvbid0IGZpbmFsaXplIHRoZSBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlID0gZmluYWxpemVOYXZpZ2F0aW9uKHRvTG9jYXRpb24sIGZyb20sIHRydWUsIHJlcGxhY2UsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyaWdnZXJBZnRlckVhY2godG9Mb2NhdGlvbiwgZnJvbSwgZmFpbHVyZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gcmVqZWN0IGFuZCBza2lwIGFsbCBuYXZpZ2F0aW9uIGd1YXJkcyBpZiBhIG5ldyBuYXZpZ2F0aW9uIGhhcHBlbmVkXHJcbiAgICAgKiBAcGFyYW0gdG9cclxuICAgICAqIEBwYXJhbSBmcm9tXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uQW5kUmVqZWN0KHRvLCBmcm9tKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbih0bywgZnJvbSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yID8gUHJvbWlzZS5yZWplY3QoZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiByZWZhY3RvciB0aGUgd2hvbGUgYmVmb3JlIGd1YXJkcyBieSBpbnRlcm5hbGx5IHVzaW5nIHJvdXRlci5iZWZvcmVFYWNoXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgZnJvbSkge1xyXG4gICAgICAgIGxldCBndWFyZHM7XHJcbiAgICAgICAgY29uc3QgW2xlYXZpbmdSZWNvcmRzLCB1cGRhdGluZ1JlY29yZHMsIGVudGVyaW5nUmVjb3Jkc10gPSBleHRyYWN0Q2hhbmdpbmdSZWNvcmRzKHRvLCBmcm9tKTtcclxuICAgICAgICAvLyBhbGwgY29tcG9uZW50cyBoZXJlIGhhdmUgYmVlbiByZXNvbHZlZCBvbmNlIGJlY2F1c2Ugd2UgYXJlIGxlYXZpbmdcclxuICAgICAgICBndWFyZHMgPSBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyhsZWF2aW5nUmVjb3Jkcy5yZXZlcnNlKCksICdiZWZvcmVSb3V0ZUxlYXZlJywgdG8sIGZyb20pO1xyXG4gICAgICAgIC8vIGxlYXZpbmdSZWNvcmRzIGlzIGFscmVhZHkgcmV2ZXJzZWRcclxuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBsZWF2aW5nUmVjb3Jkcykge1xyXG4gICAgICAgICAgICByZWNvcmQubGVhdmVHdWFyZHMuZm9yRWFjaChndWFyZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2sgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbkFuZFJlamVjdC5iaW5kKG51bGwsIHRvLCBmcm9tKTtcclxuICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgLy8gcnVuIHRoZSBxdWV1ZSBvZiBwZXIgcm91dGUgYmVmb3JlUm91dGVMZWF2ZSBndWFyZHNcclxuICAgICAgICByZXR1cm4gKHJ1bkd1YXJkUXVldWUoZ3VhcmRzKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGdsb2JhbCBndWFyZHMgYmVmb3JlRWFjaFxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVHdWFyZHMubGlzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGluIGNvbXBvbmVudHMgYmVmb3JlUm91dGVVcGRhdGVcclxuICAgICAgICAgICAgZ3VhcmRzID0gZXh0cmFjdENvbXBvbmVudHNHdWFyZHModXBkYXRpbmdSZWNvcmRzLCAnYmVmb3JlUm91dGVVcGRhdGUnLCB0bywgZnJvbSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHVwZGF0aW5nUmVjb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkLnVwZGF0ZUd1YXJkcy5mb3JFYWNoKGd1YXJkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSByb3V0ZSBiZWZvcmVFbnRlclxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgdG8ubWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHRyaWdnZXIgYmVmb3JlRW50ZXIgb24gcmV1c2VkIHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmJlZm9yZUVudGVyICYmICFmcm9tLm1hdGNoZWQuaW5jbHVkZXMocmVjb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5iZWZvcmVFbnRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVFbnRlciBvZiByZWNvcmQuYmVmb3JlRW50ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGJlZm9yZUVudGVyLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihyZWNvcmQuYmVmb3JlRW50ZXIsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAgICAgLy8gcnVuIHRoZSBxdWV1ZSBvZiBwZXIgcm91dGUgYmVmb3JlRW50ZXIgZ3VhcmRzXHJcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IHRvLm1hdGNoZWQgaXMgbm9ybWFsaXplZCBhbmQgZG9lcyBub3QgY29udGFpbiBhbnkgKCkgPT4gUHJvbWlzZTxDb21wb25lbnQ+XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGVudGVyQ2FsbGJhY2tzLCB0aGVzZSBhcmUgYWRkZWQgYnkgZXh0cmFjdENvbXBvbmVudHNHdWFyZHNcclxuICAgICAgICAgICAgdG8ubWF0Y2hlZC5mb3JFYWNoKHJlY29yZCA9PiAocmVjb3JkLmVudGVyQ2FsbGJhY2tzID0ge30pKTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaW4tY29tcG9uZW50IGJlZm9yZVJvdXRlRW50ZXJcclxuICAgICAgICAgICAgZ3VhcmRzID0gZXh0cmFjdENvbXBvbmVudHNHdWFyZHMoZW50ZXJpbmdSZWNvcmRzLCAnYmVmb3JlUm91dGVFbnRlcicsIHRvLCBmcm9tKTtcclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGdsb2JhbCBndWFyZHMgYmVmb3JlUmVzb2x2ZVxyXG4gICAgICAgICAgICBndWFyZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBndWFyZCBvZiBiZWZvcmVSZXNvbHZlR3VhcmRzLmxpc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihndWFyZCwgdG8sIGZyb20pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgICAgIHJldHVybiBydW5HdWFyZFF1ZXVlKGd1YXJkcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gY2F0Y2ggYW55IG5hdmlnYXRpb24gY2FuY2VsZWRcclxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBpc05hdmlnYXRpb25GYWlsdXJlKGVyciwgOCAvKiBOQVZJR0FUSU9OX0NBTkNFTExFRCAqLylcclxuICAgICAgICAgICAgPyBlcnJcclxuICAgICAgICAgICAgOiBQcm9taXNlLnJlamVjdChlcnIpKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmlnZ2VyQWZ0ZXJFYWNoKHRvLCBmcm9tLCBmYWlsdXJlKSB7XHJcbiAgICAgICAgLy8gbmF2aWdhdGlvbiBpcyBjb25maXJtZWQsIGNhbGwgYWZ0ZXJHdWFyZHNcclxuICAgICAgICAvLyBUT0RPOiB3cmFwIHdpdGggZXJyb3IgaGFuZGxlcnNcclxuICAgICAgICBmb3IgKGNvbnN0IGd1YXJkIG9mIGFmdGVyR3VhcmRzLmxpc3QoKSlcclxuICAgICAgICAgICAgZ3VhcmQodG8sIGZyb20sIGZhaWx1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAtIENsZWFucyB1cCBhbnkgbmF2aWdhdGlvbiBndWFyZHNcclxuICAgICAqIC0gQ2hhbmdlcyB0aGUgdXJsIGlmIG5lY2Vzc2FyeVxyXG4gICAgICogLSBDYWxscyB0aGUgc2Nyb2xsQmVoYXZpb3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluYWxpemVOYXZpZ2F0aW9uKHRvTG9jYXRpb24sIGZyb20sIGlzUHVzaCwgcmVwbGFjZSwgZGF0YSkge1xyXG4gICAgICAgIC8vIGEgbW9yZSByZWNlbnQgbmF2aWdhdGlvbiB0b29rIHBsYWNlXHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0NhbmNlbGVkTmF2aWdhdGlvbih0b0xvY2F0aW9uLCBmcm9tKTtcclxuICAgICAgICBpZiAoZXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIGFzIHB1c2ggaWYgaXQncyBub3QgdGhlIGZpcnN0IG5hdmlnYXRpb25cclxuICAgICAgICBjb25zdCBpc0ZpcnN0TmF2aWdhdGlvbiA9IGZyb20gPT09IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQ7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSAhaXNCcm93c2VyID8ge30gOiBoaXN0b3J5LnN0YXRlO1xyXG4gICAgICAgIC8vIGNoYW5nZSBVUkwgb25seSBpZiB0aGUgdXNlciBkaWQgYSBwdXNoL3JlcGxhY2UgYW5kIGlmIGl0J3Mgbm90IHRoZSBpbml0aWFsIG5hdmlnYXRpb24gYmVjYXVzZVxyXG4gICAgICAgIC8vIGl0J3MganVzdCByZWZsZWN0aW5nIHRoZSB1cmxcclxuICAgICAgICBpZiAoaXNQdXNoKSB7XHJcbiAgICAgICAgICAgIC8vIG9uIHRoZSBpbml0aWFsIG5hdmlnYXRpb24sIHdlIHdhbnQgdG8gcmV1c2UgdGhlIHNjcm9sbCBwb3NpdGlvbiBmcm9tXHJcbiAgICAgICAgICAgIC8vIGhpc3Rvcnkgc3RhdGUgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlIHx8IGlzRmlyc3ROYXZpZ2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5yZXBsYWNlKHRvTG9jYXRpb24uZnVsbFBhdGgsIGFzc2lnbih7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiBpc0ZpcnN0TmF2aWdhdGlvbiAmJiBzdGF0ZSAmJiBzdGF0ZS5zY3JvbGwsXHJcbiAgICAgICAgICAgICAgICB9LCBkYXRhKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJvdXRlckhpc3RvcnkucHVzaCh0b0xvY2F0aW9uLmZ1bGxQYXRoLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWNjZXB0IGN1cnJlbnQgbmF2aWdhdGlvblxyXG4gICAgICAgIGN1cnJlbnRSb3V0ZS52YWx1ZSA9IHRvTG9jYXRpb247XHJcbiAgICAgICAgaGFuZGxlU2Nyb2xsKHRvTG9jYXRpb24sIGZyb20sIGlzUHVzaCwgaXNGaXJzdE5hdmlnYXRpb24pO1xyXG4gICAgICAgIG1hcmtBc1JlYWR5KCk7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVtb3ZlSGlzdG9yeUxpc3RlbmVyO1xyXG4gICAgLy8gYXR0YWNoIGxpc3RlbmVyIHRvIGhpc3RvcnkgdG8gdHJpZ2dlciBuYXZpZ2F0aW9uc1xyXG4gICAgZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgLy8gYXZvaWQgc2V0dGluZyB1cCBsaXN0ZW5lcnMgdHdpY2UgZHVlIHRvIGFuIGludmFsaWQgZmlyc3QgbmF2aWdhdGlvblxyXG4gICAgICAgIGlmIChyZW1vdmVIaXN0b3J5TGlzdGVuZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICByZW1vdmVIaXN0b3J5TGlzdGVuZXIgPSByb3V0ZXJIaXN0b3J5Lmxpc3RlbigodG8sIF9mcm9tLCBpbmZvKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBhIHJlZGlyZWN0IHJvdXRlIGJlY2F1c2UgaXQgd2FzIGluIGhpc3RvcnlcclxuICAgICAgICAgICAgY29uc3QgdG9Mb2NhdGlvbiA9IHJlc29sdmUodG8pO1xyXG4gICAgICAgICAgICAvLyBkdWUgdG8gZHluYW1pYyByb3V0aW5nLCBhbmQgdG8gaGFzaCBoaXN0b3J5IHdpdGggbWFudWFsIG5hdmlnYXRpb25cclxuICAgICAgICAgICAgLy8gKG1hbnVhbGx5IGNoYW5naW5nIHRoZSB1cmwgb3IgY2FsbGluZyBoaXN0b3J5Lmhhc2ggPSAnIy9zb21ld2hlcmUnKSxcclxuICAgICAgICAgICAgLy8gdGhlcmUgY291bGQgYmUgYSByZWRpcmVjdCByZWNvcmQgaW4gaGlzdG9yeVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZWRpcmVjdCA9IGhhbmRsZVJlZGlyZWN0UmVjb3JkKHRvTG9jYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVkaXJlY3QpIHtcclxuICAgICAgICAgICAgICAgIHB1c2hXaXRoUmVkaXJlY3QoYXNzaWduKHNob3VsZFJlZGlyZWN0LCB7IHJlcGxhY2U6IHRydWUgfSksIHRvTG9jYXRpb24pLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBlbmRpbmdMb2NhdGlvbiA9IHRvTG9jYXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBjdXJyZW50Um91dGUudmFsdWU7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBiZSBtb3ZlZCB0byB3ZWIgaGlzdG9yeT9cclxuICAgICAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgc2F2ZVNjcm9sbFBvc2l0aW9uKGdldFNjcm9sbEtleShmcm9tLmZ1bGxQYXRoLCBpbmZvLmRlbHRhKSwgY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hdmlnYXRlKHRvTG9jYXRpb24sIGZyb20pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uRmFpbHVyZShlcnJvciwgNCAvKiBOQVZJR0FUSU9OX0FCT1JURUQgKi8gfCA4IC8qIE5BVklHQVRJT05fQ0FOQ0VMTEVEICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yLCAyIC8qIE5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBjb3VsZCBjYWxsIGlmIChpbmZvLmRlbHRhKSByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbHNlKSBidXQgdGhpcyBpcyBidWcgcHJvbmUgYXMgd2UgaGF2ZSBubyB3YXkgdG8gd2FpdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYXZpZ2F0aW9uIHRvIGJlIGZpbmlzaGVkIGJlZm9yZSBjYWxsaW5nIHB1c2hXaXRoUmVkaXJlY3QuIFVzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzZXRUaW1lb3V0IG9mIDE2bXMgc2VlbXMgdG8gd29yayBidXQgdGhlcmUgaXMgbm90IGd1YXJhbnRlZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0byB3b3JrIG9uIGV2ZXJ5IGJyb3dzZXIuIFNvIEluc3RlYWQgd2UgZG8gbm90IHJlc3RvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBhbmQgdHJpZ2dlciBhIG5ldyBuYXZpZ2F0aW9uIGFzIHJlcXVlc3RlZCBieSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYXZpZ2F0aW9uIGd1YXJkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBlcnJvciBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgcm91dGVyLnB1c2ggd2UganVzdCB3YW50IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyB0aGUgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2l0aFJlZGlyZWN0KGVycm9yLnRvLCB0b0xvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgYW4gdW5jYXVnaHQgcmVqZWN0aW9uLCBsZXQgcHVzaCBjYWxsIHRyaWdnZXJFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZmFpbHVyZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbnVhbCBjaGFuZ2UgaW4gaGFzaCBoaXN0b3J5ICM5MTYgZW5kaW5nIHVwIGluIHRoZSBVUkwgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5naW5nIGJ1dCBpdCB3YXMgY2hhbmdlZCBieSB0aGUgbWFudWFsIHVybCBjaGFuZ2UsIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFudWFsbHkgY2hhbmdlIGl0IG91cnNlbHZlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uRmFpbHVyZShmYWlsdXJlLCA0IC8qIE5BVklHQVRJT05fQUJPUlRFRCAqLyB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNiAvKiBOQVZJR0FUSU9OX0RVUExJQ0FURUQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5mby5kZWx0YSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby50eXBlID09PSBOYXZpZ2F0aW9uVHlwZS5wb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlckhpc3RvcnkuZ28oLTEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChub29wKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCB0aGUgdGhlbiBicmFuY2hcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCByZXN0b3JlIGhpc3Rvcnkgb24gdW5rbm93biBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmRlbHRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlckhpc3RvcnkuZ28oLWluZm8uZGVsdGEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVucmVjb2duaXplZCBlcnJvciwgdHJhbnNmZXIgdG8gdGhlIGdsb2JhbCBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlckVycm9yKGVycm9yLCB0b0xvY2F0aW9uLCBmcm9tKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChmYWlsdXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlID1cclxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplTmF2aWdhdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgbmF2aWdhdGlvbiwgYWxsIG1hdGNoZWQgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9Mb2NhdGlvbiwgZnJvbSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IHRoZSBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlckhpc3RvcnkuZ28oLWluZm8uZGVsdGEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5mby50eXBlID09PSBOYXZpZ2F0aW9uVHlwZS5wb3AgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOYXZpZ2F0aW9uRmFpbHVyZShmYWlsdXJlLCA0IC8qIE5BVklHQVRJT05fQUJPUlRFRCAqLyB8IDE2IC8qIE5BVklHQVRJT05fRFVQTElDQVRFRCAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsIGNoYW5nZSBpbiBoYXNoIGhpc3RvcnkgIzkxNlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGxpa2UgYSBwdXNoIGJ1dCBsYWNrcyB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC0xLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFmdGVyRWFjaCh0b0xvY2F0aW9uLCBmcm9tLCBmYWlsdXJlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChub29wKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCBFcnJvcnNcclxuICAgIGxldCByZWFkeUhhbmRsZXJzID0gdXNlQ2FsbGJhY2tzKCk7XHJcbiAgICBsZXQgZXJyb3JIYW5kbGVycyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgbGV0IHJlYWR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGVycm9ySGFuZGxlcnMgYWRkZWQgdmlhIG9uRXJyb3IgYW5kIHRocm93cyB0aGUgZXJyb3IgYXMgd2VsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlcnJvciAtIGVycm9yIHRvIHRocm93XHJcbiAgICAgKiBAcGFyYW0gdG8gLSBsb2NhdGlvbiB3ZSB3ZXJlIG5hdmlnYXRpbmcgdG8gd2hlbiB0aGUgZXJyb3IgaGFwcGVuZWRcclxuICAgICAqIEBwYXJhbSBmcm9tIC0gbG9jYXRpb24gd2Ugd2VyZSBuYXZpZ2F0aW5nIGZyb20gd2hlbiB0aGUgZXJyb3IgaGFwcGVuZWRcclxuICAgICAqIEByZXR1cm5zIHRoZSBlcnJvciBhcyBhIHJlamVjdGVkIHByb21pc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJpZ2dlckVycm9yKGVycm9yLCB0bywgZnJvbSkge1xyXG4gICAgICAgIG1hcmtBc1JlYWR5KGVycm9yKTtcclxuICAgICAgICBjb25zdCBsaXN0ID0gZXJyb3JIYW5kbGVycy5saXN0KCk7XHJcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZXJyb3IsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzUmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHJlYWR5ICYmIGN1cnJlbnRSb3V0ZS52YWx1ZSAhPT0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRClcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlYWR5SGFuZGxlcnMuYWRkKFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcmtBc1JlYWR5KGVycikge1xyXG4gICAgICAgIGlmICghcmVhZHkpIHtcclxuICAgICAgICAgICAgLy8gc3RpbGwgbm90IHJlYWR5IGlmIGFuIGVycm9yIGhhcHBlbmVkXHJcbiAgICAgICAgICAgIHJlYWR5ID0gIWVycjtcclxuICAgICAgICAgICAgc2V0dXBMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgcmVhZHlIYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgLmxpc3QoKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKFtyZXNvbHZlLCByZWplY3RdKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpKTtcclxuICAgICAgICAgICAgcmVhZHlIYW5kbGVycy5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG4gICAgLy8gU2Nyb2xsIGJlaGF2aW9yXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwodG8sIGZyb20sIGlzUHVzaCwgaXNGaXJzdE5hdmlnYXRpb24pIHtcclxuICAgICAgICBjb25zdCB7IHNjcm9sbEJlaGF2aW9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICFzY3JvbGxCZWhhdmlvcilcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gKCFpc1B1c2ggJiYgZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkodG8uZnVsbFBhdGgsIDApKSkgfHxcclxuICAgICAgICAgICAgKChpc0ZpcnN0TmF2aWdhdGlvbiB8fCAhaXNQdXNoKSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZS5zY3JvbGwpIHx8XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2Nyb2xsQmVoYXZpb3IodG8sIGZyb20sIHNjcm9sbFBvc2l0aW9uKSlcclxuICAgICAgICAgICAgLnRoZW4ocG9zaXRpb24gPT4gcG9zaXRpb24gJiYgc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbikpXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdHJpZ2dlckVycm9yKGVyciwgdG8sIGZyb20pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGdvID0gKGRlbHRhKSA9PiByb3V0ZXJIaXN0b3J5LmdvKGRlbHRhKTtcclxuICAgIGxldCBzdGFydGVkO1xyXG4gICAgY29uc3QgaW5zdGFsbGVkQXBwcyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJvdXRlciA9IHtcclxuICAgICAgICBjdXJyZW50Um91dGUsXHJcbiAgICAgICAgYWRkUm91dGUsXHJcbiAgICAgICAgcmVtb3ZlUm91dGUsXHJcbiAgICAgICAgaGFzUm91dGUsXHJcbiAgICAgICAgZ2V0Um91dGVzLFxyXG4gICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBwdXNoLFxyXG4gICAgICAgIHJlcGxhY2UsXHJcbiAgICAgICAgZ28sXHJcbiAgICAgICAgYmFjazogKCkgPT4gZ28oLTEpLFxyXG4gICAgICAgIGZvcndhcmQ6ICgpID0+IGdvKDEpLFxyXG4gICAgICAgIGJlZm9yZUVhY2g6IGJlZm9yZUd1YXJkcy5hZGQsXHJcbiAgICAgICAgYmVmb3JlUmVzb2x2ZTogYmVmb3JlUmVzb2x2ZUd1YXJkcy5hZGQsXHJcbiAgICAgICAgYWZ0ZXJFYWNoOiBhZnRlckd1YXJkcy5hZGQsXHJcbiAgICAgICAgb25FcnJvcjogZXJyb3JIYW5kbGVycy5hZGQsXHJcbiAgICAgICAgaXNSZWFkeSxcclxuICAgICAgICBpbnN0YWxsKGFwcCkge1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBhcHAuY29tcG9uZW50KCdSb3V0ZXJMaW5rJywgUm91dGVyTGluayk7XHJcbiAgICAgICAgICAgIGFwcC5jb21wb25lbnQoJ1JvdXRlclZpZXcnLCBSb3V0ZXJWaWV3KTtcclxuICAgICAgICAgICAgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRyb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsICckcm91dGUnLCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihjdXJyZW50Um91dGUpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gdGhpcyBpbml0aWFsIG5hdmlnYXRpb24gaXMgb25seSBuZWNlc3Nhcnkgb24gY2xpZW50LCBvbiBzZXJ2ZXIgaXQgZG9lc24ndFxyXG4gICAgICAgICAgICAvLyBtYWtlIHNlbnNlIGJlY2F1c2UgaXQgd2lsbCBjcmVhdGUgYW4gZXh0cmEgdW5uZWNlc3NhcnkgbmF2aWdhdGlvbiBhbmQgY291bGRcclxuICAgICAgICAgICAgLy8gbGVhZCB0byBwcm9ibGVtc1xyXG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyICYmXHJcbiAgICAgICAgICAgICAgICAvLyB1c2VkIGZvciB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uIGNsaWVudCBzaWRlIHRvIGF2b2lkIHB1c2hpbmdcclxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIHJvdXRlciBpcyB1c2VkIGluIG11bHRpcGxlIGFwcHNcclxuICAgICAgICAgICAgICAgICFzdGFydGVkICYmXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um91dGUudmFsdWUgPT09IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNlZSBhYm92ZVxyXG4gICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwdXNoKHJvdXRlckhpc3RvcnkubG9jYXRpb24pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignVW5leHBlY3RlZCBlcnJvciB3aGVuIHN0YXJ0aW5nIHRoZSByb3V0ZXI6JywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWN0aXZlUm91dGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhlIGtleSBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICByZWFjdGl2ZVJvdXRlW2tleV0gPSBjb21wdXRlZCgoKSA9PiBjdXJyZW50Um91dGUudmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwLnByb3ZpZGUocm91dGVyS2V5LCByb3V0ZXIpO1xyXG4gICAgICAgICAgICBhcHAucHJvdmlkZShyb3V0ZUxvY2F0aW9uS2V5LCByZWFjdGl2ZShyZWFjdGl2ZVJvdXRlKSk7XHJcbiAgICAgICAgICAgIGFwcC5wcm92aWRlKHJvdXRlclZpZXdMb2NhdGlvbktleSwgY3VycmVudFJvdXRlKTtcclxuICAgICAgICAgICAgY29uc3QgdW5tb3VudEFwcCA9IGFwcC51bm1vdW50O1xyXG4gICAgICAgICAgICBpbnN0YWxsZWRBcHBzLmFkZChhcHApO1xyXG4gICAgICAgICAgICBhcHAudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbGxlZEFwcHMuZGVsZXRlKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm91dGVyIGlzIG5vdCBhdHRhY2hlZCB0byBhbiBhcHAgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZEFwcHMuc2l6ZSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBjdXJyZW50IG5hdmlnYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTG9jYXRpb24gPSBTVEFSVF9MT0NBVElPTl9OT1JNQUxJWkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUhpc3RvcnlMaXN0ZW5lciAmJiByZW1vdmVIaXN0b3J5TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVIaXN0b3J5TGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZS52YWx1ZSA9IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50QXBwKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgaXNCcm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICBhZGREZXZ0b29scyhhcHAsIHJvdXRlciwgbWF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiByb3V0ZXI7XHJcbn1cclxuZnVuY3Rpb24gcnVuR3VhcmRRdWV1ZShndWFyZHMpIHtcclxuICAgIHJldHVybiBndWFyZHMucmVkdWNlKChwcm9taXNlLCBndWFyZCkgPT4gcHJvbWlzZS50aGVuKCgpID0+IGd1YXJkKCkpLCBQcm9taXNlLnJlc29sdmUoKSk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdENoYW5naW5nUmVjb3Jkcyh0bywgZnJvbSkge1xyXG4gICAgY29uc3QgbGVhdmluZ1JlY29yZHMgPSBbXTtcclxuICAgIGNvbnN0IHVwZGF0aW5nUmVjb3JkcyA9IFtdO1xyXG4gICAgY29uc3QgZW50ZXJpbmdSZWNvcmRzID0gW107XHJcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1heChmcm9tLm1hdGNoZWQubGVuZ3RoLCB0by5tYXRjaGVkLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkRnJvbSA9IGZyb20ubWF0Y2hlZFtpXTtcclxuICAgICAgICBpZiAocmVjb3JkRnJvbSkge1xyXG4gICAgICAgICAgICBpZiAodG8ubWF0Y2hlZC5maW5kKHJlY29yZCA9PiBpc1NhbWVSb3V0ZVJlY29yZChyZWNvcmQsIHJlY29yZEZyb20pKSlcclxuICAgICAgICAgICAgICAgIHVwZGF0aW5nUmVjb3Jkcy5wdXNoKHJlY29yZEZyb20pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nUmVjb3Jkcy5wdXNoKHJlY29yZEZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWNvcmRUbyA9IHRvLm1hdGNoZWRbaV07XHJcbiAgICAgICAgaWYgKHJlY29yZFRvKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSB0eXBlIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2Ugd2UgYXJlIGNvbXBhcmluZyBwZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGlmICghZnJvbS5tYXRjaGVkLmZpbmQocmVjb3JkID0+IGlzU2FtZVJvdXRlUmVjb3JkKHJlY29yZCwgcmVjb3JkVG8pKSkge1xyXG4gICAgICAgICAgICAgICAgZW50ZXJpbmdSZWNvcmRzLnB1c2gocmVjb3JkVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtsZWF2aW5nUmVjb3JkcywgdXBkYXRpbmdSZWNvcmRzLCBlbnRlcmluZ1JlY29yZHNdO1xyXG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByb3V0ZXIgaW5zdGFuY2UuIEVxdWl2YWxlbnQgdG8gdXNpbmcgYCRyb3V0ZXJgIGluc2lkZVxyXG4gKiB0ZW1wbGF0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VSb3V0ZXIoKSB7XHJcbiAgICByZXR1cm4gaW5qZWN0KHJvdXRlcktleSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm91dGUgbG9jYXRpb24uIEVxdWl2YWxlbnQgdG8gdXNpbmcgYCRyb3V0ZWAgaW5zaWRlXHJcbiAqIHRlbXBsYXRlcy5cclxuICovXHJcbmZ1bmN0aW9uIHVzZVJvdXRlKCkge1xyXG4gICAgcmV0dXJuIGluamVjdChyb3V0ZUxvY2F0aW9uS2V5KTtcclxufVxuXG5leHBvcnQgeyBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUsIFJvdXRlckxpbmssIFJvdXRlclZpZXcsIFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQgYXMgU1RBUlRfTE9DQVRJT04sIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZVJvdXRlciwgY3JlYXRlUm91dGVyTWF0Y2hlciwgY3JlYXRlV2ViSGFzaEhpc3RvcnksIGNyZWF0ZVdlYkhpc3RvcnksIGlzTmF2aWdhdGlvbkZhaWx1cmUsIG1hdGNoZWRSb3V0ZUtleSwgb25CZWZvcmVSb3V0ZUxlYXZlLCBvbkJlZm9yZVJvdXRlVXBkYXRlLCBwYXJzZVF1ZXJ5LCByb3V0ZUxvY2F0aW9uS2V5LCByb3V0ZXJLZXksIHJvdXRlclZpZXdMb2NhdGlvbktleSwgc3RyaW5naWZ5UXVlcnksIHVzZUxpbmssIHVzZVJvdXRlLCB1c2VSb3V0ZXIsIHZpZXdEZXB0aEtleSB9O1xuIiwiaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4sIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBpcyB0aGUgXCJmdWxsLWJ1aWxkXCIgdGhhdCBpbmNsdWRlcyBib3RoIHRoZSBydW50aW1lXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGluaXREZXYoKTtcclxufVxyXG5jb25zdCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5ID0gdGVtcGxhdGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWVsKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3MgcmVuZGVyZWRcclxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe1xyXG4gICAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxyXG4gICAgICAgIG9uRXJyb3I6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IG9uRXJyb3IgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgb25XYXJuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBlID0+IG9uRXJyb3IoZSwgdHJ1ZSkgOiBOT09QXHJcbiAgICB9LCBvcHRpb25zKSk7XHJcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgYXNXYXJuaW5nID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXNXYXJuaW5nXHJcbiAgICAgICAgICAgID8gZXJyLm1lc3NhZ2VcclxuICAgICAgICAgICAgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcclxuICAgICAgICBjb25zdCBjb2RlRnJhbWUgPSBlcnIubG9jICYmXHJcbiAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlcnIubG9jLnN0YXJ0Lm9mZnNldCwgZXJyLmxvYy5lbmQub2Zmc2V0KTtcclxuICAgICAgICB3YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHdpbGRjYXJkIGltcG9ydCByZXN1bHRzIGluIGEgaHVnZSBvYmplY3Qgd2l0aCBldmVyeSBleHBvcnRcclxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cclxuICAgIC8vIEluIHRoZSBnbG9iYWwgYnVpbGQgd2Uga25vdyBgVnVlYCBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgc28gd2UgY2FuIGF2b2lkXHJcbiAgICAvLyB0aGUgd2lsZGNhcmQgb2JqZWN0LlxyXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbSkpO1xyXG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XHJcbiAgICByZXR1cm4gKGNvbXBpbGVDYWNoZVtrZXldID0gcmVuZGVyKTtcclxufVxyXG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==